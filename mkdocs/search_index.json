{
    "docs": [
        {
            "location": "/", 
            "text": "bfg9000\n\n\nbfg9000\n (\n\"build file generator\"\n) is a cross-platform \nbuild configuration\nsystem\n with an emphasis on making it easy to define how to build your software.\nIt converts a Python-based build script into the appropriate files for your\nunderlying build system of choice.\n\n\nWhy bfg9000?\n\n\n\n\nAlready familiar\n\n\nbuild.bfg\n files are just Python scripts with some new functions added, so you\nmay already know how to write them; and when your build gets complicated, you\ncan rely on the existing Python ecosystem to get you out of trouble.\n\n\nBuild fast\n\n\nPython may be slow, but bfg9000 gets out of the way as quickly as possible and\nrelies on existing, mature build systems like Make and Ninja to do the heavy\nlifting of building your software.\n\n\nStay sane\n\n\nBuilding your code shouldn't be the hard part of developing your project. Above\nall else, bfg9000 strives to make it easy to write your build scripts.\n\n\n\n\nA brief example\n\n\nYou can't get much simpler than the simplest \nbuild.bfg\n file:\n\n\nexecutable('simple', files=['simple.cpp'])\n\n\n\n\nTo build this executable, we need to create the actual build files and then\nrun them:\n\n\n$ bfg9000 path/to/src/ build/\n$ cd build\n$ ninja\n\n\n\n\nFrom there, you can run your newly-created executable: \n./simple\n. Hooray!\n\n\nFor further examples, please see the\n\nexamples/\n\nsubdirectory.", 
            "title": "Home"
        }, 
        {
            "location": "/#bfg9000", 
            "text": "bfg9000  ( \"build file generator\" ) is a cross-platform  build configuration\nsystem  with an emphasis on making it easy to define how to build your software.\nIt converts a Python-based build script into the appropriate files for your\nunderlying build system of choice.", 
            "title": "bfg9000"
        }, 
        {
            "location": "/#why-bfg9000", 
            "text": "", 
            "title": "Why bfg9000?"
        }, 
        {
            "location": "/#already-familiar", 
            "text": "build.bfg  files are just Python scripts with some new functions added, so you\nmay already know how to write them; and when your build gets complicated, you\ncan rely on the existing Python ecosystem to get you out of trouble.", 
            "title": "Already familiar"
        }, 
        {
            "location": "/#build-fast", 
            "text": "Python may be slow, but bfg9000 gets out of the way as quickly as possible and\nrelies on existing, mature build systems like Make and Ninja to do the heavy\nlifting of building your software.", 
            "title": "Build fast"
        }, 
        {
            "location": "/#stay-sane", 
            "text": "Building your code shouldn't be the hard part of developing your project. Above\nall else, bfg9000 strives to make it easy to write your build scripts.", 
            "title": "Stay sane"
        }, 
        {
            "location": "/#a-brief-example", 
            "text": "You can't get much simpler than the simplest  build.bfg  file:  executable('simple', files=['simple.cpp'])  To build this executable, we need to create the actual build files and then\nrun them:  $ bfg9000 path/to/src/ build/\n$ cd build\n$ ninja  From there, you can run your newly-created executable:  ./simple . Hooray!  For further examples, please see the examples/ \nsubdirectory.", 
            "title": "A brief example"
        }, 
        {
            "location": "/install/", 
            "text": "Installation\n\n\nbfg9000 uses \nsetuptools\n, so installation\nis much the same as any other Python package:\n\n\n$ pip install .\n\n\n\n\nIf you've downloaded bfg, just run \npip install .\n from the source directory.\n(Equivalently, you can run \npython setup.py install\n.) From there, you can start\nusing bfg to build your software!\n\n\nInstalling patchelf\n\n\nOn Linux, bfg9000 requires \npatchelf\n in order\nto modify \nrpath\ns of executables and\nshared libraries when installing. The setup script will automatically download\nand install patchelf when installing the rest of bfg9000. If you're installing\nbfg into a \nvirtualenv\n, patchelf\nwill go into \n$VIRTUAL_ENV/bin\n. You can also manually install patchelf from the\nsetup script with the following command (assuming you've downloaded bfg's\nsource):\n\n\n$ python setup.py install_patchelf\n\n\n\n\nIf you'd prefer not to install patchelf at all, simply set the environment\nvariable \nNO_PATCHELF\n to \n1\n before installing bfg9000:\n\n\n$ NO_PATCHELF=1 pip install bfg9000\n\n\n\n\nInstalling MSBuild support\n\n\nSince many users don't need it, MSBuild support is an optional feature. To\ninstall all the dependencies required for MSBuild, you can run the following:\n\n\n$ pip install bfg9000[msbuild]", 
            "title": "Installation"
        }, 
        {
            "location": "/install/#installation", 
            "text": "bfg9000 uses  setuptools , so installation\nis much the same as any other Python package:  $ pip install .  If you've downloaded bfg, just run  pip install .  from the source directory.\n(Equivalently, you can run  python setup.py install .) From there, you can start\nusing bfg to build your software!", 
            "title": "Installation"
        }, 
        {
            "location": "/install/#installing-patchelf", 
            "text": "On Linux, bfg9000 requires  patchelf  in order\nto modify  rpath s of executables and\nshared libraries when installing. The setup script will automatically download\nand install patchelf when installing the rest of bfg9000. If you're installing\nbfg into a  virtualenv , patchelf\nwill go into  $VIRTUAL_ENV/bin . You can also manually install patchelf from the\nsetup script with the following command (assuming you've downloaded bfg's\nsource):  $ python setup.py install_patchelf  If you'd prefer not to install patchelf at all, simply set the environment\nvariable  NO_PATCHELF  to  1  before installing bfg9000:  $ NO_PATCHELF=1 pip install bfg9000", 
            "title": "Installing patchelf"
        }, 
        {
            "location": "/install/#installing-msbuild-support", 
            "text": "Since many users don't need it, MSBuild support is an optional feature. To\ninstall all the dependencies required for MSBuild, you can run the following:  $ pip install bfg9000[msbuild]", 
            "title": "Installing MSBuild support"
        }, 
        {
            "location": "/user/building/", 
            "text": "Building With bfg9000\n\n\nLike some other tools (e.g. \nCMake\n or\n\nautotools\n), bfg9000 isn't actually a\nbuild system; it's a \nbuild configuration system\n or, if you prefer, a\n\nmeta-build system\n. That is, bfg9000 builds build files which you then use to\nrun your actual builds.\n\n\nYour first build\n\n\nInvoking bfg9000 is simple. Assuming you have an existing project that uses\nbfg9000, just call \nbfg9000 srcdir builddir\n and it will generate the final\nbuild script (\nbuild.ninja\n in this case) in \nbuilddir\n to use for\nbuilding your project:\n\n\n$ bfg9000 path/to/src/ build/\n$ cd build\n$ ninja\n\n\n\n\n\n\nNote\n\n\nOn Windows, using bfg9000 requires a bit more care. Since the MSVC tools\naren't in the \nPATH\n by default, you can't just open any command prompt.\nYou need to pick the \ncorrect\n prompt. Thankfully, Visual Studio provides\nStart Menu items such as \"VS2015 Developer Command Prompt\". These add the\nappropiate directories to the \nPATH\n, allowing you to use whichever version\nof the MSVC tools that you'd like.\n\n\n\n\nBuild directories\n\n\nYou might have noticed above that \nbuild.ninja\n was placed in a separate\ndirectory. This is because bfg9000 exclusively uses \nout-of-tree builds\n; that\nis, the build directory must be different from the source directory. While\nslightly more inconvenient for one-off builds (users will have to \ncd\n into\nanother directory to start the build), the benefits are significant. First, it\nensures that cleaning a build is trivial: just remove the build directory.\nSecond, simplifies building in multiple configurations, a very useful feature\nfor development; you can easily have debug and optimized builds sitting\nside-by-side.\n\n\nIn our example above, we explicitly specified both the source and build\ndirectories. However, for convenience, only one of them is required. If you're\nalready in a source directory (i.e. a directory which contains a \nbuild.bfg\n\nfile), then you can simply say \nbfg9000 builddir\n. If you're in a build\ndirectory (i.e. a directory which does \nnot\n contain a \nbuild.bfg\n file), then\nyou can instead say \nbfg9000 srcdir\n.\n\n\nSelecting a backend\n\n\nBy default, bfg9000 tries to use the most appropriate build backend for your\nsystem. In descending order, bfg prefers \nninja\n,\n\nmake\n, and\n\nmsbuild\n.\nIf one of these isn't installed, it will try the next best option. However, you\ncan explicitly select a backend with the \n--backend\n option. For instance, to\nbuild a Makefile even if Ninja is installed:\n\n\n$ bfg9000 --backend make srcdir builddir\n\n\n\n\nSetting options\n\n\nMany options for building can be set via the environment. These generally follow\nthe UNIX naming conventions, so you can use, say,\n\nCXX\n to change the C++ compiler that bfg9000 uses.\nFor a full listing of the recognized environment variables, see the \nEnvironment\nVariables\n chapter.\n\n\nInstalling your software\n\n\nAfter building your software, you may wish to install it to another directory on\nyour system. By default, bfg9000 will install them into the appropriate place\nfor your platform (e.g. \n/usr/local/bin\n for exectuables on POSIX systems).\nHowever, you can specify where you'd like to install your project when invoking\nbfg9000. To change the installation prefix (\n/usr/local\n on POSIX), just specify\n\n--prefix /path/to/prefix\n when running bfg9000. You can also specify the\nbinary, library, and include directories individually, using \n--bindir\n,\n\n--libdir\n, and \n--includedir\n, respectively.", 
            "title": "Building with bfg9000"
        }, 
        {
            "location": "/user/building/#building-with-bfg9000", 
            "text": "Like some other tools (e.g.  CMake  or autotools ), bfg9000 isn't actually a\nbuild system; it's a  build configuration system  or, if you prefer, a meta-build system . That is, bfg9000 builds build files which you then use to\nrun your actual builds.", 
            "title": "Building With bfg9000"
        }, 
        {
            "location": "/user/building/#your-first-build", 
            "text": "Invoking bfg9000 is simple. Assuming you have an existing project that uses\nbfg9000, just call  bfg9000 srcdir builddir  and it will generate the final\nbuild script ( build.ninja  in this case) in  builddir  to use for\nbuilding your project:  $ bfg9000 path/to/src/ build/\n$ cd build\n$ ninja   Note  On Windows, using bfg9000 requires a bit more care. Since the MSVC tools\naren't in the  PATH  by default, you can't just open any command prompt.\nYou need to pick the  correct  prompt. Thankfully, Visual Studio provides\nStart Menu items such as \"VS2015 Developer Command Prompt\". These add the\nappropiate directories to the  PATH , allowing you to use whichever version\nof the MSVC tools that you'd like.", 
            "title": "Your first build"
        }, 
        {
            "location": "/user/building/#build-directories", 
            "text": "You might have noticed above that  build.ninja  was placed in a separate\ndirectory. This is because bfg9000 exclusively uses  out-of-tree builds ; that\nis, the build directory must be different from the source directory. While\nslightly more inconvenient for one-off builds (users will have to  cd  into\nanother directory to start the build), the benefits are significant. First, it\nensures that cleaning a build is trivial: just remove the build directory.\nSecond, simplifies building in multiple configurations, a very useful feature\nfor development; you can easily have debug and optimized builds sitting\nside-by-side.  In our example above, we explicitly specified both the source and build\ndirectories. However, for convenience, only one of them is required. If you're\nalready in a source directory (i.e. a directory which contains a  build.bfg \nfile), then you can simply say  bfg9000 builddir . If you're in a build\ndirectory (i.e. a directory which does  not  contain a  build.bfg  file), then\nyou can instead say  bfg9000 srcdir .", 
            "title": "Build directories"
        }, 
        {
            "location": "/user/building/#selecting-a-backend", 
            "text": "By default, bfg9000 tries to use the most appropriate build backend for your\nsystem. In descending order, bfg prefers  ninja , make , and msbuild .\nIf one of these isn't installed, it will try the next best option. However, you\ncan explicitly select a backend with the  --backend  option. For instance, to\nbuild a Makefile even if Ninja is installed:  $ bfg9000 --backend make srcdir builddir", 
            "title": "Selecting a backend"
        }, 
        {
            "location": "/user/building/#setting-options", 
            "text": "Many options for building can be set via the environment. These generally follow\nthe UNIX naming conventions, so you can use, say, CXX  to change the C++ compiler that bfg9000 uses.\nFor a full listing of the recognized environment variables, see the  Environment\nVariables  chapter.", 
            "title": "Setting options"
        }, 
        {
            "location": "/user/building/#installing-your-software", 
            "text": "After building your software, you may wish to install it to another directory on\nyour system. By default, bfg9000 will install them into the appropriate place\nfor your platform (e.g.  /usr/local/bin  for exectuables on POSIX systems).\nHowever, you can specify where you'd like to install your project when invoking\nbfg9000. To change the installation prefix ( /usr/local  on POSIX), just specify --prefix /path/to/prefix  when running bfg9000. You can also specify the\nbinary, library, and include directories individually, using  --bindir , --libdir , and  --includedir , respectively.", 
            "title": "Installing your software"
        }, 
        {
            "location": "/user/writing/", 
            "text": "Writing a Build File\n\n\nbfg9000's build script is called \nbuild.bfg\n and is (usually) placed in the root\nof your source tree. \nbuild.bfg\n files are just Python scripts with a handful of\nextra built-in functions to define all the rules for building your software.\nWhile bfg9000's goal is to make writing build scripts easy, sometimes complexity\nis unavoidable. By using a general-purpose language, this complexity can\n(hopefully!) be managed.\n\n\nYour first build script\n\n\nThe simplest build script, compiling a single source file into an\n\nexecutable\n, is indeed very\nsimple:\n\n\nexecutable('simple', files=['simple.cpp'])\n\n\n\n\nThe above is all you need to build your executable for any supported build\nbackend and platform. The output file's name is automatically converted to the\nappropriate name for the target platform (\n'simple'\n on Linux and OS X and\n\n'simple.exe'\n on Windows).\n\n\nBuilding executables\n\n\nWe've already seen how to build simple executables, but build tools aren't much\ngood if that's all they can do! Naturally, it's easy to build an executable from\nmultiple source files (just add more elements to the \nfiles\n argument), but\nthere are plenty of other things you'd probably like to do with your build\nscripts.\n\n\nImplicit conversions\n\n\nbfg9000 tries its best to make your build scripts easy to read and to minimize\nverbosity. First, arguments that normally take a list can take a single item\ninstead, e.g. \nexecutable('simple', files='simple.cpp')\n. In addition, bfg9000\nwill automatically convert a string argument to an object of the appropriate\ntype. In the previous example, \n'simple.cpp'\n is automatically converted to a\n\nsource_file\n.\n\n\nSudirectories\n\n\nMany projects organize their headers and source files into different\ndirectories. For source files, this is easy to handle: just write out the\nrelative path to the file. For header files, you need to let your compiler know\nwhere they're located. The\n\nheader_directory\n function creates\na reference to the directory, which can then be passed to your build function\nvia the \ninclude\n argument:\n\n\ninclude_dir = header_directory('include')\nexecutable('program', files=['src/prog.cpp'], include=[include_dir])\n\n\n\n\nAs noted above, you can also simplify this to:\n\n\nexecutable('program', files='src/prog.cpp', include='include')\n\n\n\n\nOf course, bfg9000 also allows you to place built files in subdirectories as\nwell. Simply specify the relative path as the name of executable (or whatever\ntype of file you're building).\n\n\nOptions\n\n\nBuild scripts often need to set options when compiling/linking binaries.\nSometimes, these are specific to a single executable in the project, and other\ntimes they apply to \nall\n the binaries. bfg9000 supports both cases. You can\nprovide options for a single binary with the \ncompile_options\n and\n\nlink_options\n arguments:\n\n\nexecutable('simple', files=['simple.cpp'], compile_options=['-Wall', '-Werror'],\n           link_options=['-static-libstdc++'])\n\n\n\n\nYou can also specify \nglobal compiler\noptions\n (on a per-language basis) as\nwell as \nglobal linker options\n:\n\n\nglobal_options(['-Wall', '-Werror'], lang='c++')\nglobal_link_options(['-static-libstdc++'])\n\n\n\n\nNaturally, the interpretations of these arguments depend on the compiler being\nused, so it's important to be sure the compiler understands the arguments. You\ncan determine the kind of compiler being used by consulting the build's\n\nEnvironment\n and checking the compiler's\n\nflavor\n.\n\n\nBuilding libraries\n\n\nSimilar to building executables, you can also build\n\nshared\n and\n\nstatic\n libraries. These take\nthe same arguments as above, although static libraries have no use for the\n\nlink_options\n argument.\n\n\nOnce you've defined rules to build a library, you can pass it along to an\nexecutable or other shared library via the \nlibs\n argument:\n\n\nshared = shared_library('shared', files=['shared.cpp'])\nstatic = static_library('shared', files=['static.cpp'])\nexecutable('program', files=['program.cpp'], libs=[shared, static])\n\n\n\n\nFinding files\n\n\nFor projects with many source files, it can be inconvenient to manually list all\nof them. Since \nbuild.bfg\n files are just Python scripts, you \ncould\n use\nPython's standard library to examine the file system and build the list.\nHowever, there's a better way: bfg9000 provides a\n\nfind_files()\n\nfunction to fetch the list; if the list ever changes, the build files will be\nregenerated \nautomatically\n the next time they're run.\n\n\nfind_files()\n starts at a base directory and searches recursively for any files\nmatching a particular glob:\n\n\nhello_files = find_files('src/hello', '*.cpp')\nexecutable('hello', files=hello_files)\n\n\n\n\nThere are lots of options you can pass to \nfind_files()\n to tweak its behavior.\nFor instance, you can search only for files or only for directories by passing\n\n'f'\n or \n'd'\n, respectively to the \ntype\n argument.\n\n\nDefault targets\n\n\nWhen you're building multiple binaries, you might want to be able to specify\nwhat gets built by default, i.e. when calling \nmake\n (or \nninja\n) with no\narguments. Normally, every executable and library (except those passed to\n\ntest()\n) will get built.\nHowever, you can pass any build rule(s) to \ndefault()\n,\nand they'll be set as the default, overriding the normal behavior. This makes it\neasy to provide your users with a standard build that gets them all the bits\nthey need, and none they don't.\n\n\nExternal packages\n\n\nMost projects have external packages that they depend on. There are lots of\ndifferent ways these packages are organized, and bfg9000 currently supports two\nof them: \n\"system\" packages\n\n(libraries installed into the default location for your system) and \nBoost\npackages\n:\n\n\nogg = system_package('ogg', kind='static')\nprog_opts = boost_package('program_options', version='\n=1.55')\n\n\n\n\nEach of these returns an object representing the package that can be used when\nbuilding binaries by passing them in the \npackages\n argument:\n\n\nexecutable('program', files=['main.cpp'], packages=[ogg, prog_opts])\n\n\n\n\nInstallation\n\n\nAfter building, you might want to allow your project to be installed onto the\nuser's system somewhere. Most files (headers, executables, libraries) can be\nadded to the list of installed files via the\n\ninstall()\n rule. You can also install entire\ndirectories of headers:\n\n\ninclude_dir = header_directory('include')\nlib = static_library('program', files=['src/prog.cpp'], include=[include_dir])\ninstall(lib, include_dir)\n\n\n\n\nCommands\n\n\nIn addition to ordinary build rules, it can be useful to provide other common\ncommands that apply to a project's source, such as linting the code or building\ndocumentation. Normally, you should pass the command to be run as an array of\narguments. This will automatically handle escaping any quotes in each argument.\nThis is especially important for cross-platform compatibility, since different\nshells have different quoting rules:\n\n\ncommand('hello', cmd=['python', '-c', 'print(\nhello\n)'])\n\n\n\n\nOf course, if you need to use your shell's special characters (like \n), you\ncan simply pass a string to the \ncmd\n argument. In addition, you can supply\nmultiple commands to this function via the \ncmds\n argument:\n\n\ncommand('script', cmds=[\n    'touch file',\n    ['python', script.py']\n])\n\n\n\n\nAliases\n\n\nSometimes, you just want to group a set of targets together to make it easier to\nbuild all of them at once. This automatically happens for \ndefault\ntargets\n by creating an \nall\n alias, but you can do this\nyourself for any collection of targets:\n\n\nfoo = executable('foo', files=['foo.cpp'])\nbar = executable('bar', files=['bar.cpp'])\nalias('foobar', [foo, bar])\n\n\n\n\nTests\n\n\nAll good projects should have tests. Since your project is good (isn't it?),\nyours has tests too, and you should have a good way to execute those tests from\nyour build system. bfg9000 provides a \nset of\nfunctions\n for running tests. The most important of\nthese is aptly named\n\ntest()\n. Any executable can\nbe passed to this function, and it will be executed as a test; an exit status of\n0 marks success, and non-zero marks failure:\n\n\ntest( executable('test_foo', files=['test_foo.cpp']) )\n\n\n\n\nIn addition, you can provide a \ntest\ndriver\n that collects\nall of your tests together and runs them as one. \ntest_driver()\n takes an\nexecutable (a \nsystem_executable\n by\ndefault) that runs all the test files. This allows you to aggregate multiple\ntest files into a single run, which is very useful for reporting:\n\n\nmettle = test_driver('mettle')\ntest( executable('test_foo', files=['test_foo.cpp']), driver=mettle )\ntest( executable('test_bar', files=['test_bar.cpp']), driver=mettle )", 
            "title": "Writing a Build File"
        }, 
        {
            "location": "/user/writing/#writing-a-build-file", 
            "text": "bfg9000's build script is called  build.bfg  and is (usually) placed in the root\nof your source tree.  build.bfg  files are just Python scripts with a handful of\nextra built-in functions to define all the rules for building your software.\nWhile bfg9000's goal is to make writing build scripts easy, sometimes complexity\nis unavoidable. By using a general-purpose language, this complexity can\n(hopefully!) be managed.", 
            "title": "Writing a Build File"
        }, 
        {
            "location": "/user/writing/#your-first-build-script", 
            "text": "The simplest build script, compiling a single source file into an executable , is indeed very\nsimple:  executable('simple', files=['simple.cpp'])  The above is all you need to build your executable for any supported build\nbackend and platform. The output file's name is automatically converted to the\nappropriate name for the target platform ( 'simple'  on Linux and OS X and 'simple.exe'  on Windows).", 
            "title": "Your first build script"
        }, 
        {
            "location": "/user/writing/#building-executables", 
            "text": "We've already seen how to build simple executables, but build tools aren't much\ngood if that's all they can do! Naturally, it's easy to build an executable from\nmultiple source files (just add more elements to the  files  argument), but\nthere are plenty of other things you'd probably like to do with your build\nscripts.", 
            "title": "Building executables"
        }, 
        {
            "location": "/user/writing/#implicit-conversions", 
            "text": "bfg9000 tries its best to make your build scripts easy to read and to minimize\nverbosity. First, arguments that normally take a list can take a single item\ninstead, e.g.  executable('simple', files='simple.cpp') . In addition, bfg9000\nwill automatically convert a string argument to an object of the appropriate\ntype. In the previous example,  'simple.cpp'  is automatically converted to a source_file .", 
            "title": "Implicit conversions"
        }, 
        {
            "location": "/user/writing/#sudirectories", 
            "text": "Many projects organize their headers and source files into different\ndirectories. For source files, this is easy to handle: just write out the\nrelative path to the file. For header files, you need to let your compiler know\nwhere they're located. The header_directory  function creates\na reference to the directory, which can then be passed to your build function\nvia the  include  argument:  include_dir = header_directory('include')\nexecutable('program', files=['src/prog.cpp'], include=[include_dir])  As noted above, you can also simplify this to:  executable('program', files='src/prog.cpp', include='include')  Of course, bfg9000 also allows you to place built files in subdirectories as\nwell. Simply specify the relative path as the name of executable (or whatever\ntype of file you're building).", 
            "title": "Sudirectories"
        }, 
        {
            "location": "/user/writing/#options", 
            "text": "Build scripts often need to set options when compiling/linking binaries.\nSometimes, these are specific to a single executable in the project, and other\ntimes they apply to  all  the binaries. bfg9000 supports both cases. You can\nprovide options for a single binary with the  compile_options  and link_options  arguments:  executable('simple', files=['simple.cpp'], compile_options=['-Wall', '-Werror'],\n           link_options=['-static-libstdc++'])  You can also specify  global compiler\noptions  (on a per-language basis) as\nwell as  global linker options :  global_options(['-Wall', '-Werror'], lang='c++')\nglobal_link_options(['-static-libstdc++'])  Naturally, the interpretations of these arguments depend on the compiler being\nused, so it's important to be sure the compiler understands the arguments. You\ncan determine the kind of compiler being used by consulting the build's Environment  and checking the compiler's flavor .", 
            "title": "Options"
        }, 
        {
            "location": "/user/writing/#building-libraries", 
            "text": "Similar to building executables, you can also build shared  and static  libraries. These take\nthe same arguments as above, although static libraries have no use for the link_options  argument.  Once you've defined rules to build a library, you can pass it along to an\nexecutable or other shared library via the  libs  argument:  shared = shared_library('shared', files=['shared.cpp'])\nstatic = static_library('shared', files=['static.cpp'])\nexecutable('program', files=['program.cpp'], libs=[shared, static])", 
            "title": "Building libraries"
        }, 
        {
            "location": "/user/writing/#finding-files", 
            "text": "For projects with many source files, it can be inconvenient to manually list all\nof them. Since  build.bfg  files are just Python scripts, you  could  use\nPython's standard library to examine the file system and build the list.\nHowever, there's a better way: bfg9000 provides a find_files() \nfunction to fetch the list; if the list ever changes, the build files will be\nregenerated  automatically  the next time they're run.  find_files()  starts at a base directory and searches recursively for any files\nmatching a particular glob:  hello_files = find_files('src/hello', '*.cpp')\nexecutable('hello', files=hello_files)  There are lots of options you can pass to  find_files()  to tweak its behavior.\nFor instance, you can search only for files or only for directories by passing 'f'  or  'd' , respectively to the  type  argument.", 
            "title": "Finding files"
        }, 
        {
            "location": "/user/writing/#default-targets", 
            "text": "When you're building multiple binaries, you might want to be able to specify\nwhat gets built by default, i.e. when calling  make  (or  ninja ) with no\narguments. Normally, every executable and library (except those passed to test() ) will get built.\nHowever, you can pass any build rule(s) to  default() ,\nand they'll be set as the default, overriding the normal behavior. This makes it\neasy to provide your users with a standard build that gets them all the bits\nthey need, and none they don't.", 
            "title": "Default targets"
        }, 
        {
            "location": "/user/writing/#external-packages", 
            "text": "Most projects have external packages that they depend on. There are lots of\ndifferent ways these packages are organized, and bfg9000 currently supports two\nof them:  \"system\" packages \n(libraries installed into the default location for your system) and  Boost\npackages :  ogg = system_package('ogg', kind='static')\nprog_opts = boost_package('program_options', version=' =1.55')  Each of these returns an object representing the package that can be used when\nbuilding binaries by passing them in the  packages  argument:  executable('program', files=['main.cpp'], packages=[ogg, prog_opts])", 
            "title": "External packages"
        }, 
        {
            "location": "/user/writing/#installation", 
            "text": "After building, you might want to allow your project to be installed onto the\nuser's system somewhere. Most files (headers, executables, libraries) can be\nadded to the list of installed files via the install()  rule. You can also install entire\ndirectories of headers:  include_dir = header_directory('include')\nlib = static_library('program', files=['src/prog.cpp'], include=[include_dir])\ninstall(lib, include_dir)", 
            "title": "Installation"
        }, 
        {
            "location": "/user/writing/#commands", 
            "text": "In addition to ordinary build rules, it can be useful to provide other common\ncommands that apply to a project's source, such as linting the code or building\ndocumentation. Normally, you should pass the command to be run as an array of\narguments. This will automatically handle escaping any quotes in each argument.\nThis is especially important for cross-platform compatibility, since different\nshells have different quoting rules:  command('hello', cmd=['python', '-c', 'print( hello )'])  Of course, if you need to use your shell's special characters (like  ), you\ncan simply pass a string to the  cmd  argument. In addition, you can supply\nmultiple commands to this function via the  cmds  argument:  command('script', cmds=[\n    'touch file',\n    ['python', script.py']\n])", 
            "title": "Commands"
        }, 
        {
            "location": "/user/writing/#aliases", 
            "text": "Sometimes, you just want to group a set of targets together to make it easier to\nbuild all of them at once. This automatically happens for  default\ntargets  by creating an  all  alias, but you can do this\nyourself for any collection of targets:  foo = executable('foo', files=['foo.cpp'])\nbar = executable('bar', files=['bar.cpp'])\nalias('foobar', [foo, bar])", 
            "title": "Aliases"
        }, 
        {
            "location": "/user/writing/#tests", 
            "text": "All good projects should have tests. Since your project is good (isn't it?),\nyours has tests too, and you should have a good way to execute those tests from\nyour build system. bfg9000 provides a  set of\nfunctions  for running tests. The most important of\nthese is aptly named test() . Any executable can\nbe passed to this function, and it will be executed as a test; an exit status of\n0 marks success, and non-zero marks failure:  test( executable('test_foo', files=['test_foo.cpp']) )  In addition, you can provide a  test\ndriver  that collects\nall of your tests together and runs them as one.  test_driver()  takes an\nexecutable (a  system_executable  by\ndefault) that runs all the test files. This allows you to aggregate multiple\ntest files into a single run, which is very useful for reporting:  mettle = test_driver('mettle')\ntest( executable('test_foo', files=['test_foo.cpp']), driver=mettle )\ntest( executable('test_bar', files=['test_bar.cpp']), driver=mettle )", 
            "title": "Tests"
        }, 
        {
            "location": "/user/reference/", 
            "text": "Reference\n\n\nBuild steps\n\n\n\n\nNote\n\n\nFor build steps which produce an actual file, the exact name of the output\nfile is determined by the platform you're running on. For instance, when\nbuilding an executable file named \"foo\" on Windows, the resulting file will\nbe \nfoo.exe\n.\n\n\n\n\ncommand(\nname\n, \ncmd\n|\ncmds\n, [\nenvironment\n], [\nextra_deps\n])\n\n\nCreate a build step that runs a list of arbitrary commands, specified in either\n\ncmd\n or \ncmds\n; \ncmd\n takes a single command, whereas \ncmds\n takes a list of\ncommands. Each command may either be a string to be parsed according to shell\nrules or a list of arguments to be passed directly to the process.\n\n\nYou may also pass a dict to \nenvironment\n to set environment variables for the\ncommands. These override any environment variables set on the command line.\n\n\nexecutable(\nname\n, [\nfiles\n, ..., [\nextra_deps\n]])\n\n\nCreate a build step that builds an executable file named \nname\n. \nfiles\n is the\nlist of source (or object) files to link. If an element of \nfiles\n is a source\nfile (or a plain string), this function will implicitly call\n\nobject_file\n on it.\n\n\nThe following arguments may also be specified:\n\n\n\n\ninclude\n: Forwarded on to \nobject_file\n\n\nlibs\n: A list of library files (see \nshared_library\n and \nstatic_library\n)\n\n\npackages\n: A list of external \npackages\n; also forwarded on\n  to \nobject_file\n\n\ncompile_options\n: Forwarded on to\n  \nobject_file\n as \noptions\n\n\nlink_options\n: Command-line options to pass to the linker\n\n\nlang\n: Forwarded on to \nobject_file\n\n\n\n\nIf \nfiles\n isn't specified, this function merely references an \nexisting\n\nexecutable file (a precompiled binary, a shell script, etc) somewhere on the\nfilesystem. In this case, \nname\n is the exact name of the file. This allows\nyou to refer to existing executables for other functions.\n\n\nThis build step recognizes the \ndynamic linking environment\nvariables\n and the \ncompiler environment\nvariable\n (e.g. \nCC\n) for the\nrelevant language.\n\n\nobject_file([\nname\n], [\nfile\n, ..., [\nextra_deps\n]])\n\n\nCreate a build step that compiles a source file named \nfile\n to an object file\nnamed \nname\n; if \nname\n is not specified, it takes the file name in \nfile\n\nwithout the extension.\n\n\nThe following arguments may also be specified:\n\n\n\n\ninclude\n: A list of \ndirectories\n to search for\n  header files\n\n\npackages\n: A list of external \npackages\n\n\noptions\n: Command-line options to pass to the compiler\n\n\nlang\n: The language of the source file; useful if the source file's extension\n  isn't recognized by bfg9000\n\n\n\n\nIf \nfile\n isn't specified, this function merely references an \nexisting\n\nobject file somewhere on the filesystem. In this case, \nname\n must be specified\nand is the exact name of the file.\n\n\nThis build step recognizes the \ncompilation environment\nvariables\n for the relevant language.\n\n\nobject_files(\nfiles\n, ..., [\nextra_deps\n])\n\n\nCreate a compilation build step for each of the files in \nfiles\n; this is\nequivalent to calling \nobject_file\n for each\nelement in \nfiles\n.\n\n\nIn addition, \nobject_files\n returns a special list that allows you to index into\nit using the filename of one of the source files listed in \nfiles\n. This makes\nit easy to extract a single object file to use in other places, e.g. test code.\nFor example:\n\n\nobjs = object_files(['foo.cpp', 'bar.cpp'])\nrelease_exe = executable('release', objs)\n\nfoo_obj = objs['foo.cpp']\ntest_exe = executable('test', ['test.cpp', foo_obj])\n\n\n\n\nshared_library(\nname\n, [\nfiles\n, ..., [\nextra_deps\n]])\n\n\nCreate a build step that builds a shared library named \nname\n. Its arguments are\nthe same as \nexecutable\n, with the following\nadditional options:\n\n\n\n\nversion\n: The version number of the library, e.g. \n1.2.3\n.\n\n\nsoversion\n: The API version of the library (used in its soname), e.g. \n1\n.\n\n\n\n\nThis build step recognizes the \ndynamic linking environment\nvariables\n and the \ncompiler environment\nvariable\n (e.g. \nCC\n) for the\nrelevant language.\n\n\n\n\nNote\n\n\nOn Windows, this produces \ntwo\n files: \nname.dll\n and \nname.lib\n. The latter\nis the \nimport library\n, used when linking to this library. As a result,\n\nmy_lib.all\n returns a list containing two files.\n\n\nAdditionally, this step will add a preprocessor macro on Windows named\n\nLIB\nNAME\n_EXPORTS\n that can be used for declaring public symbols. The\nfollowing snippet shows how you can use this macro (and \nLIB\nNAME\n_STATIC\n)\nto set the appropriate attributes for your public symbols:\n\n\n#if defined(_WIN32) \n !defined(LIBLIBRARY_STATIC)\n#  ifdef LIBLIBRARY_EXPORTS\n#    define LIB_PUBLIC __declspec(dllexport)\n#  else\n#    define LIB_PUBLIC __declspec(dllimport)\n#  endif\n#else\n#  define LIB_PUBLIC\n#endif\n\n\n\n\n\n\nstatic_library(\nname\n, [\nfiles\n, ..., [\nextra_deps\n]])\n\n\nCreate a build step that builds a static library named \nname\n. Its arguments are\nthe same as \nexecutable\n. Link-related\narguments (\nlink_options\n, \nlibs\n, and libraries from \npackages\n) have no direct\neffect on this build step. Instead, they're cached and forwarded on to any\ndynamic linking step that uses this static library.\n\n\nThis build step recognizes the \nstatic linking environment\nvariables\n.\n\n\n\n\nNote\n\n\nOn Windows, this step will add a preprocessor macro on Windows named\n\nLIB\nNAME\n_STATIC\n that can be used for declaring public symbols. See\n\nshared_library\n for more details on\nhow to use this macro.\n\n\n\n\nFile types\n\n\ndirectory(\nname\n)\n\n\nCreate a reference to an existing directory named \nname\n. This allows you to\nrefer to an arbitrary subfolder of your source directory.\n\n\nheader(\nname\n)\n\n\nCreate a reference to an existing header named \nname\n. This is useful if you'd\nlike to \ninstall\n a single header file for your project.\n\n\nheader_directory(\nname\n, [\nsystem\n])\n\n\nCreate a reference to a directory named \nname\n containing header files for the\nproject. This can then be used in the \ninclude\n argument when\n\ncompiling\n a source file. If \nsystem\n is\n\nTrue\n, this directory will be treated as a\n\nsystem directory\n for\ncompilers that support this.\n\n\nsource_file(\nname\n, [\nlang\n])\n\n\nCreate a reference to an existing source file named \nname\n. If \nlang\n is not\nspecified, the language of the file is inferred from its extension. Generally,\nthis function is only necessary when running commands that take a source file\nas an argument, e.g. running a Python script; this allows you to specify that\nthe file is found in the \nsource directory\n. In other cases, a plain string will\nautomatically get converted to a \nsource_file\n.\n\n\nwhole_archive(\nname\n)\n\n\nCreate a \nwhole-archive\n from an existing static\nlibrary named \nname\n. This ensure that \nevery\n object file in the library is\nincluded, rather than just the ones whose symbols are referenced. This is\ntypically used to turn a static library into a shared library.\n\n\n\n\nWarning\n\n\nThe MSVC linker doesn't have a way of expressing this directive, so\n\nwhole_archive\n can't be used with it.\n\n\n\n\nGrouping rules\n\n\nalias(\nname\n, [\ndeps\n])\n\n\nCreate a build step named \nname\n that performs no actions on its own. Instead,\nit just runs its dependencies listed in \ndeps\n as necessary. This build step is\nuseful for grouping common steps together.\n\n\ndefault(\n...\n)\n\n\nSpecify a list of build steps that should be run by default when building. These\nare all accumulated into the \nall\n target. If \ndefault\n is never called, all\nexecutables and libraries \nnot\n passed to\n\ntest\n will be built by default.\n\n\ninstall(\n...\n)\n\n\nSpecify a list of files that need to be installed for the project to work. Each\nwill be installed to the appropriate location based on its type, e.g. header\nfiles will go in \n$PREFIX/include\n by default on POSIX systems. These are all\naccumulated into the \ninstall\n target. If there are any runtime dependencies for\na file (such as shared libraries you just built), they will be installed as\nwell.\n\n\n\n\nNote\n\n\nWhen explicitly listing a target, \nall\n the files for that target will be\ninstalled. For instance, on Windows, this means that passing in a shared\nlibrary will install the DLL \nand\n the import library.\n\n\n\n\nThis rule recognizes the following environment variables:\n\nINSTALL\n,\n\nINSTALL_NAME_TOOL\n,\n\nMKDIR_P\n,\n\nPATCHELF\n.\n\n\nGlobal options\n\n\nglobal_options(\noptions\n, \nlang\n)\n\n\nSpecify some \noptions\n (either as a string or list) to use for all compilation\nsteps for the language \nlang\n.\n\n\nglobal_link_options(\noptions\n)\n\n\nSpecify some \noptions\n (either as a string or list) to use for all link steps\n(i.e. for \nexecutables\n and\n\nshared libraries\n).\n\n\nTest rules\n\n\nThese rules help you define automated tests that can all be run via the \ntest\n\ntarget. For simple cases, you should only need the\n\ntest\n rule, but you can also wrap your\ntests with a separate driver using\n\ntest_driver\n.\n\n\nFor cases where you only want to \nbuild\n the tests, not run them, you can use\nthe \ntests\n target.\n\n\ntest(\ntest\n, [\noptions\n], [\nenvironment\n|\ndriver\n])\n\n\nCreate a test for a single test file named \ntest\n. You may specify additional\ncommand-line arguments to the test in \noptions\n. You can also pass temporary\nenvironment variables as a dict via \nenvironment\n, or specify a test driver to\nadd this test file to via \ndriver\n.\n\n\ntest_driver(\ndriver\n, [\noptions\n], [\nenvironment\n|\nparent\n])\n\n\nCreate a test driver which can run a series of tests, specified as command-line\narguments to the driver. You may specify driver-wide command-line arguments via\n\noptions\n. You can also pass temporary environment variables as a dict with\n\nenvironment\n, or specify a parent test driver to wrap this driver via \ndriver\n.\n\n\ntest_deps(\n...\n)\n\n\nSpecify a list of dependencies which must be satisfied before the tests can be\nrun.\n\n\nPackage resolvers\n\n\nboost_package([\nname\n], [\nversion\n])\n\n\nSearch for a \nBoost\n library. You can specify \nname\n (as\na string or a list) to specify a specific Boost library (or libraries); for\ninstance, \n'program_options'\n. For header-only libraries, you can omit \nname\n.\nIf \nversion\n is specified, it will ensure that the installed version of Boost\nmeets the version requirement; it must be formatted as a Python \nversion\nspecifier\n.\n\n\nThis rule recognizes the \npackaging environment\nvariables\n.\n\n\npkgconfig_package(\nname\n, [\nversion\n], [\nlang\n])\n\n\nSearch for a package named \nname\n via\n\npkg-config\n. If\n\nversion\n is specified, it will ensure that the installed version of the package\nmeets the version requirement; it must be formatted as a Python \nversion\nspecifier\n. \nlang\n\nis the source language of the library (\n'c'\n by default); this is useful if you\nneed to link a static library written in C++ with a program written in C.\n\n\nThis rule recognizes the following environment variable:\n\nPKG_CONFIG\n,\n\n\nsystem_executable(\nname\n)\n\n\nSearch for an executable named \nname\n somewhere in the system's PATH.\n\n\nThis rule recognizes the following environment variables:\n\nPATH\n, \nPATHEXT\n.\n\n\nsystem_package(\nname\n, [\nlang\n], [\nkind\n])\n\n\nSearch for a library named \nname\n somewhere in the system's default library\nlocation. \nlang\n is the source language of the library (\n'c'\n by default); this\nis useful if you need to link a static library written in C++ with a program\nwritten in C.\n\n\nYou can also specify \nkind\n to one of \n'any'\n (the default), \n'shared'\n, or\n\n'static'\n. This allows you to restrict the search to find only static versions\nof a library, for example.\n\n\nThis rule recognizes the following environment variables:\n\nLIB\n,\n\nLIBRARY_PATH\n.\n\n\n\n\nNote\n\n\nThis only finds the library itself, not any required headers. Those are\nassumed to be somewhere where your compiler can find them automatically; if\nnot, you can set \nCPPFLAGS\n to add the\nappropriate header search path.\n\n\n\n\nEnvironment\n\n\nThe \nenvironment\n, \nenv\n, is a special object that encapsulates information\nabout the system outside of bfg9000. It's used internally for nearly all\nplatform-specific code, but it can also help in \nbuild.bfg\n files when you\nencounter some unavoidable issue with multiplatform compatibility.\n\n\n\n\nNote\n\n\nThis listing doesn't cover \nall\n available functions on the environment,\nsince many are only useful to internal code. However, the most relevant ones\nfor \nbuild.bfg\n files are shown below.\n\n\n\n\nenv.compiler(\nlang\n)\n\n\nReturn the compiler used by bfg9000 for a particular language \nlang\n. While\ncompiler objects are primarily suited to bfg's internals, there are still a few\nuseful properties for \nbuild.bfg\n files:\n\n\ncompiler.command\n\n\nThe command to run when invoking this compiler, e.g. \ng++-4.9\n.\n\n\ncompiler.flavor\n\n\nThe \"flavor\" of the compiler, i.e. the kind of command-line interface it has.\nPossible values are \n'cc'\n and \n'msvc'\n.\n\n\nenv.linker(\nlangs\n)\n\n\nReturn the compiler used by bfg9000 for a particular language (or list of\nlanguages) \nlang\n. Its public properties are the same as\n\ncompiler\n above.\n\n\nenv.platform\n\n\nReturn the target platform used for the build (currently the same as the host\nplatform).\n\n\nplatform.flavor\n\n\nThe \"flavor\" of the platform. Either \n'posix'\n or \n'windows'\n.\n\n\nplatform.name\n\n\nThe name of the platform, e.g. \n'linux'\n, \n'darwin'\n (OS X), or \n'windows'\n.\n\n\nMiscellaneous\n\n\nbfg9000_required_version([\nversion\n], [\npython_version\n])\n\n\nSet the required \nversion\n for bfg9000 and/or the required \npython_version\n.\nEach of these is a standard Python \nversion\nspecifier\n.\n\n\nbfg9000_version\n\n\nReturn the current version of bfg9000. This can be useful if you want to\noptionally support a feature only available in certain versions of bfg.\n\n\nfilter_by_platform(\nname\n, \ntype\n)\n\n\nReturn \nTrue\n if \nname\n is a filename that should be included for the target\nplatform, and \nFalse\n otherwise. File (or directory) names like \nPLATFORM\n or\n\nfoo_PLATFORM.cpp\n are excluded if \nPLATFORM\n is a known platform name that\n\ndoesn't\n match the target platform. Known platform names are: \n'posix'\n,\n\n'linux'\n, \n'darwin'\n, \n'cygwin'\n, \n'windows'\n.\n\n\nThis is the default \nfilter\n for\n\nfind_files\n.\n\n\nfind_files([\npath\n], [\nname\n], [\ntype\n], [\nflat\n], [\nfilter\n], [\ncache\n])\n\n\nFind files in \npath\n whose name matches the glob \nname\n. If \npath\n is omitted,\nsearch in the root of the source directory; if \nname\n is omitted, all files will\nmatch. \ntype\n may be either \n'f'\n to find only files or \n'd'\n to find only\ndirectories. If \nflat\n is true, \nfind_files\n will not recurse into\nsubdirectories. You can also specify a custom \nfilter\n function to filter the\nlist of files; this function takes two arguments: the file's name and its type.\n\n\nFinally, if \ncache\n is \nTrue\n (the default), this lookup will be cached so that\nany changes to the result of this function will regenerate the build scripts\nfor the project. This allows you do add or remove source files and not have to\nworry about manually rerunning bfg9000.", 
            "title": "Reference"
        }, 
        {
            "location": "/user/reference/#reference", 
            "text": "", 
            "title": "Reference"
        }, 
        {
            "location": "/user/reference/#build-steps", 
            "text": "Note  For build steps which produce an actual file, the exact name of the output\nfile is determined by the platform you're running on. For instance, when\nbuilding an executable file named \"foo\" on Windows, the resulting file will\nbe  foo.exe .", 
            "title": "Build steps"
        }, 
        {
            "location": "/user/reference/#commandname-cmdcmds-environment-extra_deps", 
            "text": "Create a build step that runs a list of arbitrary commands, specified in either cmd  or  cmds ;  cmd  takes a single command, whereas  cmds  takes a list of\ncommands. Each command may either be a string to be parsed according to shell\nrules or a list of arguments to be passed directly to the process.  You may also pass a dict to  environment  to set environment variables for the\ncommands. These override any environment variables set on the command line.", 
            "title": "command(name, cmd|cmds, [environment], [extra_deps])"
        }, 
        {
            "location": "/user/reference/#executablename-files-extra_deps", 
            "text": "Create a build step that builds an executable file named  name .  files  is the\nlist of source (or object) files to link. If an element of  files  is a source\nfile (or a plain string), this function will implicitly call object_file  on it.  The following arguments may also be specified:   include : Forwarded on to  object_file  libs : A list of library files (see  shared_library  and  static_library )  packages : A list of external  packages ; also forwarded on\n  to  object_file  compile_options : Forwarded on to\n   object_file  as  options  link_options : Command-line options to pass to the linker  lang : Forwarded on to  object_file   If  files  isn't specified, this function merely references an  existing \nexecutable file (a precompiled binary, a shell script, etc) somewhere on the\nfilesystem. In this case,  name  is the exact name of the file. This allows\nyou to refer to existing executables for other functions.  This build step recognizes the  dynamic linking environment\nvariables  and the  compiler environment\nvariable  (e.g.  CC ) for the\nrelevant language.", 
            "title": "executable(name, [files, ..., [extra_deps]])"
        }, 
        {
            "location": "/user/reference/#object_filename-file-extra_deps", 
            "text": "Create a build step that compiles a source file named  file  to an object file\nnamed  name ; if  name  is not specified, it takes the file name in  file \nwithout the extension.  The following arguments may also be specified:   include : A list of  directories  to search for\n  header files  packages : A list of external  packages  options : Command-line options to pass to the compiler  lang : The language of the source file; useful if the source file's extension\n  isn't recognized by bfg9000   If  file  isn't specified, this function merely references an  existing \nobject file somewhere on the filesystem. In this case,  name  must be specified\nand is the exact name of the file.  This build step recognizes the  compilation environment\nvariables  for the relevant language.", 
            "title": "object_file([name], [file, ..., [extra_deps]])"
        }, 
        {
            "location": "/user/reference/#object_filesfiles-extra_deps", 
            "text": "Create a compilation build step for each of the files in  files ; this is\nequivalent to calling  object_file  for each\nelement in  files .  In addition,  object_files  returns a special list that allows you to index into\nit using the filename of one of the source files listed in  files . This makes\nit easy to extract a single object file to use in other places, e.g. test code.\nFor example:  objs = object_files(['foo.cpp', 'bar.cpp'])\nrelease_exe = executable('release', objs)\n\nfoo_obj = objs['foo.cpp']\ntest_exe = executable('test', ['test.cpp', foo_obj])", 
            "title": "object_files(files, ..., [extra_deps])"
        }, 
        {
            "location": "/user/reference/#shared_libraryname-files-extra_deps", 
            "text": "Create a build step that builds a shared library named  name . Its arguments are\nthe same as  executable , with the following\nadditional options:   version : The version number of the library, e.g.  1.2.3 .  soversion : The API version of the library (used in its soname), e.g.  1 .   This build step recognizes the  dynamic linking environment\nvariables  and the  compiler environment\nvariable  (e.g.  CC ) for the\nrelevant language.   Note  On Windows, this produces  two  files:  name.dll  and  name.lib . The latter\nis the  import library , used when linking to this library. As a result, my_lib.all  returns a list containing two files.  Additionally, this step will add a preprocessor macro on Windows named LIB NAME _EXPORTS  that can be used for declaring public symbols. The\nfollowing snippet shows how you can use this macro (and  LIB NAME _STATIC )\nto set the appropriate attributes for your public symbols:  #if defined(_WIN32)   !defined(LIBLIBRARY_STATIC)\n#  ifdef LIBLIBRARY_EXPORTS\n#    define LIB_PUBLIC __declspec(dllexport)\n#  else\n#    define LIB_PUBLIC __declspec(dllimport)\n#  endif\n#else\n#  define LIB_PUBLIC\n#endif", 
            "title": "shared_library(name, [files, ..., [extra_deps]])"
        }, 
        {
            "location": "/user/reference/#static_libraryname-files-extra_deps", 
            "text": "Create a build step that builds a static library named  name . Its arguments are\nthe same as  executable . Link-related\narguments ( link_options ,  libs , and libraries from  packages ) have no direct\neffect on this build step. Instead, they're cached and forwarded on to any\ndynamic linking step that uses this static library.  This build step recognizes the  static linking environment\nvariables .   Note  On Windows, this step will add a preprocessor macro on Windows named LIB NAME _STATIC  that can be used for declaring public symbols. See shared_library  for more details on\nhow to use this macro.", 
            "title": "static_library(name, [files, ..., [extra_deps]])"
        }, 
        {
            "location": "/user/reference/#file-types", 
            "text": "", 
            "title": "File types"
        }, 
        {
            "location": "/user/reference/#directoryname", 
            "text": "Create a reference to an existing directory named  name . This allows you to\nrefer to an arbitrary subfolder of your source directory.", 
            "title": "directory(name)"
        }, 
        {
            "location": "/user/reference/#headername", 
            "text": "Create a reference to an existing header named  name . This is useful if you'd\nlike to  install  a single header file for your project.", 
            "title": "header(name)"
        }, 
        {
            "location": "/user/reference/#header_directoryname-system", 
            "text": "Create a reference to a directory named  name  containing header files for the\nproject. This can then be used in the  include  argument when compiling  a source file. If  system  is True , this directory will be treated as a system directory  for\ncompilers that support this.", 
            "title": "header_directory(name, [system])"
        }, 
        {
            "location": "/user/reference/#source_filename-lang", 
            "text": "Create a reference to an existing source file named  name . If  lang  is not\nspecified, the language of the file is inferred from its extension. Generally,\nthis function is only necessary when running commands that take a source file\nas an argument, e.g. running a Python script; this allows you to specify that\nthe file is found in the  source directory . In other cases, a plain string will\nautomatically get converted to a  source_file .", 
            "title": "source_file(name, [lang])"
        }, 
        {
            "location": "/user/reference/#whole_archivename", 
            "text": "Create a  whole-archive  from an existing static\nlibrary named  name . This ensure that  every  object file in the library is\nincluded, rather than just the ones whose symbols are referenced. This is\ntypically used to turn a static library into a shared library.   Warning  The MSVC linker doesn't have a way of expressing this directive, so whole_archive  can't be used with it.", 
            "title": "whole_archive(name)"
        }, 
        {
            "location": "/user/reference/#grouping-rules", 
            "text": "", 
            "title": "Grouping rules"
        }, 
        {
            "location": "/user/reference/#aliasname-deps", 
            "text": "Create a build step named  name  that performs no actions on its own. Instead,\nit just runs its dependencies listed in  deps  as necessary. This build step is\nuseful for grouping common steps together.", 
            "title": "alias(name, [deps])"
        }, 
        {
            "location": "/user/reference/#default", 
            "text": "Specify a list of build steps that should be run by default when building. These\nare all accumulated into the  all  target. If  default  is never called, all\nexecutables and libraries  not  passed to test  will be built by default.", 
            "title": "default(...)"
        }, 
        {
            "location": "/user/reference/#install", 
            "text": "Specify a list of files that need to be installed for the project to work. Each\nwill be installed to the appropriate location based on its type, e.g. header\nfiles will go in  $PREFIX/include  by default on POSIX systems. These are all\naccumulated into the  install  target. If there are any runtime dependencies for\na file (such as shared libraries you just built), they will be installed as\nwell.   Note  When explicitly listing a target,  all  the files for that target will be\ninstalled. For instance, on Windows, this means that passing in a shared\nlibrary will install the DLL  and  the import library.   This rule recognizes the following environment variables: INSTALL , INSTALL_NAME_TOOL , MKDIR_P , PATCHELF .", 
            "title": "install(...)"
        }, 
        {
            "location": "/user/reference/#global-options", 
            "text": "", 
            "title": "Global options"
        }, 
        {
            "location": "/user/reference/#global_optionsoptions-lang", 
            "text": "Specify some  options  (either as a string or list) to use for all compilation\nsteps for the language  lang .", 
            "title": "global_options(options, lang)"
        }, 
        {
            "location": "/user/reference/#global_link_optionsoptions", 
            "text": "Specify some  options  (either as a string or list) to use for all link steps\n(i.e. for  executables  and shared libraries ).", 
            "title": "global_link_options(options)"
        }, 
        {
            "location": "/user/reference/#test-rules", 
            "text": "These rules help you define automated tests that can all be run via the  test \ntarget. For simple cases, you should only need the test  rule, but you can also wrap your\ntests with a separate driver using test_driver .  For cases where you only want to  build  the tests, not run them, you can use\nthe  tests  target.", 
            "title": "Test rules"
        }, 
        {
            "location": "/user/reference/#testtest-options-environmentdriver", 
            "text": "Create a test for a single test file named  test . You may specify additional\ncommand-line arguments to the test in  options . You can also pass temporary\nenvironment variables as a dict via  environment , or specify a test driver to\nadd this test file to via  driver .", 
            "title": "test(test, [options], [environment|driver])"
        }, 
        {
            "location": "/user/reference/#test_driverdriver-options-environmentparent", 
            "text": "Create a test driver which can run a series of tests, specified as command-line\narguments to the driver. You may specify driver-wide command-line arguments via options . You can also pass temporary environment variables as a dict with environment , or specify a parent test driver to wrap this driver via  driver .", 
            "title": "test_driver(driver, [options], [environment|parent])"
        }, 
        {
            "location": "/user/reference/#test_deps", 
            "text": "Specify a list of dependencies which must be satisfied before the tests can be\nrun.", 
            "title": "test_deps(...)"
        }, 
        {
            "location": "/user/reference/#package-resolvers", 
            "text": "", 
            "title": "Package resolvers"
        }, 
        {
            "location": "/user/reference/#boost_packagename-version", 
            "text": "Search for a  Boost  library. You can specify  name  (as\na string or a list) to specify a specific Boost library (or libraries); for\ninstance,  'program_options' . For header-only libraries, you can omit  name .\nIf  version  is specified, it will ensure that the installed version of Boost\nmeets the version requirement; it must be formatted as a Python  version\nspecifier .  This rule recognizes the  packaging environment\nvariables .", 
            "title": "boost_package([name], [version])"
        }, 
        {
            "location": "/user/reference/#pkgconfig_packagename-version-lang", 
            "text": "Search for a package named  name  via pkg-config . If version  is specified, it will ensure that the installed version of the package\nmeets the version requirement; it must be formatted as a Python  version\nspecifier .  lang \nis the source language of the library ( 'c'  by default); this is useful if you\nneed to link a static library written in C++ with a program written in C.  This rule recognizes the following environment variable: PKG_CONFIG ,", 
            "title": "pkgconfig_package(name, [version], [lang])"
        }, 
        {
            "location": "/user/reference/#system_executablename", 
            "text": "Search for an executable named  name  somewhere in the system's PATH.  This rule recognizes the following environment variables: PATH ,  PATHEXT .", 
            "title": "system_executable(name)"
        }, 
        {
            "location": "/user/reference/#system_packagename-lang-kind", 
            "text": "Search for a library named  name  somewhere in the system's default library\nlocation.  lang  is the source language of the library ( 'c'  by default); this\nis useful if you need to link a static library written in C++ with a program\nwritten in C.  You can also specify  kind  to one of  'any'  (the default),  'shared' , or 'static' . This allows you to restrict the search to find only static versions\nof a library, for example.  This rule recognizes the following environment variables: LIB , LIBRARY_PATH .   Note  This only finds the library itself, not any required headers. Those are\nassumed to be somewhere where your compiler can find them automatically; if\nnot, you can set  CPPFLAGS  to add the\nappropriate header search path.", 
            "title": "system_package(name, [lang], [kind])"
        }, 
        {
            "location": "/user/reference/#environment", 
            "text": "The  environment ,  env , is a special object that encapsulates information\nabout the system outside of bfg9000. It's used internally for nearly all\nplatform-specific code, but it can also help in  build.bfg  files when you\nencounter some unavoidable issue with multiplatform compatibility.   Note  This listing doesn't cover  all  available functions on the environment,\nsince many are only useful to internal code. However, the most relevant ones\nfor  build.bfg  files are shown below.", 
            "title": "Environment"
        }, 
        {
            "location": "/user/reference/#envcompilerlang", 
            "text": "Return the compiler used by bfg9000 for a particular language  lang . While\ncompiler objects are primarily suited to bfg's internals, there are still a few\nuseful properties for  build.bfg  files:", 
            "title": "env.compiler(lang)"
        }, 
        {
            "location": "/user/reference/#compilercommand", 
            "text": "The command to run when invoking this compiler, e.g.  g++-4.9 .", 
            "title": "compiler.command"
        }, 
        {
            "location": "/user/reference/#compilerflavor", 
            "text": "The \"flavor\" of the compiler, i.e. the kind of command-line interface it has.\nPossible values are  'cc'  and  'msvc' .", 
            "title": "compiler.flavor"
        }, 
        {
            "location": "/user/reference/#envlinkerlangs", 
            "text": "Return the compiler used by bfg9000 for a particular language (or list of\nlanguages)  lang . Its public properties are the same as compiler  above.", 
            "title": "env.linker(langs)"
        }, 
        {
            "location": "/user/reference/#envplatform", 
            "text": "Return the target platform used for the build (currently the same as the host\nplatform).", 
            "title": "env.platform"
        }, 
        {
            "location": "/user/reference/#platformflavor", 
            "text": "The \"flavor\" of the platform. Either  'posix'  or  'windows' .", 
            "title": "platform.flavor"
        }, 
        {
            "location": "/user/reference/#platformname", 
            "text": "The name of the platform, e.g.  'linux' ,  'darwin'  (OS X), or  'windows' .", 
            "title": "platform.name"
        }, 
        {
            "location": "/user/reference/#miscellaneous", 
            "text": "", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/user/reference/#bfg9000_required_versionversion-python_version", 
            "text": "Set the required  version  for bfg9000 and/or the required  python_version .\nEach of these is a standard Python  version\nspecifier .", 
            "title": "bfg9000_required_version([version], [python_version])"
        }, 
        {
            "location": "/user/reference/#bfg9000_version", 
            "text": "Return the current version of bfg9000. This can be useful if you want to\noptionally support a feature only available in certain versions of bfg.", 
            "title": "bfg9000_version"
        }, 
        {
            "location": "/user/reference/#filter_by_platformname-type", 
            "text": "Return  True  if  name  is a filename that should be included for the target\nplatform, and  False  otherwise. File (or directory) names like  PLATFORM  or foo_PLATFORM.cpp  are excluded if  PLATFORM  is a known platform name that doesn't  match the target platform. Known platform names are:  'posix' , 'linux' ,  'darwin' ,  'cygwin' ,  'windows' .  This is the default  filter  for find_files .", 
            "title": "filter_by_platform(name, type)"
        }, 
        {
            "location": "/user/reference/#find_filespath-name-type-flat-filter-cache", 
            "text": "Find files in  path  whose name matches the glob  name . If  path  is omitted,\nsearch in the root of the source directory; if  name  is omitted, all files will\nmatch.  type  may be either  'f'  to find only files or  'd'  to find only\ndirectories. If  flat  is true,  find_files  will not recurse into\nsubdirectories. You can also specify a custom  filter  function to filter the\nlist of files; this function takes two arguments: the file's name and its type.  Finally, if  cache  is  True  (the default), this lookup will be cached so that\nany changes to the result of this function will regenerate the build scripts\nfor the project. This allows you do add or remove source files and not have to\nworry about manually rerunning bfg9000.", 
            "title": "find_files([path], [name], [type], [flat], [filter], [cache])"
        }, 
        {
            "location": "/user/environment-vars/", 
            "text": "Environment Variables\n\n\nbfg9000 reads from a number of environment variables. These are the primary way\nin which users can customize parts of a specific build, e.g. by changing the\ntools to use or adding compiler flags. Below is a full list of all the\nenvironment variables bfg9000 recognizes.\n\n\nCompilation variables\n\n\nGeneric\n\n\n\n\nCPPFLAGS\n\n\nDefault: \nnone\n\n\n\"C preprocessor flags\"; command line arguments to pass to the compiler when\ncompiling any C-family source file (C, C++, Objective C/C++).\n\n\nC\n\n\n\n\nCC\n\n\nDefault: \ncc\n (POSIX), \ncl\n (Windows)\n\n\nThe command to use when compiling C source files. Also the command to use with\ncc-style toolchains when linking object files whose source is in C.\n\n\nCFLAGS\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the compiler when compiling any C source file.\n\n\nC++\n\n\n\n\nCXX\n\n\nDefault: \nc++\n (POSIX), \ncl\n (Windows)\n\n\nThe command to use when compiling C++ source files. Also the command to use with\ncc-style toolchains when linking object files whose source is in C++.\n\n\nCXXFLAGS\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the compiler when compiling any C++ source\nfile.\n\n\nObjective C\n\n\n\n\nOBJC\n\n\nDefault: \ncc\n\n\nThe command to use when compiling Objective C source files. Also the command to\nuse with cc-style toolchains when linking object files whose source is in\nObjective C.\n\n\nOBJCFLAGS\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the compiler when compiling any Objective C\nsource file.\n\n\nObjective C++\n\n\n\n\nOBJCXX\n\n\nDefault: \nc++\n\n\nThe command to use when compiling Objective C++ source files. Also the command\nto use with cc-style toolchains when linking object files whose source is in\nObjective C++.\n\n\nOBJCXXFLAGS\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the compiler when compiling any Objective C++\nsource file.\n\n\nLinking variables\n\n\nStatic linking\n\n\n\n\nAR\n\n\nDefault: \nar\n\n\nPOSIX-only\n. The command to use when creating static libraries from object\nfiles.\n\n\nARFLAGS\n\n\nDefault: \ncru\n\n\nPOSIX-only\n. The arguments to pass to the static library builder (typically\n\nar\n).\n\n\nCC_LIB\n\n\nDefault: \nlib\n\n\nMSVC-only\n. The command to use when creating static libraries whose source\nis in C.\n\n\nCXX_LIB\n\n\nDefault: \nlib\n\n\nMSVC-only\n. The command to use when creating static libraries whose source\nis in C++.\n\n\nLIBFLAGS\n\n\nDefault: \nnone\n\n\nWindows-only\n. Command line arguments to pass to the static library builder\n(typically \nlib\n).\n\n\nDynamic linking\n\n\n\n\nCC_LINK\n\n\nDefault: \nlink\n\n\nMSVC-only\n. The command to use when linking shared libraries whose source\nis in C.\n\n\nCXX_LINK\n\n\nDefault: \nlink\n\n\nMSVC-only\n. The command to use when linking shared libraries whose source\nis in C++.\n\n\nLDFLAGS\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the linker when linking an executable or\nshared library.\n\n\nLDLIBS\n\n\nDefault: \nnone\n\n\nAdditional libraries to link into an executable or shared library. This is\nmainly useful for cases where a system library (e.g. the C++ Standard Library\nimplementation) requires another library to be explicitly linked with it.\n\n\nPackaging variables\n\n\n\n\nBOOST_ROOT\n\n\nDefault: \nnone\n\n\nThe root directory where Boost headers and libraries are stored (as\n\n$BOOST_ROOT/include\n and \n$BOOST_ROOT/lib\n, respectively).\n\n\nBOOST_INCLUDEDIR\n\n\nDefault: \nnone\n\n\nThe root directory where Boost headers are stored. This takes precedence over\n\nBOOST_ROOT\n.\n\n\nBOOST_LIBRARYDIR\n\n\nDefault: \nnone\n\n\nThe root directory where Boost libraries are stored. This takes precedence over\n\nBOOST_ROOT\n.\n\n\nCPATH\n\n\nDefault: \nnone\n\n\nA list of additional directories to search for headers. On POSIX systems, this\nis delimited by \n:\n; on Windows, by \n;\n.\n\n\nINCLUDE\n\n\nDefault: \nnone\n\n\nMSVC-only\n A list of directories to search for headers, delimited by  \n;\n.\n\n\nLIB\n\n\nDefault: \nnone\n\n\nMSVC-only\n A list of directories to search for \nsystem\nlibraries\n, delimited by  \n;\n.\n\n\nLIBRARY_PATH\n\n\nDefault: \nnone\n\n\nA list of additional directories to search for \nsystem\nlibraries\n. On POSIX systems, this is delimited\nby \n:\n; on Windows, by \n;\n.\n\n\nPATH\n\n\nDefault: \nnone\n\n\nA list of directories to search for \nsystem\nexecutables\n. On POSIX systems, this is\ndelimited by \n:\n; on Windows, by \n;\n.\n\n\nPATHEXT\n\n\nDefault: \nnone\n\n\nWindows-only\n. A list of valid extensions for executable files under Windows,\nseparated by \n;\n.\n\n\nPKG_CONFIG\n\n\nDefault: \npkg_config\n\n\nThe command to use when fetching pkg-config package information.\n\n\nCommand variables\n\n\n\n\nBFG9000\n\n\nDefault: \n/path/to/bfg9000\n\n\nThe command to use when executing bfg9000 (e.g. when regenerating the build\nscripts because the list of source files has changed). This should only be\nnecessary if you run bfg9000 from a wrapper script.\n\n\nDEPFIXER\n\n\nDefault: \n/path/to/bfg9000-depfixer\n\n\nThe command to use when fixing up depfiles generated by your compiler for the\nMake backend. In general, you shouldn't need to touch this.\n\n\nINSTALL\n\n\nDefault: \ninstall\n (Linux, Windows), \nginstall\n (Darwin)\n\n\nThe command to use when installing files.\n\n\nINSTALL_NAME_TOOL\n\n\nDefault: \ninstall_name_tool\n\n\nDarwin-only\n The command to use when modifying the paths of the shared\nlibraries linked to during installation.\n\n\nMKDIR_P\n\n\nDefault: \nmkdir -p\n\n\nThe command to use when making a directory tree. This is used both for\ninstalling whole directories of files and for creating build directories under\nthe Make backend.\n\n\nPATCHELF\n\n\nDefault: \npatchelf\n\n\nLinux-only\n. The command to use when patching an ELF file's rpath for\ninstallation.\n\n\nSETENV\n\n\nDefault: \n/path/to/bfg9000-setenv\n\n\nWindows-only\n. The command to use when setting temporary environment variables,\nsimilar to the POSIX \nenv\n command. This is used when setting environment\nvariables for tests.\n\n\nSystem variables\n\n\n\n\nPLATFORM\n\n\nDefault: \nWin32\n\n\nWindows-only\n. The platform type to use when generating MSBuild files.\n\n\nVISUALSTUDIOVERSION\n\n\nDefault: \n14.0\n\n\nWindows-only\n. The version of Visual Studio to target when generating MSBuild\nfiles.", 
            "title": "Environment Variables"
        }, 
        {
            "location": "/user/environment-vars/#environment-variables", 
            "text": "bfg9000 reads from a number of environment variables. These are the primary way\nin which users can customize parts of a specific build, e.g. by changing the\ntools to use or adding compiler flags. Below is a full list of all the\nenvironment variables bfg9000 recognizes.", 
            "title": "Environment Variables"
        }, 
        {
            "location": "/user/environment-vars/#compilation-variables", 
            "text": "", 
            "title": "Compilation variables"
        }, 
        {
            "location": "/user/environment-vars/#generic", 
            "text": "", 
            "title": "Generic"
        }, 
        {
            "location": "/user/environment-vars/#cppflags", 
            "text": "Default:  none  \"C preprocessor flags\"; command line arguments to pass to the compiler when\ncompiling any C-family source file (C, C++, Objective C/C++).", 
            "title": "CPPFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#c", 
            "text": "", 
            "title": "C"
        }, 
        {
            "location": "/user/environment-vars/#cc", 
            "text": "Default:  cc  (POSIX),  cl  (Windows)  The command to use when compiling C source files. Also the command to use with\ncc-style toolchains when linking object files whose source is in C.", 
            "title": "CC"
        }, 
        {
            "location": "/user/environment-vars/#cflags", 
            "text": "Default:  none  Command line arguments to pass to the compiler when compiling any C source file.", 
            "title": "CFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#c_1", 
            "text": "", 
            "title": "C++"
        }, 
        {
            "location": "/user/environment-vars/#cxx", 
            "text": "Default:  c++  (POSIX),  cl  (Windows)  The command to use when compiling C++ source files. Also the command to use with\ncc-style toolchains when linking object files whose source is in C++.", 
            "title": "CXX"
        }, 
        {
            "location": "/user/environment-vars/#cxxflags", 
            "text": "Default:  none  Command line arguments to pass to the compiler when compiling any C++ source\nfile.", 
            "title": "CXXFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#objective-c", 
            "text": "", 
            "title": "Objective C"
        }, 
        {
            "location": "/user/environment-vars/#objc", 
            "text": "Default:  cc  The command to use when compiling Objective C source files. Also the command to\nuse with cc-style toolchains when linking object files whose source is in\nObjective C.", 
            "title": "OBJC"
        }, 
        {
            "location": "/user/environment-vars/#objcflags", 
            "text": "Default:  none  Command line arguments to pass to the compiler when compiling any Objective C\nsource file.", 
            "title": "OBJCFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#objective-c_1", 
            "text": "", 
            "title": "Objective C++"
        }, 
        {
            "location": "/user/environment-vars/#objcxx", 
            "text": "Default:  c++  The command to use when compiling Objective C++ source files. Also the command\nto use with cc-style toolchains when linking object files whose source is in\nObjective C++.", 
            "title": "OBJCXX"
        }, 
        {
            "location": "/user/environment-vars/#objcxxflags", 
            "text": "Default:  none  Command line arguments to pass to the compiler when compiling any Objective C++\nsource file.", 
            "title": "OBJCXXFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#linking-variables", 
            "text": "", 
            "title": "Linking variables"
        }, 
        {
            "location": "/user/environment-vars/#static-linking", 
            "text": "", 
            "title": "Static linking"
        }, 
        {
            "location": "/user/environment-vars/#ar", 
            "text": "Default:  ar  POSIX-only . The command to use when creating static libraries from object\nfiles.", 
            "title": "AR"
        }, 
        {
            "location": "/user/environment-vars/#arflags", 
            "text": "Default:  cru  POSIX-only . The arguments to pass to the static library builder (typically ar ).", 
            "title": "ARFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#cc_lib", 
            "text": "Default:  lib  MSVC-only . The command to use when creating static libraries whose source\nis in C.", 
            "title": "CC_LIB"
        }, 
        {
            "location": "/user/environment-vars/#cxx_lib", 
            "text": "Default:  lib  MSVC-only . The command to use when creating static libraries whose source\nis in C++.", 
            "title": "CXX_LIB"
        }, 
        {
            "location": "/user/environment-vars/#libflags", 
            "text": "Default:  none  Windows-only . Command line arguments to pass to the static library builder\n(typically  lib ).", 
            "title": "LIBFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#dynamic-linking", 
            "text": "", 
            "title": "Dynamic linking"
        }, 
        {
            "location": "/user/environment-vars/#cc_link", 
            "text": "Default:  link  MSVC-only . The command to use when linking shared libraries whose source\nis in C.", 
            "title": "CC_LINK"
        }, 
        {
            "location": "/user/environment-vars/#cxx_link", 
            "text": "Default:  link  MSVC-only . The command to use when linking shared libraries whose source\nis in C++.", 
            "title": "CXX_LINK"
        }, 
        {
            "location": "/user/environment-vars/#ldflags", 
            "text": "Default:  none  Command line arguments to pass to the linker when linking an executable or\nshared library.", 
            "title": "LDFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#ldlibs", 
            "text": "Default:  none  Additional libraries to link into an executable or shared library. This is\nmainly useful for cases where a system library (e.g. the C++ Standard Library\nimplementation) requires another library to be explicitly linked with it.", 
            "title": "LDLIBS"
        }, 
        {
            "location": "/user/environment-vars/#packaging-variables", 
            "text": "", 
            "title": "Packaging variables"
        }, 
        {
            "location": "/user/environment-vars/#boost_root", 
            "text": "Default:  none  The root directory where Boost headers and libraries are stored (as $BOOST_ROOT/include  and  $BOOST_ROOT/lib , respectively).", 
            "title": "BOOST_ROOT"
        }, 
        {
            "location": "/user/environment-vars/#boost_includedir", 
            "text": "Default:  none  The root directory where Boost headers are stored. This takes precedence over BOOST_ROOT .", 
            "title": "BOOST_INCLUDEDIR"
        }, 
        {
            "location": "/user/environment-vars/#boost_librarydir", 
            "text": "Default:  none  The root directory where Boost libraries are stored. This takes precedence over BOOST_ROOT .", 
            "title": "BOOST_LIBRARYDIR"
        }, 
        {
            "location": "/user/environment-vars/#cpath", 
            "text": "Default:  none  A list of additional directories to search for headers. On POSIX systems, this\nis delimited by  : ; on Windows, by  ; .", 
            "title": "CPATH"
        }, 
        {
            "location": "/user/environment-vars/#include", 
            "text": "Default:  none  MSVC-only  A list of directories to search for headers, delimited by   ; .", 
            "title": "INCLUDE"
        }, 
        {
            "location": "/user/environment-vars/#lib", 
            "text": "Default:  none  MSVC-only  A list of directories to search for  system\nlibraries , delimited by   ; .", 
            "title": "LIB"
        }, 
        {
            "location": "/user/environment-vars/#library_path", 
            "text": "Default:  none  A list of additional directories to search for  system\nlibraries . On POSIX systems, this is delimited\nby  : ; on Windows, by  ; .", 
            "title": "LIBRARY_PATH"
        }, 
        {
            "location": "/user/environment-vars/#path", 
            "text": "Default:  none  A list of directories to search for  system\nexecutables . On POSIX systems, this is\ndelimited by  : ; on Windows, by  ; .", 
            "title": "PATH"
        }, 
        {
            "location": "/user/environment-vars/#pathext", 
            "text": "Default:  none  Windows-only . A list of valid extensions for executable files under Windows,\nseparated by  ; .", 
            "title": "PATHEXT"
        }, 
        {
            "location": "/user/environment-vars/#pkg_config", 
            "text": "Default:  pkg_config  The command to use when fetching pkg-config package information.", 
            "title": "PKG_CONFIG"
        }, 
        {
            "location": "/user/environment-vars/#command-variables", 
            "text": "", 
            "title": "Command variables"
        }, 
        {
            "location": "/user/environment-vars/#bfg9000", 
            "text": "Default:  /path/to/bfg9000  The command to use when executing bfg9000 (e.g. when regenerating the build\nscripts because the list of source files has changed). This should only be\nnecessary if you run bfg9000 from a wrapper script.", 
            "title": "BFG9000"
        }, 
        {
            "location": "/user/environment-vars/#depfixer", 
            "text": "Default:  /path/to/bfg9000-depfixer  The command to use when fixing up depfiles generated by your compiler for the\nMake backend. In general, you shouldn't need to touch this.", 
            "title": "DEPFIXER"
        }, 
        {
            "location": "/user/environment-vars/#install", 
            "text": "Default:  install  (Linux, Windows),  ginstall  (Darwin)  The command to use when installing files.", 
            "title": "INSTALL"
        }, 
        {
            "location": "/user/environment-vars/#install_name_tool", 
            "text": "Default:  install_name_tool  Darwin-only  The command to use when modifying the paths of the shared\nlibraries linked to during installation.", 
            "title": "INSTALL_NAME_TOOL"
        }, 
        {
            "location": "/user/environment-vars/#mkdir_p", 
            "text": "Default:  mkdir -p  The command to use when making a directory tree. This is used both for\ninstalling whole directories of files and for creating build directories under\nthe Make backend.", 
            "title": "MKDIR_P"
        }, 
        {
            "location": "/user/environment-vars/#patchelf", 
            "text": "Default:  patchelf  Linux-only . The command to use when patching an ELF file's rpath for\ninstallation.", 
            "title": "PATCHELF"
        }, 
        {
            "location": "/user/environment-vars/#setenv", 
            "text": "Default:  /path/to/bfg9000-setenv  Windows-only . The command to use when setting temporary environment variables,\nsimilar to the POSIX  env  command. This is used when setting environment\nvariables for tests.", 
            "title": "SETENV"
        }, 
        {
            "location": "/user/environment-vars/#system-variables", 
            "text": "", 
            "title": "System variables"
        }, 
        {
            "location": "/user/environment-vars/#platform", 
            "text": "Default:  Win32  Windows-only . The platform type to use when generating MSBuild files.", 
            "title": "PLATFORM"
        }, 
        {
            "location": "/user/environment-vars/#visualstudioversion", 
            "text": "Default:  14.0  Windows-only . The version of Visual Studio to target when generating MSBuild\nfiles.", 
            "title": "VISUALSTUDIOVERSION"
        }, 
        {
            "location": "/developer/internals/", 
            "text": "Developer Documentation\n\n\nAt its core, a build file is just a DAG (directed acyclic graph) that gets\nwalked through by the build system, where the nodes are files and the edges are\nbuild steps. A bfg9000 build file is no different.\n\n\nHow a build.bfg file is compiled\n\n\nSnapshot the environment\n\n\nWhen bfg9000 is invoked, it first takes a snapshot of the current environment\n(the operating system, environment variables, compiler to use, etc). This is\nimportant to provide a stable state for regeneration of the build file if\nnecessary (e.g. if build.bfg is changed).\n\n\nBuild an internal dependency graph\n\n\nNext, it executes the build.bfg file. Most bfg9000 functions represent build\nsteps or other related parts of the dependency graph. When called, these build\nup an internal DAG structure with all the backend-agnostic data filled in (e.g.\nvirtual filenames are resolved to real ones, such as \"foo\" to \"libfoo.so\").\n\n\nEmit the final build file\n\n\nOnce this is complete, the DAG is passed to the appropriate backend, which\niterates over all the known edges (build steps) and emits the backend-specific\ncode for them. Since all the backends handle walking the DAG on their own,\nbfg9000 can safely avoid worrying about trying to do this efficiently in Python.", 
            "title": "Internals"
        }, 
        {
            "location": "/developer/internals/#developer-documentation", 
            "text": "At its core, a build file is just a DAG (directed acyclic graph) that gets\nwalked through by the build system, where the nodes are files and the edges are\nbuild steps. A bfg9000 build file is no different.", 
            "title": "Developer Documentation"
        }, 
        {
            "location": "/developer/internals/#how-a-buildbfg-file-is-compiled", 
            "text": "", 
            "title": "How a build.bfg file is compiled"
        }, 
        {
            "location": "/developer/internals/#snapshot-the-environment", 
            "text": "When bfg9000 is invoked, it first takes a snapshot of the current environment\n(the operating system, environment variables, compiler to use, etc). This is\nimportant to provide a stable state for regeneration of the build file if\nnecessary (e.g. if build.bfg is changed).", 
            "title": "Snapshot the environment"
        }, 
        {
            "location": "/developer/internals/#build-an-internal-dependency-graph", 
            "text": "Next, it executes the build.bfg file. Most bfg9000 functions represent build\nsteps or other related parts of the dependency graph. When called, these build\nup an internal DAG structure with all the backend-agnostic data filled in (e.g.\nvirtual filenames are resolved to real ones, such as \"foo\" to \"libfoo.so\").", 
            "title": "Build an internal dependency graph"
        }, 
        {
            "location": "/developer/internals/#emit-the-final-build-file", 
            "text": "Once this is complete, the DAG is passed to the appropriate backend, which\niterates over all the known edges (build steps) and emits the backend-specific\ncode for them. Since all the backends handle walking the DAG on their own,\nbfg9000 can safely avoid worrying about trying to do this efficiently in Python.", 
            "title": "Emit the final build file"
        }, 
        {
            "location": "/developer/contributing/", 
            "text": "Contributing\n\n\nSo, you'd like to help improve bfg9000 by writing a patch? Great! This page will\nprovide you with some useful information to help you get started.\n\n\nRunning tests\n\n\nbfg9000 has a suite of tests to ensure that everything works properly. (Well,\neverything that has tests!) As you may expect, you can run these via:\n\n\n$ python setup.py test\n\n\n\n\nIf you'd like to run a subset of tests, such as when trying to fix a bug in a\nspecific area of the code, you can limit the tests that get run. For instance,\nto run only the tests in \ntest/integration/test_simple.py\n, you can type:\n\n\n$ python setup.py test -s test.integration.test_simple\n\n\n\n\nLinting code\n\n\nbfg9000 uses \nflake8\n for linting.\nSince users generally don't need to worry about linting the codebase, this isn't\nautomatically installed by setup.py. You'll need to install it yourself. Once\ninstalled, you can use the \nlint\n command like so:\n\n\n$ python setup.py lint", 
            "title": "Contributing"
        }, 
        {
            "location": "/developer/contributing/#contributing", 
            "text": "So, you'd like to help improve bfg9000 by writing a patch? Great! This page will\nprovide you with some useful information to help you get started.", 
            "title": "Contributing"
        }, 
        {
            "location": "/developer/contributing/#running-tests", 
            "text": "bfg9000 has a suite of tests to ensure that everything works properly. (Well,\neverything that has tests!) As you may expect, you can run these via:  $ python setup.py test  If you'd like to run a subset of tests, such as when trying to fix a bug in a\nspecific area of the code, you can limit the tests that get run. For instance,\nto run only the tests in  test/integration/test_simple.py , you can type:  $ python setup.py test -s test.integration.test_simple", 
            "title": "Running tests"
        }, 
        {
            "location": "/developer/contributing/#linting-code", 
            "text": "bfg9000 uses  flake8  for linting.\nSince users generally don't need to worry about linting the codebase, this isn't\nautomatically installed by setup.py. You'll need to install it yourself. Once\ninstalled, you can use the  lint  command like so:  $ python setup.py lint", 
            "title": "Linting code"
        }, 
        {
            "location": "/license/", 
            "text": "License\n\n\nBSD 3-clause license\n\n\nCopyright (c) 2015-2016, Jim Porter\nAll rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n\n\n\n\n\nRedistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n\n\n\n\n\nNeither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\n\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "", 
            "title": "License"
        }, 
        {
            "location": "/license/#bsd-3-clause-license", 
            "text": "Copyright (c) 2015-2016, Jim Porter\nAll rights reserved.  Redistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:    Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.    Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.    Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", 
            "title": "BSD 3-clause license"
        }
    ]
}