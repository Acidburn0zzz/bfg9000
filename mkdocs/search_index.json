{
    "docs": [
        {
            "location": "/", 
            "text": "bfg9000\n\u00a7\n\n\nbfg9000\n (\n\"build file generator\"\n) is a cross-platform \nbuild configuration\nsystem\n with an emphasis on making it easy to define how to build your software.\nIt converts a Python-based build script into the appropriate files for your\nunderlying build system of choice.\n\n\nWhy bfg9000?\n\u00a7\n\n\n\n\nAlready familiar\n\u00a7\n\n\nbuild.bfg\n files are just Python scripts with some new functions added, so you\nmay already know how to write them; and when your build gets complicated, you\ncan rely on the existing Python ecosystem to get you out of trouble.\n\n\nBuild fast\n\u00a7\n\n\nPython may be slow, but bfg9000 gets out of the way as quickly as possible and\nrelies on existing, mature build systems like Make and Ninja to do the heavy\nlifting of building your software.\n\n\nStay sane\n\u00a7\n\n\nBuilding your code shouldn't be the hard part of developing your project. Above\nall else, bfg9000 strives to make it easy to write your build scripts.\n\n\n\n\nA brief example\n\u00a7\n\n\nYou can't get much simpler than the simplest \nbuild.bfg\n file:\n\n\nexecutable('simple', files=['simple.cpp'])\n\n\n\n\nTo build this executable, we need to create the actual build files and then\nrun them:\n\n\n$ cd /path/to/src/\n$ 9k build/\n$ cd build/\n$ ninja\n\n\n\n\nFrom there, you can run your newly-created executable: \n./simple\n. Hooray!\n\n\nFor further examples, please see the\n\nexamples/\n\nsubdirectory.", 
            "title": "Home"
        }, 
        {
            "location": "/#bfg9000", 
            "text": "bfg9000  ( \"build file generator\" ) is a cross-platform  build configuration\nsystem  with an emphasis on making it easy to define how to build your software.\nIt converts a Python-based build script into the appropriate files for your\nunderlying build system of choice.", 
            "title": "bfg9000"
        }, 
        {
            "location": "/#why-bfg9000", 
            "text": "", 
            "title": "Why bfg9000?"
        }, 
        {
            "location": "/#already-familiar", 
            "text": "build.bfg  files are just Python scripts with some new functions added, so you\nmay already know how to write them; and when your build gets complicated, you\ncan rely on the existing Python ecosystem to get you out of trouble.", 
            "title": "Already familiar"
        }, 
        {
            "location": "/#build-fast", 
            "text": "Python may be slow, but bfg9000 gets out of the way as quickly as possible and\nrelies on existing, mature build systems like Make and Ninja to do the heavy\nlifting of building your software.", 
            "title": "Build fast"
        }, 
        {
            "location": "/#stay-sane", 
            "text": "Building your code shouldn't be the hard part of developing your project. Above\nall else, bfg9000 strives to make it easy to write your build scripts.", 
            "title": "Stay sane"
        }, 
        {
            "location": "/#a-brief-example", 
            "text": "You can't get much simpler than the simplest  build.bfg  file:  executable('simple', files=['simple.cpp'])  To build this executable, we need to create the actual build files and then\nrun them:  $ cd /path/to/src/\n$ 9k build/\n$ cd build/\n$ ninja  From there, you can run your newly-created executable:  ./simple . Hooray!  For further examples, please see the examples/ \nsubdirectory.", 
            "title": "A brief example"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting Started\n\u00a7\n\n\nSupported platforms/languages\n\u00a7\n\n\nbfg9000 is designed to work on Linux, OS X, and Windows; other POSIX systems\nshould work as well, but they aren't explicitly supported (if you'd like to help\nadd support for your favorite platform, just file a pull request!). In addition,\nbfg9000 supports building code written in the following languages:\n\n\n\n\nC\n\n\nC++\n\n\nFortran (partial)\n\n\nObjective C/C++\n\n\n\n\nInstallation\n\u00a7\n\n\nbfg9000 uses \nsetuptools\n, so installation\nis much the same as any other Python package:\n\n\n$ pip install bfg9000\n\n\n\n\nIf you've downloaded bfg already, just run \npip install .\n from the source\ndirectory. (Equivalently, you can run \npython setup.py install\n.) From there,\nyou can start using bfg to build your software!\n\n\n\n\nNote\n\n\nIf you're using Ubuntu, you can also install bfg9000 from the following PPA:\n\nppa:jimporter/stable\n.\n\n\n\n\nInstalling patchelf\n\u00a7\n\n\nOn Linux, bfg9000 requires \npatchelf\n in order\nto modify \nrpath\ns of executables and\nshared libraries when installing. If you don't already have patchelf installed\n(e.g. via your distro's package manager) and in your \nPATH\n, bfg9000 will\nautomatically install it via the\n\npatchelf-wrapper\n package. If\nyou'd prefer not to install patchelf at all, you can set the \nNO_PATCHELF\n\nenvironment variable to 1 before installing bfg9000:\n\n\n$ NO_PATCHELF=1 pip install bfg9000\n\n\n\n\nThis will automatically download and install patchelf when installing the rest\nof bfg9000. If you're installing into a\n\nvirtualenv\n, patchelf\nwill go into \n$VIRTUAL_ENV/bin\n.\n\n\nInstalling MSBuild support\n\u00a7\n\n\nSince many users don't need it, MSBuild support is an optional feature. To\ninstall all the dependencies required for MSBuild, you can run the following:\n\n\n$ pip install bfg9000[msbuild]", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#supported-platformslanguages", 
            "text": "bfg9000 is designed to work on Linux, OS X, and Windows; other POSIX systems\nshould work as well, but they aren't explicitly supported (if you'd like to help\nadd support for your favorite platform, just file a pull request!). In addition,\nbfg9000 supports building code written in the following languages:   C  C++  Fortran (partial)  Objective C/C++", 
            "title": "Supported platforms/languages"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "bfg9000 uses  setuptools , so installation\nis much the same as any other Python package:  $ pip install bfg9000  If you've downloaded bfg already, just run  pip install .  from the source\ndirectory. (Equivalently, you can run  python setup.py install .) From there,\nyou can start using bfg to build your software!   Note  If you're using Ubuntu, you can also install bfg9000 from the following PPA: ppa:jimporter/stable .", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#installing-patchelf", 
            "text": "On Linux, bfg9000 requires  patchelf  in order\nto modify  rpath s of executables and\nshared libraries when installing. If you don't already have patchelf installed\n(e.g. via your distro's package manager) and in your  PATH , bfg9000 will\nautomatically install it via the patchelf-wrapper  package. If\nyou'd prefer not to install patchelf at all, you can set the  NO_PATCHELF \nenvironment variable to 1 before installing bfg9000:  $ NO_PATCHELF=1 pip install bfg9000  This will automatically download and install patchelf when installing the rest\nof bfg9000. If you're installing into a virtualenv , patchelf\nwill go into  $VIRTUAL_ENV/bin .", 
            "title": "Installing patchelf"
        }, 
        {
            "location": "/getting-started/#installing-msbuild-support", 
            "text": "Since many users don't need it, MSBuild support is an optional feature. To\ninstall all the dependencies required for MSBuild, you can run the following:  $ pip install bfg9000[msbuild]", 
            "title": "Installing MSBuild support"
        }, 
        {
            "location": "/user/building/", 
            "text": "Building With bfg9000\n\u00a7\n\n\nLike some other tools (e.g. \nCMake\n or\n\nautotools\n), bfg9000 isn't actually a\nbuild system; it's a \nbuild configuration system\n or, if you prefer, a\n\nmeta-build system\n. That is, bfg9000 builds build files which you then use to\nrun your actual builds.\n\n\nYour first build\n\u00a7\n\n\nInvoking bfg9000 is simple. Assuming you have an existing project that uses\nbfg9000, just call \nbfg9000 configure builddir\n and it will generate the final\nbuild script (\nbuild.ninja\n in this case) in \nbuilddir\n to use for\nbuilding your project:\n\n\n$ cd /path/to/src/\n$ bfg9000 configure build/\n$ cd build/\n$ ninja\n\n\n\n\nSince the configure command is easily the most common thing to run when using\nbfg9000, you can use the following shorthand instead of\n\nbfg9000 configure build/\n:\n\n\n$ 9k build/\n\n\n\n\n\n\nNote\n\n\nOn Windows, using bfg9000 requires a bit more care. Since the MSVC tools\naren't in the \nPATH\n by default, you can't just open any command prompt.\nYou need to pick the \ncorrect\n prompt. Thankfully, Visual Studio provides\nStart Menu items such as \"VS2015 Developer Command Prompt\". These add the\nappropiate directories to the \nPATH\n, allowing you to use whichever version\nof the MSVC tools that you'd like.\n\n\n\n\nBuild directories\n\u00a7\n\n\nYou might have noticed above that \nbuild.ninja\n was placed in a separate\ndirectory. This is because bfg9000 exclusively uses \nout-of-tree builds\n; that\nis, the build directory must be different from the source directory. While\nslightly more inconvenient for one-off builds (users will have to \ncd\n into\nanother directory to start the build), the benefits are significant. First, it\nensures that cleaning a build is trivial: just remove the build directory.\nSecond, simplifies building in multiple configurations, a very useful feature\nfor development; you can easily have debug and optimized builds sitting\nside-by-side.\n\n\nIn our example above, we specified the build directory to place the final build\nfiles. However, you can also run bfg9000 \nfrom\n the build directory, in which\ncase you'd run \nbfg9000 configure srcdir/\n (or, equivalently, \n9k srcdir/\n). If\nneither the source nor build directories are your current working directory, you\ncan run:\n\n\nbfg9000 configure-into srcdir/ builddir/\n\n\n\n\nSelecting a backend\n\u00a7\n\n\nBy default, bfg9000 tries to use the most appropriate build backend for your\nsystem. In descending order, bfg prefers \nninja\n,\n\nmake\n, and\n\nmsbuild\n.\nIf one of these isn't installed, it will try the next best option. However, you\ncan explicitly select a backend with the \n--backend\n option. For instance, to\nbuild a Makefile even if Ninja is installed:\n\n\n$ bfg9000 configure builddir/ --backend=make\n\n\n\n\nSetting options\n\u00a7\n\n\nMany options for building can be set via the environment. These generally follow\nthe UNIX naming conventions, so you can use, say,\n\nCXX\n to change the C++ compiler that bfg9000 uses.\nFor a full listing of the recognized environment variables, see the \nEnvironment\nVariables\n chapter.\n\n\nInstalling your software\n\u00a7\n\n\nAfter building your software, you may wish to install it to another directory on\nyour system. You can do this by running:\n\n\n$ ninja install\n\n\n\n\nOf course, if you're using the Make backend, you'd run \nmake install\n instead.\n\n\n\n\nWarning\n\n\nThe MSBuild backend doesn't currently support this command.\n\n\n\n\nInstall locations\n\u00a7\n\n\nBy default, bfg9000 will install them into the appropriate place for your\nplatform (e.g. \n/usr/local/bin\n for exectuables on POSIX systems).  However, you\ncan specify where you'd like to install your project when invoking bfg9000. To\nchange the installation prefix (\n/usr/local\n on POSIX), just specify \n--prefix\n/path/to/prefix\n when running bfg9000. You can also specify the binary, library,\nand include directories individually, using \n--bindir\n, \n--libdir\n, and\n\n--includedir\n, respectively.\n\n\nDistributing your source\n\u00a7\n\n\nOnce you're ready to release your software, you'll want to provide a source\ndistribution. You can't just archive the entire source directory, since it'll\ninclude things that don't belong like \n.gitignore\n. Instead, you should run:\n\n\n$ ninja dist\n\n\n\n\n(Of course, you should run \nmake dist\n for the Make backend.) This will produce\na \ntar.gz\n file containing all the source files necessary for building your\nproject. If you'd like to specify another file format, you can use one of the\nfollowing targets: \ndist-gzip\n, \ndist-bzip2\n, or \ndist-zip\n.\n\n\n\n\nWarning\n\n\nThe MSBuild backend doesn't currently support this command.", 
            "title": "Building with bfg9000"
        }, 
        {
            "location": "/user/building/#building-with-bfg9000", 
            "text": "Like some other tools (e.g.  CMake  or autotools ), bfg9000 isn't actually a\nbuild system; it's a  build configuration system  or, if you prefer, a meta-build system . That is, bfg9000 builds build files which you then use to\nrun your actual builds.", 
            "title": "Building With bfg9000"
        }, 
        {
            "location": "/user/building/#your-first-build", 
            "text": "Invoking bfg9000 is simple. Assuming you have an existing project that uses\nbfg9000, just call  bfg9000 configure builddir  and it will generate the final\nbuild script ( build.ninja  in this case) in  builddir  to use for\nbuilding your project:  $ cd /path/to/src/\n$ bfg9000 configure build/\n$ cd build/\n$ ninja  Since the configure command is easily the most common thing to run when using\nbfg9000, you can use the following shorthand instead of bfg9000 configure build/ :  $ 9k build/   Note  On Windows, using bfg9000 requires a bit more care. Since the MSVC tools\naren't in the  PATH  by default, you can't just open any command prompt.\nYou need to pick the  correct  prompt. Thankfully, Visual Studio provides\nStart Menu items such as \"VS2015 Developer Command Prompt\". These add the\nappropiate directories to the  PATH , allowing you to use whichever version\nof the MSVC tools that you'd like.", 
            "title": "Your first build"
        }, 
        {
            "location": "/user/building/#build-directories", 
            "text": "You might have noticed above that  build.ninja  was placed in a separate\ndirectory. This is because bfg9000 exclusively uses  out-of-tree builds ; that\nis, the build directory must be different from the source directory. While\nslightly more inconvenient for one-off builds (users will have to  cd  into\nanother directory to start the build), the benefits are significant. First, it\nensures that cleaning a build is trivial: just remove the build directory.\nSecond, simplifies building in multiple configurations, a very useful feature\nfor development; you can easily have debug and optimized builds sitting\nside-by-side.  In our example above, we specified the build directory to place the final build\nfiles. However, you can also run bfg9000  from  the build directory, in which\ncase you'd run  bfg9000 configure srcdir/  (or, equivalently,  9k srcdir/ ). If\nneither the source nor build directories are your current working directory, you\ncan run:  bfg9000 configure-into srcdir/ builddir/", 
            "title": "Build directories"
        }, 
        {
            "location": "/user/building/#selecting-a-backend", 
            "text": "By default, bfg9000 tries to use the most appropriate build backend for your\nsystem. In descending order, bfg prefers  ninja , make , and msbuild .\nIf one of these isn't installed, it will try the next best option. However, you\ncan explicitly select a backend with the  --backend  option. For instance, to\nbuild a Makefile even if Ninja is installed:  $ bfg9000 configure builddir/ --backend=make", 
            "title": "Selecting a backend"
        }, 
        {
            "location": "/user/building/#setting-options", 
            "text": "Many options for building can be set via the environment. These generally follow\nthe UNIX naming conventions, so you can use, say, CXX  to change the C++ compiler that bfg9000 uses.\nFor a full listing of the recognized environment variables, see the  Environment\nVariables  chapter.", 
            "title": "Setting options"
        }, 
        {
            "location": "/user/building/#installing-your-software", 
            "text": "After building your software, you may wish to install it to another directory on\nyour system. You can do this by running:  $ ninja install  Of course, if you're using the Make backend, you'd run  make install  instead.   Warning  The MSBuild backend doesn't currently support this command.", 
            "title": "Installing your software"
        }, 
        {
            "location": "/user/building/#install-locations", 
            "text": "By default, bfg9000 will install them into the appropriate place for your\nplatform (e.g.  /usr/local/bin  for exectuables on POSIX systems).  However, you\ncan specify where you'd like to install your project when invoking bfg9000. To\nchange the installation prefix ( /usr/local  on POSIX), just specify  --prefix\n/path/to/prefix  when running bfg9000. You can also specify the binary, library,\nand include directories individually, using  --bindir ,  --libdir , and --includedir , respectively.", 
            "title": "Install locations"
        }, 
        {
            "location": "/user/building/#distributing-your-source", 
            "text": "Once you're ready to release your software, you'll want to provide a source\ndistribution. You can't just archive the entire source directory, since it'll\ninclude things that don't belong like  .gitignore . Instead, you should run:  $ ninja dist  (Of course, you should run  make dist  for the Make backend.) This will produce\na  tar.gz  file containing all the source files necessary for building your\nproject. If you'd like to specify another file format, you can use one of the\nfollowing targets:  dist-gzip ,  dist-bzip2 , or  dist-zip .   Warning  The MSBuild backend doesn't currently support this command.", 
            "title": "Distributing your source"
        }, 
        {
            "location": "/user/writing/", 
            "text": "Writing a Build File\n\u00a7\n\n\nbfg9000's build script is called \nbuild.bfg\n and is (usually) placed in the root\nof your source tree. \nbuild.bfg\n files are just Python scripts with a handful of\nextra built-in functions to define all the rules for building your software.\nWhile bfg9000's goal is to make writing build scripts easy, sometimes complexity\nis unavoidable. By using a general-purpose language, this complexity can\n(hopefully!) be managed.\n\n\nYour first build script\n\u00a7\n\n\nThe simplest build script, compiling a single source file into an\n\nexecutable\n, is indeed very simple:\n\n\nexecutable('simple', files=['simple.cpp'])\n\n\n\n\nThe above is all you need to build your executable for any supported build\nbackend and platform. The output file's name is automatically converted to the\nappropriate name for the target platform (\n'simple'\n on Linux and OS X and\n\n'simple.exe'\n on Windows).\n\n\nBuilding executables\n\u00a7\n\n\nWe've already seen how to build simple executables, but build tools aren't much\ngood if that's all they can do! Naturally, it's easy to build an executable from\nmultiple source files (just add more elements to the \nfiles\n argument), but\nthere are plenty of other things you'd probably like to do with your build\nscripts.\n\n\nImplicit conversions\n\u00a7\n\n\nbfg9000 tries its best to make your build scripts easy to read and to minimize\nverbosity. First, arguments that normally take a list can take a single item\ninstead, e.g. \nexecutable('simple', files='simple.cpp')\n. In addition, bfg9000\nwill automatically convert a string argument to an object of the appropriate\ntype. In the previous example, \n'simple.cpp'\n is automatically converted to a\n\nsource_file\n.\n\n\nSudirectories\n\u00a7\n\n\nMany projects organize their headers and source files into different\ndirectories. For source files, this is easy to handle: just write out the\nrelative path to the file. For header files, you need to let your compiler know\nwhere they're located. The\n\nheader_directory\n function creates\na reference to the directory, which can then be passed to your build function\nvia the \ninclude\n argument:\n\n\ninclude_dir = header_directory('include')\nexecutable('program', files=['src/prog.cpp'], include=[include_dir])\n\n\n\n\nAs noted above, you can also simplify this to:\n\n\nexecutable('program', files='src/prog.cpp', include='include')\n\n\n\n\nOf course, bfg9000 also allows you to place built files in subdirectories as\nwell. Simply specify the relative path as the name of executable (or whatever\ntype of file you're building).\n\n\nOptions\n\u00a7\n\n\nBuild scripts often need to set options when compiling/linking binaries.\nSometimes, these are specific to a single executable in the project, and other\ntimes they apply to \nall\n the binaries. bfg9000 supports both cases. You can\nprovide options for a single binary with the \ncompile_options\n and\n\nlink_options\n arguments:\n\n\nexecutable('simple', files=['simple.cpp'], compile_options=['-Wall', '-Werror'],\n           link_options=['-static-libstdc++'])\n\n\n\n\nYou can also specify \nglobal compiler options\n (on\na per-language basis) as well as \nglobal linker\noptions\n:\n\n\nglobal_options(['-Wall', '-Werror'], lang='c++')\nglobal_link_options(['-static-libstdc++'])\n\n\n\n\nNaturally, the interpretations of these arguments depend on the compiler being\nused, so it's important to be sure the compiler understands the arguments. You\ncan determine the kind of compiler being used by consulting the build's\n\nEnvironment\n and checking the compiler's\n\nflavor\n.\n\n\nBuilding libraries\n\u00a7\n\n\nSimilar to building executables, you can also build\n\nshared\n and \nstatic\n\nlibraries. These take the same arguments as above, although static libraries\nhave no use for the \nlink_options\n argument.\n\n\nOnce you've defined rules to build a library, you can pass it along to an\nexecutable or other shared library via the \nlibs\n argument:\n\n\nshared = shared_library('shared', files=['shared.cpp'])\nstatic = static_library('shared', files=['static.cpp'])\nexecutable('program', files=['program.cpp'], libs=[shared, static])\n\n\n\n\nBuilding libraries on Windows\n\u00a7\n\n\nOn Windows, native shared libraries need to annotate public symbols so that the\ndynamic linker knows what to do. To facilitate this, bfg9000 automatically\ndefines a preprocessor macro named for native-runtime languages (e.g. C or C++)\nwhen building on Windows. For shared libraries, it defines \nLIB\nNAME\n_EXPORTS\n;\nfor static, \nLIB\nNAME\n_STATIC\n. The following snippet shows how you can use\nthese macros to set the appropriate attributes for your public symbols:\n\n\n#if defined(_WIN32) \n !defined(LIBLIBRARY_STATIC)\n#  ifdef LIBLIBRARY_EXPORTS\n#    define LIB_PUBLIC __declspec(dllexport)\n#  else\n#    define LIB_PUBLIC __declspec(dllimport)\n#  endif\n#else\n#  define LIB_PUBLIC\n#endif\n\n\n\n\nFinding files\n\u00a7\n\n\nFor projects with many source files, it can be inconvenient to manually list all\nof them. Since \nbuild.bfg\n files are just Python scripts, you \ncould\n use\nPython's standard library to examine the file system and build the list.\nHowever, there's a better way: bfg9000 provides a\n\nfind_files()\n function to fetch the list; if the\nlist ever changes, the build files will be regenerated \nautomatically\n the next\ntime they're run.\n\n\nfind_files()\n starts at a base directory and searches recursively for any files\nmatching a particular glob:\n\n\nhello_files = find_files('src/hello', '*.cpp')\nexecutable('hello', files=hello_files)\n\n\n\n\nThere are lots of options you can pass to \nfind_files()\n to tweak its behavior.\nFor instance, you can search only for files or only for directories by passing\n\n'f'\n or \n'd'\n, respectively to the \ntype\n argument.\n\n\nDefault targets\n\u00a7\n\n\nWhen you're building multiple binaries, you might want to be able to specify\nwhat gets built by default, i.e. when calling \nmake\n (or \nninja\n) with no\narguments. Normally, every executable and library (except those passed to\n\ntest()\n) will get built. However, you can pass any build\nrule(s) to \ndefault()\n, and they'll be set as the\ndefault, overriding the normal behavior. This makes it easy to provide your\nusers with a standard build that gets them all the bits they need, and none they\ndon't.\n\n\nExternal packages\n\u00a7\n\n\nMost projects have external packages that they depend on. There are lots of\ndifferent ways these packages are organized, and bfg9000 currently supports\nthree of them: \n\"system\" packages\n (libraries\ninstalled into the default location for your system), \npkg-config\npackages\n, and \nBoost\npackages\n:\n\n\nogg = system_package('ogg', kind='static')\nzlib = pkgconfig_package('zlib', version='\n=1.2.8')\nprog_opts = boost_package('program_options', version='\n=1.55')\n\n\n\n\nEach of these returns an object representing the package that can be used when\nbuilding binaries by passing them in the \npackages\n argument:\n\n\nexecutable('program', files=['main.cpp'], packages=[ogg, zlib, prog_opts])\n\n\n\n\nInstallation\n\u00a7\n\n\nAfter building, you might want to allow your project to be installed onto the\nuser's system somewhere. Most files (headers, executables, libraries) can be\nadded to the list of installed files via the\n\ninstall()\n rule. You can also install entire\ndirectories of headers:\n\n\ninclude_dir = header_directory('include')\nlib = static_library('program', files=['src/prog.cpp'], include=[include_dir])\ninstall(lib, include_dir)\n\n\n\n\nCommands\n\u00a7\n\n\nIn addition to ordinary build rules, it can be useful to provide other common\ncommands that apply to a project's source, such as linting the code or building\ndocumentation. Normally, you should pass the command to be run as an array of\narguments. This will automatically handle escaping any quotes in each argument.\nThis is especially important for cross-platform compatibility, since different\nshells have different quoting rules:\n\n\ncommand('hello', cmd=['python', '-c', 'print(\nhello\n)'])\n\n\n\n\nOf course, if you need to use your shell's special characters (like \n), you\ncan simply pass a string to the \ncmd\n argument. In addition, you can supply\nmultiple commands to this function via the \ncmds\n argument:\n\n\ncommand('script', cmds=[\n    'touch file',\n    ['python', 'script.py']\n])\n\n\n\n\nAliases\n\u00a7\n\n\nSometimes, you just want to group a set of targets together to make it easier to\nbuild all of them at once. This automatically happens for \ndefault\ntargets\n by creating an \nall\n alias, but you can do this\nyourself for any collection of targets:\n\n\nfoo = executable('foo', files=['foo.cpp'])\nbar = executable('bar', files=['bar.cpp'])\nalias('foobar', [foo, bar])\n\n\n\n\nTests\n\u00a7\n\n\nAll good projects should have tests. Since your project is good (isn't it?),\nyours has tests too, and you should have a good way to execute those tests from\nyour build system. bfg9000 provides a \nset of\nfunctions\n for running tests. The most important of\nthese is aptly named \ntest()\n. Any executable can be passed\nto this function, and it will be executed as a test; an exit status of 0 marks\nsuccess, and non-zero marks failure:\n\n\ntest( executable('test_foo', files=['test_foo.cpp']) )\n\n\n\n\nIn addition, you can provide a \ntest driver\n that\ncollects all of your tests together and runs them as one. \ntest_driver()\n takes\nan executable (a \nsystem_executable\n by\ndefault) that runs all the test files. This allows you to aggregate multiple\ntest files into a single run, which is very useful for reporting:\n\n\nmettle = test_driver('mettle')\ntest( executable('test_foo', files=['test_foo.cpp']), driver=mettle )\ntest( executable('test_bar', files=['test_bar.cpp']), driver=mettle )\n\n\n\n\nCustom build steps\n\u00a7\n\n\nSometimes, the built-in build steps don't support the things you want to do\n(e.g. if you're generating source files via Flex/Bison). In these cases, you\ncan use \nbuild_step()\n to define a step that produces\na file by running an arbitrary command:\n\n\nlex = build_step('lex.yy.c', cmd=[ 'flex', source_file('hello.lex') ])\n\n\n\n\nYou can also define steps that produce \nmultiple\n files. When doing this, you'll\ngenerally want to specify the \ntype\n argument as well, which lets you indicate\nthe type of file object to return. In addition, you can pass \nargs\n and \nkwargs\n\nto forward arguments along to \ntype\n:\n\n\nhdr, src = build_step(['hello.tab.h', 'hello.tab.c'], cmd=[\n    'bison', 'hello.y'\n], type=[header_file, source_file])", 
            "title": "Writing a Build File"
        }, 
        {
            "location": "/user/writing/#writing-a-build-file", 
            "text": "bfg9000's build script is called  build.bfg  and is (usually) placed in the root\nof your source tree.  build.bfg  files are just Python scripts with a handful of\nextra built-in functions to define all the rules for building your software.\nWhile bfg9000's goal is to make writing build scripts easy, sometimes complexity\nis unavoidable. By using a general-purpose language, this complexity can\n(hopefully!) be managed.", 
            "title": "Writing a Build File"
        }, 
        {
            "location": "/user/writing/#your-first-build-script", 
            "text": "The simplest build script, compiling a single source file into an executable , is indeed very simple:  executable('simple', files=['simple.cpp'])  The above is all you need to build your executable for any supported build\nbackend and platform. The output file's name is automatically converted to the\nappropriate name for the target platform ( 'simple'  on Linux and OS X and 'simple.exe'  on Windows).", 
            "title": "Your first build script"
        }, 
        {
            "location": "/user/writing/#building-executables", 
            "text": "We've already seen how to build simple executables, but build tools aren't much\ngood if that's all they can do! Naturally, it's easy to build an executable from\nmultiple source files (just add more elements to the  files  argument), but\nthere are plenty of other things you'd probably like to do with your build\nscripts.", 
            "title": "Building executables"
        }, 
        {
            "location": "/user/writing/#implicit-conversions", 
            "text": "bfg9000 tries its best to make your build scripts easy to read and to minimize\nverbosity. First, arguments that normally take a list can take a single item\ninstead, e.g.  executable('simple', files='simple.cpp') . In addition, bfg9000\nwill automatically convert a string argument to an object of the appropriate\ntype. In the previous example,  'simple.cpp'  is automatically converted to a source_file .", 
            "title": "Implicit conversions"
        }, 
        {
            "location": "/user/writing/#sudirectories", 
            "text": "Many projects organize their headers and source files into different\ndirectories. For source files, this is easy to handle: just write out the\nrelative path to the file. For header files, you need to let your compiler know\nwhere they're located. The header_directory  function creates\na reference to the directory, which can then be passed to your build function\nvia the  include  argument:  include_dir = header_directory('include')\nexecutable('program', files=['src/prog.cpp'], include=[include_dir])  As noted above, you can also simplify this to:  executable('program', files='src/prog.cpp', include='include')  Of course, bfg9000 also allows you to place built files in subdirectories as\nwell. Simply specify the relative path as the name of executable (or whatever\ntype of file you're building).", 
            "title": "Sudirectories"
        }, 
        {
            "location": "/user/writing/#options", 
            "text": "Build scripts often need to set options when compiling/linking binaries.\nSometimes, these are specific to a single executable in the project, and other\ntimes they apply to  all  the binaries. bfg9000 supports both cases. You can\nprovide options for a single binary with the  compile_options  and link_options  arguments:  executable('simple', files=['simple.cpp'], compile_options=['-Wall', '-Werror'],\n           link_options=['-static-libstdc++'])  You can also specify  global compiler options  (on\na per-language basis) as well as  global linker\noptions :  global_options(['-Wall', '-Werror'], lang='c++')\nglobal_link_options(['-static-libstdc++'])  Naturally, the interpretations of these arguments depend on the compiler being\nused, so it's important to be sure the compiler understands the arguments. You\ncan determine the kind of compiler being used by consulting the build's Environment  and checking the compiler's flavor .", 
            "title": "Options"
        }, 
        {
            "location": "/user/writing/#building-libraries", 
            "text": "Similar to building executables, you can also build shared  and  static \nlibraries. These take the same arguments as above, although static libraries\nhave no use for the  link_options  argument.  Once you've defined rules to build a library, you can pass it along to an\nexecutable or other shared library via the  libs  argument:  shared = shared_library('shared', files=['shared.cpp'])\nstatic = static_library('shared', files=['static.cpp'])\nexecutable('program', files=['program.cpp'], libs=[shared, static])", 
            "title": "Building libraries"
        }, 
        {
            "location": "/user/writing/#building-libraries-on-windows", 
            "text": "On Windows, native shared libraries need to annotate public symbols so that the\ndynamic linker knows what to do. To facilitate this, bfg9000 automatically\ndefines a preprocessor macro named for native-runtime languages (e.g. C or C++)\nwhen building on Windows. For shared libraries, it defines  LIB NAME _EXPORTS ;\nfor static,  LIB NAME _STATIC . The following snippet shows how you can use\nthese macros to set the appropriate attributes for your public symbols:  #if defined(_WIN32)   !defined(LIBLIBRARY_STATIC)\n#  ifdef LIBLIBRARY_EXPORTS\n#    define LIB_PUBLIC __declspec(dllexport)\n#  else\n#    define LIB_PUBLIC __declspec(dllimport)\n#  endif\n#else\n#  define LIB_PUBLIC\n#endif", 
            "title": "Building libraries on Windows"
        }, 
        {
            "location": "/user/writing/#finding-files", 
            "text": "For projects with many source files, it can be inconvenient to manually list all\nof them. Since  build.bfg  files are just Python scripts, you  could  use\nPython's standard library to examine the file system and build the list.\nHowever, there's a better way: bfg9000 provides a find_files()  function to fetch the list; if the\nlist ever changes, the build files will be regenerated  automatically  the next\ntime they're run.  find_files()  starts at a base directory and searches recursively for any files\nmatching a particular glob:  hello_files = find_files('src/hello', '*.cpp')\nexecutable('hello', files=hello_files)  There are lots of options you can pass to  find_files()  to tweak its behavior.\nFor instance, you can search only for files or only for directories by passing 'f'  or  'd' , respectively to the  type  argument.", 
            "title": "Finding files"
        }, 
        {
            "location": "/user/writing/#default-targets", 
            "text": "When you're building multiple binaries, you might want to be able to specify\nwhat gets built by default, i.e. when calling  make  (or  ninja ) with no\narguments. Normally, every executable and library (except those passed to test() ) will get built. However, you can pass any build\nrule(s) to  default() , and they'll be set as the\ndefault, overriding the normal behavior. This makes it easy to provide your\nusers with a standard build that gets them all the bits they need, and none they\ndon't.", 
            "title": "Default targets"
        }, 
        {
            "location": "/user/writing/#external-packages", 
            "text": "Most projects have external packages that they depend on. There are lots of\ndifferent ways these packages are organized, and bfg9000 currently supports\nthree of them:  \"system\" packages  (libraries\ninstalled into the default location for your system),  pkg-config\npackages , and  Boost\npackages :  ogg = system_package('ogg', kind='static')\nzlib = pkgconfig_package('zlib', version=' =1.2.8')\nprog_opts = boost_package('program_options', version=' =1.55')  Each of these returns an object representing the package that can be used when\nbuilding binaries by passing them in the  packages  argument:  executable('program', files=['main.cpp'], packages=[ogg, zlib, prog_opts])", 
            "title": "External packages"
        }, 
        {
            "location": "/user/writing/#installation", 
            "text": "After building, you might want to allow your project to be installed onto the\nuser's system somewhere. Most files (headers, executables, libraries) can be\nadded to the list of installed files via the install()  rule. You can also install entire\ndirectories of headers:  include_dir = header_directory('include')\nlib = static_library('program', files=['src/prog.cpp'], include=[include_dir])\ninstall(lib, include_dir)", 
            "title": "Installation"
        }, 
        {
            "location": "/user/writing/#commands", 
            "text": "In addition to ordinary build rules, it can be useful to provide other common\ncommands that apply to a project's source, such as linting the code or building\ndocumentation. Normally, you should pass the command to be run as an array of\narguments. This will automatically handle escaping any quotes in each argument.\nThis is especially important for cross-platform compatibility, since different\nshells have different quoting rules:  command('hello', cmd=['python', '-c', 'print( hello )'])  Of course, if you need to use your shell's special characters (like  ), you\ncan simply pass a string to the  cmd  argument. In addition, you can supply\nmultiple commands to this function via the  cmds  argument:  command('script', cmds=[\n    'touch file',\n    ['python', 'script.py']\n])", 
            "title": "Commands"
        }, 
        {
            "location": "/user/writing/#aliases", 
            "text": "Sometimes, you just want to group a set of targets together to make it easier to\nbuild all of them at once. This automatically happens for  default\ntargets  by creating an  all  alias, but you can do this\nyourself for any collection of targets:  foo = executable('foo', files=['foo.cpp'])\nbar = executable('bar', files=['bar.cpp'])\nalias('foobar', [foo, bar])", 
            "title": "Aliases"
        }, 
        {
            "location": "/user/writing/#tests", 
            "text": "All good projects should have tests. Since your project is good (isn't it?),\nyours has tests too, and you should have a good way to execute those tests from\nyour build system. bfg9000 provides a  set of\nfunctions  for running tests. The most important of\nthese is aptly named  test() . Any executable can be passed\nto this function, and it will be executed as a test; an exit status of 0 marks\nsuccess, and non-zero marks failure:  test( executable('test_foo', files=['test_foo.cpp']) )  In addition, you can provide a  test driver  that\ncollects all of your tests together and runs them as one.  test_driver()  takes\nan executable (a  system_executable  by\ndefault) that runs all the test files. This allows you to aggregate multiple\ntest files into a single run, which is very useful for reporting:  mettle = test_driver('mettle')\ntest( executable('test_foo', files=['test_foo.cpp']), driver=mettle )\ntest( executable('test_bar', files=['test_bar.cpp']), driver=mettle )", 
            "title": "Tests"
        }, 
        {
            "location": "/user/writing/#custom-build-steps", 
            "text": "Sometimes, the built-in build steps don't support the things you want to do\n(e.g. if you're generating source files via Flex/Bison). In these cases, you\ncan use  build_step()  to define a step that produces\na file by running an arbitrary command:  lex = build_step('lex.yy.c', cmd=[ 'flex', source_file('hello.lex') ])  You can also define steps that produce  multiple  files. When doing this, you'll\ngenerally want to specify the  type  argument as well, which lets you indicate\nthe type of file object to return. In addition, you can pass  args  and  kwargs \nto forward arguments along to  type :  hdr, src = build_step(['hello.tab.h', 'hello.tab.c'], cmd=[\n    'bison', 'hello.y'\n], type=[header_file, source_file])", 
            "title": "Custom build steps"
        }, 
        {
            "location": "/user/reference/", 
            "text": "Reference\n\u00a7\n\n\nFile types\n\u00a7\n\n\nFiles used in a \nbuild.bfg\n script are divided by their types (e.g. source\ncode, header files, etc). All files from the source directory which are\nreferenced in the \nbuild.bfg\n script will automatically be added to the source\ndistribution when it's built.\n\n\nIn most cases, you can simply pass a string to functions expecting a file type;\nthe string will automatically be converted to a file object of the appropriate\ntype. However, in some cases, you may wish to explicitly create a file object.\nThis can be useful, for instance, when running commands that take a source file\nas an argument, e.g. in the following snippet:\n\n\ncommand('script', cmd=['python', source_file('script.py')])\n\n\n\n\nUsing \nsource_file\n here allows you to specify that the\nfile is found in the \nsource directory\n, rather than the build directory.\n\n\ndirectory(\nname\n, [\ninclude\n], [\nexclude\n], [\nfilter\n])\n\u00a7\n\n\nCreate a reference to an existing directory named \nname\n. This allows you to\nrefer to an arbitrary subfolder of your source directory. The arguments\n\ninclude\n, \nexclude\n, and \nfilter\n are as per \nfind_files\n. Any\nmatching files will be added to the project's \nsource\ndistribution\n.\n\n\nextra_dist([\nfiles\n], [\ndirs\n])\n\u00a7\n\n\nAdd extra \nfiles\n and \ndirs\n to the list of recognized source files. This lets\nyou reference files that are part of the source distribution but which have no\nimpact on the build proper (e.g. READMEs).\n\n\ngeneric_file(\nname\n)\n\u00a7\n\n\nCreate a reference to an existing file named \nname\n.\n\n\nheader_directory(\nname\n, [\ninclude\n], [\nexclude\n], [\nfilter\n], [\nsystem\n])\n\u00a7\n\n\nCreate a reference to a directory named \nname\n containing header files for the\nproject. This can then be used in the \ninclude\n argument when\n\ncompiling\n a source file. The arguments \ninclude\n, \nexclude\n, and\n\nfilter\n are as per \nfind_files\n. Any matching files will be\nadded to the project's \nsource\ndistribution\n.\n\n\nIf \nsystem\n is \nTrue\n, this directory will be treated as a\n\nsystem directory\n for\ncompilers that support this.\n\n\nheader_file(\nname\n)\n\u00a7\n\n\nCreate a reference to an existing header named \nname\n. This is useful if you'd\nlike to \ninstall\n a single header file for your project.\n\n\nsource_file(\nname\n, [\nlang\n])\n\u00a7\n\n\nCreate a reference to an existing source file named \nname\n. If \nlang\n is not\nspecified, the language of the file is inferred from its extension.\n\n\nBuild steps\n\u00a7\n\n\nBuild steps define rules to create an output (usually a file) from zero or more\ninputs (also usually files). As you may expect, if the output doesn't exist, the\nstep is run to generate it. Each input is a dependency on the output, and any\nchanges to an input will result in a rebuild. This includes headers \n#include\nd\nby any of the source files, but does \nnot\n include files external to the project\n(i.e. \npackages\n).\n\n\nIn addition, all build steps have the ability to define extra dependencies via\nthe \nextra_deps\n argument. These can be files or other build steps, and changes\nto them will trigger a rebuild as with the build's inputs.\n\n\nFinally, build steps which produce a file can also be used like the\n\nfile types\n described above to refer to prebuilt files already in\nthe source tree (e.g. static libraries provided in binary form by a\nvendor). This is described in more detail for each step below.\n\n\n\n\nNote\n\n\nFor build steps which produce a file, the exact name of the output file is\ndetermined by the platform you're running on. For instance, when building an\nexecutable file named \"foo\" on Windows, the resulting file will be\n\nfoo.exe\n.\n\n\n\n\nbuild_step(\nname\n, \ncmd\n|\ncmds\n, [\nenvironment\n], [\ntype\n], [\nargs\n], [\nkwargs\n], [\nextra_deps\n])\n\u00a7\n\n\nCreate a custom build step that produces a file named \nname\n by running an\narbitrary command (\ncmd\n or \ncmds\n). \nname\n may either be a single file name or\na list of file names. For a description of the arguments \ncmd\n, \ncmds\n, and\n\nenvironment\n, see \ncommand\n below.\n\n\nBy default, this function return a \nsource_file\n; you can adjust\nthis with the \ntype\n argument. This should be either 1) a function returning a\nfile object, or 2) an object with a \n.type\n attribute that meets the criteria of\n(1). You can also pass \nargs\n and \nkwargs\n to forward arguments along to this\nfunction.\n\n\ncommand(\nname\n, \ncmd\n|\ncmds\n, [\nenvironment\n], [\nextra_deps\n])\n\u00a7\n\n\nCreate a build step named \nname\n that runs a list of arbitrary commands,\nspecified in either \ncmd\n or \ncmds\n; \ncmd\n takes a single command, whereas\n\ncmds\n takes a list of commands. Each command may either be a string to be\nparsed according to shell rules or a list of arguments to be passed directly to\nthe process.\n\n\nYou may also pass a dict to \nenvironment\n to set environment variables for the\ncommands. These override any environment variables set on the command line.\n\n\nexecutable(\nname\n, [\nfiles\n, ..., [\nextra_deps\n]])\n\u00a7\n\n\nCreate a build step that builds an executable file named \nname\n. \nfiles\n is the\nlist of source (or object) files to link. If an element of \nfiles\n is a source\nfile (or a plain string), this function will implicitly call\n\nobject_file\n on it.\n\n\nThe following arguments may also be specified:\n\n\n\n\ninclude\n: Forwarded on to \nobject_file\n\n\npch\n: Forwarded on to \nobject_file\n\n\nlibs\n: A list of library files (see \nshared_library\n and \nstatic_library\n)\n\n\npackages\n: A list of external \npackages\n; also forwarded on\n  to \nobject_file\n\n\ncompile_options\n: Forwarded on to\n  \nobject_file\n as \noptions\n\n\nlink_options\n: Command-line options to pass to the linker\n\n\nlang\n: Forwarded on to \nobject_file\n\n\n\n\nIf neither \nfiles\n nor \nlibs\n is specified, this function merely references an\n\nexisting\n executable file (a precompiled binary, a shell script, etc) somewhere\non the filesystem. In this case, \nname\n is the exact name of the file, relative\nto the source directory. This allows you to refer to existing executables for\nother functions. In addition, the following arguments may be specified:\n\n\n\n\nformat\n: The object format of the exectuable; by default, this is the\n  platform's native object format (e.g. \n'elf'\n on Linux)\n\n\n\n\nThis build step recognizes the \ndynamic linking environment\nvariables\n and the \ncompiler environment\nvariable\n (e.g. \nCC\n) for the\nrelevant language.\n\n\nobject_file([\nname\n], [\nfile\n, ..., [\nextra_deps\n]])\n\u00a7\n\n\nCreate a build step that compiles a source file named \nfile\n to an object file\nnamed \nname\n; if \nname\n is not specified, it takes the file name in \nfile\n\nwithout the extension.\n\n\nThe following arguments may also be specified:\n\n\n\n\ninclude\n: A list of \ndirectories\n to search for header\n  files; you may also pass \nheader files\n, and their directories will\n  be added to the search list\n\n\npch\n: A \nprecompiled header\n to use during compilation\n\n\npackages\n: A list of external \npackages\n\n\noptions\n: Command-line options to pass to the compiler\n\n\nlang\n: The language of the source file; useful if the source file's extension\n  isn't recognized by bfg9000\n\n\n\n\nIf \nfile\n isn't specified, this function merely references an \nexisting\n\nobject file somewhere on the filesystem. In this case, \nname\n must be specified\nand is the exact name of the file, relative to the source directory. In\naddition, the following arguments may be specified:\n\n\n\n\nformat\n: The object format of the file; by default, this is the platform's\n  native object format (e.g. \n'elf'\n on Linux)\n\n\nlang\n: The source language of the file; if none is specified, defaults to\n  \n'c'\n\n\n\n\nThis build step recognizes the \ncompilation environment\nvariables\n for the relevant language.\n\n\nobject_files(\nfiles\n, ..., [\nextra_deps\n])\n\u00a7\n\n\nCreate a compilation build step for each of the files in \nfiles\n; this is\nequivalent to calling \nobject_file\n for each element in \nfiles\n.\n\n\nIn addition, \nobject_files\n returns a special list that allows you to index into\nit using the filename of one of the source files listed in \nfiles\n. This makes\nit easy to extract a single object file to use in other places, e.g. test code.\nFor example:\n\n\nobjs = object_files(['foo.cpp', 'bar.cpp'])\nrelease_exe = executable('release', objs)\n\nfoo_obj = objs['foo.cpp']\ntest_exe = executable('test', ['test.cpp', foo_obj])\n\n\n\n\nprecompiled_header([\nname\n], [\nfile\n, ..., [\nextra_deps\n]])\n\u00a7\n\n\nCreate a build step that generates a precompiled header, which can be used to\nspeed up the compilation of \nobject files\n. If \nname\n is not\nspecified, it is inferred from the value of \nfile\n; the exact name varies based\non the compiler being used, but typically looks like \nheader.hpp.pch\n for\ncc-like compilers and \nheader.pch\n for MSVC-like compilers.\n\n\nThe arguments for \nprecompiled_header\n are the same as for\n\nobject_file\n, with the following additional argument:\n\n\n\n\npch_source\n: The source file to be used when building the precompiled\n  header. If this is not specified, a source file will automatically be created,\n  containing nothing but \n#include \"header\"\n, where \nheader\n is the name of the\n  header specified in \nfile\n. This option only applies to MSVC-like compilers;\n  for all others, it is ignored.\n\n\n\n\nIf \nfile\n isn't specified, this function merely references an \nexisting\n\nprecompiled header somewhere on the filesystem. In this case, \nname\n must be\nspecified and is the exact name of the file, relative to the source directory.\nIn addition, the following argument may be specified:\n\n\n\n\nlang\n: The source language of the file; if none is specified, defaults to\n  \n'c'\n\n\n\n\n\n\nWarning\n\n\nThe exact behavior of precompiled headers varies according to the compiler\nyou're using. In \nGCC\n and \nClang\n, the header to be\nprecompiled must be the \nfirst\n file \n#include\nd in each source file. In\n\nMSVC\n, the resulting precompiled header is actually compiled\nwithin the context of a particular source file and will contain all the\ncode \nup to and including\n the header in question.\n\n\n\n\nshared_library(\nname\n, [\nfiles\n, ..., [\nextra_deps\n]])\n\u00a7\n\n\nCreate a build step that builds a shared library named \nname\n. Its arguments are\nthe same as \nexecutable\n, with the following additional argument:\n\n\n\n\nversion\n: The version number of the library, e.g. \n1.2.3\n.\n\n\nsoversion\n: The API version of the library (used in its soname), e.g. \n1\n.\n\n\n\n\nLike with \nexecutable\n, if \nfiles\n isn't specified, this function merely\nreferences an \nexisting\n shared library somewhere on the filesystem. In this\ncase, \nname\n must be specified and is the exact name of the file, relative to\nthe source directory. You may also pass in the \nformat\n argument as with\n\nexecutable\n.\n\n\nThis build step recognizes the \ndynamic linking environment\nvariables\n and the \ncompiler environment\nvariable\n (e.g. \nCC\n) for the\nrelevant language.\n\n\n\n\nNote\n\n\nOn Windows, this produces \ntwo\n files for native-runtime languages (e.g. C\nor C++): \nname.dll\n and \nname.lib\n. The latter is the \nimport library\n, used\nwhen linking to this library. As a result, \nmy_lib.all\n returns a list\ncontaining \ntwo\n files.\n\n\nAdditionally for native languages on Windows, this step will add a\npreprocessor macro named \nLIB\nNAME\n_EXPORTS\n that can be used for declaring\npublic symbols. See \nBuilding libraries on\nWindows\n for an example of how to\nuse this macro in your code.\n\n\n\n\nstatic_library(\nname\n, [\nfiles\n, ..., [\nextra_deps\n]])\n\u00a7\n\n\nCreate a build step that builds a static library named \nname\n. Its arguments are\nthe same as \nexecutable\n. Link-related arguments (\nlink_options\n,\n\nlibs\n, and libraries from \npackages\n) have no direct effect on this build\nstep. Instead, they're cached and forwarded on to any dynamic linking step that\nuses this static library.\n\n\nLike with \nexecutable\n, if \nfiles\n isn't specified, this function merely\nreferences an \nexisting\n shared library somewhere on the filesystem. In this\ncase, \nname\n must be specified and is the exact name of the file, relative to\nthe source directory. In addition, the following arguments may be specified:\n\n\n\n\nformat\n: The object format of the exectuable; by default, this is the\n  platform's native object format (e.g. \n'elf'\n on Linux)\n\n\nlang\n: The source language(s) of the library; if none is specified, defaults\n  to \n['c']\n\n\n\n\nThis build step recognizes the \nstatic linking environment\nvariables\n.\n\n\n\n\nNote\n\n\nOn Windows, this step will add a preprocessor macro on Windows named\n\nLIB\nNAME\n_STATIC\n that can be used for declaring public symbols. See\n\nBuilding libraries on Windows\n\nfor an example of how to use this macro in your code.\n\n\n\n\nwhole_archive(\nname\n, [\nfiles\n, ..., [\nextra_deps\n]])\n\u00a7\n\n\nCreate a build step that builds a \nwhole-archive\n\nnamed \nname\n. Whole archives ensures that \nevery\n object file in the library is\nincluded, rather than just the ones whose symbols are referenced. This is\ntypically used to turn a static library into a shared library.\n\n\nwhole_archive\n's arguments are the same as for\n\nstatic_library\n. In addition, you can pass an existing\nstatic library to \nwhole_archive\n to convert it into a whole archive.\n\n\n\n\nWarning\n\n\nThe MSVC linker doesn't have a way of expressing the required directives, so\n\nwhole_archive\n can't be used with it.\n\n\n\n\nGrouping rules\n\u00a7\n\n\nalias(\nname\n, [\ndeps\n])\n\u00a7\n\n\nCreate a build step named \nname\n that performs no actions on its own. Instead,\nit just runs its dependencies listed in \ndeps\n as necessary. This build step is\nuseful for grouping common steps together.\n\n\ndefault(\n...\n)\n\u00a7\n\n\nSpecify a list of build steps that should be run by default when building. These\nare all accumulated into the \nall\n target. If \ndefault\n is never called, all\nexecutables and libraries \nnot\n passed to \ntest\n will be built by\ndefault.\n\n\ninstall(\n...\n)\n\u00a7\n\n\nSpecify a list of files that need to be installed for the project to work. Each\nwill be installed to the appropriate location based on its type, e.g. header\nfiles will go in \n$PREFIX/include\n by default on POSIX systems. These are all\naccumulated into the \ninstall\n target. If there are any runtime dependencies for\na file (such as shared libraries you just built), they will be installed as\nwell.\n\n\n\n\nNote\n\n\nWhen explicitly listing a target, \nall\n the files for that target will be\ninstalled. For instance, on Windows, this means that passing in a shared\nlibrary will install the DLL \nand\n the import library.\n\n\n\n\nThis rule recognizes the following environment variables:\n\nINSTALL\n,\n\nINSTALL_NAME_TOOL\n,\n\nMKDIR_P\n,\n\nPATCHELF\n.\n\n\nGlobal options\n\u00a7\n\n\nglobal_options(\noptions\n, \nlang\n)\n\u00a7\n\n\nSpecify some \noptions\n (either as a string or list) to use for all compilation\nsteps for the language \nlang\n.\n\n\nglobal_link_options(\noptions\n)\n\u00a7\n\n\nSpecify some \noptions\n (either as a string or list) to use for all link steps\n(i.e. for \nexecutables\n and \nshared libraries\n).\n\n\nTest rules\n\u00a7\n\n\nThese rules help you define automated tests that can all be run via the \ntest\n\ntarget. For simple cases, you should only need the \ntest\n rule, but you\ncan also wrap your tests with a separate driver using\n\ntest_driver\n.\n\n\nFor cases where you only want to \nbuild\n the tests, not run them, you can use\nthe \ntests\n target.\n\n\ntest(\ntest\n, [\noptions\n], [\nenvironment\n|\ndriver\n])\n\u00a7\n\n\nCreate a test for a single test file named \ntest\n. You may specify additional\ncommand-line arguments to the test in \noptions\n. You can also pass temporary\nenvironment variables as a dict via \nenvironment\n, or specify a test driver to\nadd this test file to via \ndriver\n.\n\n\ntest_driver(\ndriver\n, [\noptions\n], [\nenvironment\n|\nparent\n])\n\u00a7\n\n\nCreate a test driver which can run a series of tests, specified as command-line\narguments to the driver. You may specify driver-wide command-line arguments via\n\noptions\n. You can also pass temporary environment variables as a dict with\n\nenvironment\n, or specify a parent test driver to wrap this driver via \ndriver\n.\n\n\ntest_deps(\n...\n)\n\u00a7\n\n\nSpecify a list of dependencies which must be satisfied before the tests can be\nrun.\n\n\nPackage resolvers\n\u00a7\n\n\nboost_package([\nname\n], [\nversion\n])\n\u00a7\n\n\nSearch for a \nBoost\n library. You can specify \nname\n (as\na string or a list) to specify a specific Boost library (or libraries); for\ninstance, \n'program_options'\n. For header-only libraries, you can omit \nname\n.\nIf \nversion\n is specified, it will ensure that the installed version of Boost\nmeets the version requirement; it must be formatted as a Python \nversion\nspecifier\n.\n\n\nThis rule recognizes the following environment variables:\n\nBOOST_ROOT\n,\n\nBOOST_INCLUDEDIR\n,\n\nBOOST_LIBRARYDIR\n,\n\nCPATH\n,\n\nINCLUDE\n,\n\nLIB\n,\n\nLIBRARY_PATH\n.\n\n\npkgconfig_package(\nname\n, [\nversion\n], [\nlang\n])\n\u00a7\n\n\nSearch for a package named \nname\n via\n\npkg-config\n. If\n\nversion\n is specified, it will ensure that the installed version of the package\nmeets the version requirement; it must be formatted as a Python \nversion\nspecifier\n. \nlang\n\nis the source language of the library (\n'c'\n by default); this is useful if you\nneed to link a static library written in C++ with a program written in C.\n\n\nThis rule recognizes the following environment variable:\n\nPKG_CONFIG\n,\n\n\nsystem_executable(\nname\n)\n\u00a7\n\n\nSearch for an executable named \nname\n somewhere in the system's PATH.\n\n\nThis rule recognizes the following environment variables:\n\nPATH\n, \nPATHEXT\n.\n\n\nsystem_package(\nname\n, [\nlang\n], [\nkind\n], [\nheader\n])\n\u00a7\n\n\nSearch for a library named \nname\n somewhere in the system's default library\nlocation. \nlang\n is the source language of the library (\n'c'\n by default); this\nis useful if you need to link a static library written in C++ with a program\nwritten in C. You can also specify \nkind\n to one of \n'any'\n (the default),\n\n'shared'\n, or \n'static'\n. This allows you to restrict the search to find only\nstatic versions of a library, for example.\n\n\nFinally, the \nheader\n argument allows you to specify a header file (or list\nthereof) that you need to use in your source files. This will search for the\nheader file and add the appropriate include directory to your build\nconfiguration.\n\n\nThis rule recognizes the following environment variables:\n\nCPATH\n,\n\nINCLUDE\n,\n\nLIB\n,\n\nLIBRARY_PATH\n.\n\n\nEnvironment\n\u00a7\n\n\nThe \nenvironment\n, \nenv\n, is a special object that encapsulates information\nabout the system outside of bfg9000. It's used internally for nearly all\nplatform-specific code, but it can also help in \nbuild.bfg\n files when you\nencounter some unavoidable issue with multiplatform compatibility.\n\n\n\n\nNote\n\n\nThis listing doesn't cover \nall\n available functions on the environment,\nsince many are only useful to internal code. However, the most relevant ones\nfor \nbuild.bfg\n files are shown below.\n\n\n\n\nenv.builder(\nlang\n)\n\u00a7\n\n\nReturn the builder used by bfg9000 for a particular language \nlang\n. While\nbuilder objects are primarily suited to bfg's internals, there are still a few\nuseful properties for \nbuild.bfg\n files:\n\n\nbuilder.flavor\n\u00a7\n\n\nThe \"flavor\" of the builder, i.e. the kind of command-line interface it has.\nPossible values are \n'cc'\n and \n'msvc'\n.\n\n\nbuilder.brand\n\u00a7\n\n\nThe brand of the builder, i.e. the commonad name people use for it. Possible\nvalues are \n'gcc'\n, \n'clang'\n, \n'msvc'\n, and \n'unknown'\n.\n\n\nbuilder.compiler\n\u00a7\n\n\nThe compiler used with this builder.\n\n\ncompiler.command\n\u00a7\n\n\nThe command to run when invoking this compiler, e.g. \ng++-4.9\n.\n\n\nbuilder.linker(\nmode\n)\n\u00a7\n\n\nThe linker used with this builder. \nmode\n is one of \n'executable'\n,\n\n'shared_library'\n, or \n'static_library'\n. Its public properties are the same as\n\ncompiler\n above.\n\n\nenv.platform\n\u00a7\n\n\nReturn the target platform used for the build (currently the same as the host\nplatform).\n\n\nplatform.flavor\n\u00a7\n\n\nThe \"flavor\" of the platform. Either \n'posix'\n or \n'windows'\n.\n\n\nplatform.name\n\u00a7\n\n\nThe name of the platform, e.g. \n'linux'\n, \n'darwin'\n (OS X), or \n'windows'\n.\n\n\nMiscellaneous\n\u00a7\n\n\nbfg9000_required_version([\nversion\n], [\npython_version\n])\n\u00a7\n\n\nSet the required \nversion\n for bfg9000 and/or the required \npython_version\n.\nEach of these is a standard Python \nversion\nspecifier\n.\n\n\nbfg9000_version\n\u00a7\n\n\nReturn the current version of bfg9000. This can be useful if you want to\noptionally support a feature only available in certain versions of bfg.\n\n\nfilter_by_platform(\nname\n, \npath\n, \ntype\n)\n\u00a7\n\n\nReturn \nFindResult.include\n if \npath\n is a filename that should be included for\nthe target platform, and \nFindResult.not_now\n otherwise. File (or directory)\nnames like \nPLATFORM\n or \nfoo_PLATFORM.cpp\n are excluded if \nPLATFORM\n is a\nknown platform name that \ndoesn't\n match the target platform. Known platform\nnames are: \n'posix'\n,\n'linux'\n, \n'darwin'\n, \n'cygwin'\n, \n'windows'\n.\n\n\nThis is the default \nfilter\n for \nfind_files\n.\n\n\nFindResult\n\u00a7\n\n\nAn enum to be used as the result of a filter function for\n\nfind_files\n. The possible enum values are:\n\n\n\n\ninclude\n: Include this file in the results\n\n\nexclude\n: Don't include this file in the results\n\n\nnot_now\n: Don't include this file in the results, but do include it in the\n  \nsource distribution\n\n\n\n\nfind_files([\npath\n], [\nname\n], [\ntype\n], [\nextra\n], [\nexclude\n], [\nflat\n], [\nfilter\n], [\ncache\n], [\ndist\n], [\nas_object\n])\n\u00a7\n\n\nFind files in \npath\n whose name matches the glob (or list of globs) \nname\n. The\nfollowing arguments may be specified:\n\n\n\n\npath\n: A path (or list of paths) to start the search in; if omitted, search\n  in the root of the source directory (\n'.'\n)\n\n\nname\n: A glob (or list of globs) to match files; if omitted, all files match\n  (equivalent to \n'*'\n)\n\n\ntype\n: A filter for the type of file: \n'f'\n to find only files,\n'd'\n to find\n  only directories, or \n'*'\n to find either\n\n\nextra\n: A glob (or list of globs) to match extra files (which will not be\n  returned from \nfind_files\n but will be added to the\n  \nsource distribution\n)\n\n\nexclude\n: A glob (or list of globs) of files to exclude from results; by\n  default, \n.#*\n, \n*~\n, and \n#*#\n are exluded\n\n\nflat\n: If true, \nfind_files\n will not recurse into subdirectories; otherwise,\n  (the default) it will\n\n\nfilter\n: A predicate taking a filename, relative path, and file type, and\n  returning a \nFindResult\n which will filter the results; by\n  default, this is \nfilter_by_platform\n\n\ncache\n: If true (the default), cache the results so that any changes to will\n  regenerate the build scripts for the project\n\n\ndist\n: If true (the default), all files found by this function will\n  automatically be added to the source distribution\n\n\nas_object\n: If true, results will be returned as file or directory objects;\n  otherwise (the default), return path strings\n\n\n\n\nThe \ncache\n argument is particularly important. It allows you to add or remove\nsource files and not have to worry about manually rerunning bfg9000.\n\n\nproject(\nname\n, [\nversion\n])\n\u00a7\n\n\nSet the name (and optionally the version) of the project. If you don't call\nthis function to specify a project name, it defaults to the name of the\nproject's source directory. This is primarily useful for creating \nsource\ndistributions\n.", 
            "title": "Reference"
        }, 
        {
            "location": "/user/reference/#reference", 
            "text": "", 
            "title": "Reference"
        }, 
        {
            "location": "/user/reference/#file-types", 
            "text": "Files used in a  build.bfg  script are divided by their types (e.g. source\ncode, header files, etc). All files from the source directory which are\nreferenced in the  build.bfg  script will automatically be added to the source\ndistribution when it's built.  In most cases, you can simply pass a string to functions expecting a file type;\nthe string will automatically be converted to a file object of the appropriate\ntype. However, in some cases, you may wish to explicitly create a file object.\nThis can be useful, for instance, when running commands that take a source file\nas an argument, e.g. in the following snippet:  command('script', cmd=['python', source_file('script.py')])  Using  source_file  here allows you to specify that the\nfile is found in the  source directory , rather than the build directory.", 
            "title": "File types"
        }, 
        {
            "location": "/user/reference/#directory", 
            "text": "Create a reference to an existing directory named  name . This allows you to\nrefer to an arbitrary subfolder of your source directory. The arguments include ,  exclude , and  filter  are as per  find_files . Any\nmatching files will be added to the project's  source\ndistribution .", 
            "title": "directory(name, [include], [exclude], [filter])"
        }, 
        {
            "location": "/user/reference/#extra_dist", 
            "text": "Add extra  files  and  dirs  to the list of recognized source files. This lets\nyou reference files that are part of the source distribution but which have no\nimpact on the build proper (e.g. READMEs).", 
            "title": "extra_dist([files], [dirs])"
        }, 
        {
            "location": "/user/reference/#generic_file", 
            "text": "Create a reference to an existing file named  name .", 
            "title": "generic_file(name)"
        }, 
        {
            "location": "/user/reference/#header_directory", 
            "text": "Create a reference to a directory named  name  containing header files for the\nproject. This can then be used in the  include  argument when compiling  a source file. The arguments  include ,  exclude , and filter  are as per  find_files . Any matching files will be\nadded to the project's  source\ndistribution .  If  system  is  True , this directory will be treated as a system directory  for\ncompilers that support this.", 
            "title": "header_directory(name, [include], [exclude], [filter], [system])"
        }, 
        {
            "location": "/user/reference/#header_file", 
            "text": "Create a reference to an existing header named  name . This is useful if you'd\nlike to  install  a single header file for your project.", 
            "title": "header_file(name)"
        }, 
        {
            "location": "/user/reference/#source_file", 
            "text": "Create a reference to an existing source file named  name . If  lang  is not\nspecified, the language of the file is inferred from its extension.", 
            "title": "source_file(name, [lang])"
        }, 
        {
            "location": "/user/reference/#build-steps", 
            "text": "Build steps define rules to create an output (usually a file) from zero or more\ninputs (also usually files). As you may expect, if the output doesn't exist, the\nstep is run to generate it. Each input is a dependency on the output, and any\nchanges to an input will result in a rebuild. This includes headers  #include d\nby any of the source files, but does  not  include files external to the project\n(i.e.  packages ).  In addition, all build steps have the ability to define extra dependencies via\nthe  extra_deps  argument. These can be files or other build steps, and changes\nto them will trigger a rebuild as with the build's inputs.  Finally, build steps which produce a file can also be used like the file types  described above to refer to prebuilt files already in\nthe source tree (e.g. static libraries provided in binary form by a\nvendor). This is described in more detail for each step below.   Note  For build steps which produce a file, the exact name of the output file is\ndetermined by the platform you're running on. For instance, when building an\nexecutable file named \"foo\" on Windows, the resulting file will be foo.exe .", 
            "title": "Build steps"
        }, 
        {
            "location": "/user/reference/#build_step", 
            "text": "Create a custom build step that produces a file named  name  by running an\narbitrary command ( cmd  or  cmds ).  name  may either be a single file name or\na list of file names. For a description of the arguments  cmd ,  cmds , and environment , see  command  below.  By default, this function return a  source_file ; you can adjust\nthis with the  type  argument. This should be either 1) a function returning a\nfile object, or 2) an object with a  .type  attribute that meets the criteria of\n(1). You can also pass  args  and  kwargs  to forward arguments along to this\nfunction.", 
            "title": "build_step(name, cmd|cmds, [environment], [type], [args], [kwargs], [extra_deps])"
        }, 
        {
            "location": "/user/reference/#command", 
            "text": "Create a build step named  name  that runs a list of arbitrary commands,\nspecified in either  cmd  or  cmds ;  cmd  takes a single command, whereas cmds  takes a list of commands. Each command may either be a string to be\nparsed according to shell rules or a list of arguments to be passed directly to\nthe process.  You may also pass a dict to  environment  to set environment variables for the\ncommands. These override any environment variables set on the command line.", 
            "title": "command(name, cmd|cmds, [environment], [extra_deps])"
        }, 
        {
            "location": "/user/reference/#executable", 
            "text": "Create a build step that builds an executable file named  name .  files  is the\nlist of source (or object) files to link. If an element of  files  is a source\nfile (or a plain string), this function will implicitly call object_file  on it.  The following arguments may also be specified:   include : Forwarded on to  object_file  pch : Forwarded on to  object_file  libs : A list of library files (see  shared_library  and  static_library )  packages : A list of external  packages ; also forwarded on\n  to  object_file  compile_options : Forwarded on to\n   object_file  as  options  link_options : Command-line options to pass to the linker  lang : Forwarded on to  object_file   If neither  files  nor  libs  is specified, this function merely references an existing  executable file (a precompiled binary, a shell script, etc) somewhere\non the filesystem. In this case,  name  is the exact name of the file, relative\nto the source directory. This allows you to refer to existing executables for\nother functions. In addition, the following arguments may be specified:   format : The object format of the exectuable; by default, this is the\n  platform's native object format (e.g.  'elf'  on Linux)   This build step recognizes the  dynamic linking environment\nvariables  and the  compiler environment\nvariable  (e.g.  CC ) for the\nrelevant language.", 
            "title": "executable(name, [files, ..., [extra_deps]])"
        }, 
        {
            "location": "/user/reference/#object_file", 
            "text": "Create a build step that compiles a source file named  file  to an object file\nnamed  name ; if  name  is not specified, it takes the file name in  file \nwithout the extension.  The following arguments may also be specified:   include : A list of  directories  to search for header\n  files; you may also pass  header files , and their directories will\n  be added to the search list  pch : A  precompiled header  to use during compilation  packages : A list of external  packages  options : Command-line options to pass to the compiler  lang : The language of the source file; useful if the source file's extension\n  isn't recognized by bfg9000   If  file  isn't specified, this function merely references an  existing \nobject file somewhere on the filesystem. In this case,  name  must be specified\nand is the exact name of the file, relative to the source directory. In\naddition, the following arguments may be specified:   format : The object format of the file; by default, this is the platform's\n  native object format (e.g.  'elf'  on Linux)  lang : The source language of the file; if none is specified, defaults to\n   'c'   This build step recognizes the  compilation environment\nvariables  for the relevant language.", 
            "title": "object_file([name], [file, ..., [extra_deps]])"
        }, 
        {
            "location": "/user/reference/#object_files", 
            "text": "Create a compilation build step for each of the files in  files ; this is\nequivalent to calling  object_file  for each element in  files .  In addition,  object_files  returns a special list that allows you to index into\nit using the filename of one of the source files listed in  files . This makes\nit easy to extract a single object file to use in other places, e.g. test code.\nFor example:  objs = object_files(['foo.cpp', 'bar.cpp'])\nrelease_exe = executable('release', objs)\n\nfoo_obj = objs['foo.cpp']\ntest_exe = executable('test', ['test.cpp', foo_obj])", 
            "title": "object_files(files, ..., [extra_deps])"
        }, 
        {
            "location": "/user/reference/#precompiled_header", 
            "text": "Create a build step that generates a precompiled header, which can be used to\nspeed up the compilation of  object files . If  name  is not\nspecified, it is inferred from the value of  file ; the exact name varies based\non the compiler being used, but typically looks like  header.hpp.pch  for\ncc-like compilers and  header.pch  for MSVC-like compilers.  The arguments for  precompiled_header  are the same as for object_file , with the following additional argument:   pch_source : The source file to be used when building the precompiled\n  header. If this is not specified, a source file will automatically be created,\n  containing nothing but  #include \"header\" , where  header  is the name of the\n  header specified in  file . This option only applies to MSVC-like compilers;\n  for all others, it is ignored.   If  file  isn't specified, this function merely references an  existing \nprecompiled header somewhere on the filesystem. In this case,  name  must be\nspecified and is the exact name of the file, relative to the source directory.\nIn addition, the following argument may be specified:   lang : The source language of the file; if none is specified, defaults to\n   'c'    Warning  The exact behavior of precompiled headers varies according to the compiler\nyou're using. In  GCC  and  Clang , the header to be\nprecompiled must be the  first  file  #include d in each source file. In MSVC , the resulting precompiled header is actually compiled\nwithin the context of a particular source file and will contain all the\ncode  up to and including  the header in question.", 
            "title": "precompiled_header([name], [file, ..., [extra_deps]])"
        }, 
        {
            "location": "/user/reference/#shared_library", 
            "text": "Create a build step that builds a shared library named  name . Its arguments are\nthe same as  executable , with the following additional argument:   version : The version number of the library, e.g.  1.2.3 .  soversion : The API version of the library (used in its soname), e.g.  1 .   Like with  executable , if  files  isn't specified, this function merely\nreferences an  existing  shared library somewhere on the filesystem. In this\ncase,  name  must be specified and is the exact name of the file, relative to\nthe source directory. You may also pass in the  format  argument as with executable .  This build step recognizes the  dynamic linking environment\nvariables  and the  compiler environment\nvariable  (e.g.  CC ) for the\nrelevant language.   Note  On Windows, this produces  two  files for native-runtime languages (e.g. C\nor C++):  name.dll  and  name.lib . The latter is the  import library , used\nwhen linking to this library. As a result,  my_lib.all  returns a list\ncontaining  two  files.  Additionally for native languages on Windows, this step will add a\npreprocessor macro named  LIB NAME _EXPORTS  that can be used for declaring\npublic symbols. See  Building libraries on\nWindows  for an example of how to\nuse this macro in your code.", 
            "title": "shared_library(name, [files, ..., [extra_deps]])"
        }, 
        {
            "location": "/user/reference/#static_library", 
            "text": "Create a build step that builds a static library named  name . Its arguments are\nthe same as  executable . Link-related arguments ( link_options , libs , and libraries from  packages ) have no direct effect on this build\nstep. Instead, they're cached and forwarded on to any dynamic linking step that\nuses this static library.  Like with  executable , if  files  isn't specified, this function merely\nreferences an  existing  shared library somewhere on the filesystem. In this\ncase,  name  must be specified and is the exact name of the file, relative to\nthe source directory. In addition, the following arguments may be specified:   format : The object format of the exectuable; by default, this is the\n  platform's native object format (e.g.  'elf'  on Linux)  lang : The source language(s) of the library; if none is specified, defaults\n  to  ['c']   This build step recognizes the  static linking environment\nvariables .   Note  On Windows, this step will add a preprocessor macro on Windows named LIB NAME _STATIC  that can be used for declaring public symbols. See Building libraries on Windows \nfor an example of how to use this macro in your code.", 
            "title": "static_library(name, [files, ..., [extra_deps]])"
        }, 
        {
            "location": "/user/reference/#whole_archive", 
            "text": "Create a build step that builds a  whole-archive \nnamed  name . Whole archives ensures that  every  object file in the library is\nincluded, rather than just the ones whose symbols are referenced. This is\ntypically used to turn a static library into a shared library.  whole_archive 's arguments are the same as for static_library . In addition, you can pass an existing\nstatic library to  whole_archive  to convert it into a whole archive.   Warning  The MSVC linker doesn't have a way of expressing the required directives, so whole_archive  can't be used with it.", 
            "title": "whole_archive(name, [files, ..., [extra_deps]])"
        }, 
        {
            "location": "/user/reference/#grouping-rules", 
            "text": "", 
            "title": "Grouping rules"
        }, 
        {
            "location": "/user/reference/#alias", 
            "text": "Create a build step named  name  that performs no actions on its own. Instead,\nit just runs its dependencies listed in  deps  as necessary. This build step is\nuseful for grouping common steps together.", 
            "title": "alias(name, [deps])"
        }, 
        {
            "location": "/user/reference/#default", 
            "text": "Specify a list of build steps that should be run by default when building. These\nare all accumulated into the  all  target. If  default  is never called, all\nexecutables and libraries  not  passed to  test  will be built by\ndefault.", 
            "title": "default(...)"
        }, 
        {
            "location": "/user/reference/#install", 
            "text": "Specify a list of files that need to be installed for the project to work. Each\nwill be installed to the appropriate location based on its type, e.g. header\nfiles will go in  $PREFIX/include  by default on POSIX systems. These are all\naccumulated into the  install  target. If there are any runtime dependencies for\na file (such as shared libraries you just built), they will be installed as\nwell.   Note  When explicitly listing a target,  all  the files for that target will be\ninstalled. For instance, on Windows, this means that passing in a shared\nlibrary will install the DLL  and  the import library.   This rule recognizes the following environment variables: INSTALL , INSTALL_NAME_TOOL , MKDIR_P , PATCHELF .", 
            "title": "install(...)"
        }, 
        {
            "location": "/user/reference/#global-options", 
            "text": "", 
            "title": "Global options"
        }, 
        {
            "location": "/user/reference/#global_options", 
            "text": "Specify some  options  (either as a string or list) to use for all compilation\nsteps for the language  lang .", 
            "title": "global_options(options, lang)"
        }, 
        {
            "location": "/user/reference/#global_link_options", 
            "text": "Specify some  options  (either as a string or list) to use for all link steps\n(i.e. for  executables  and  shared libraries ).", 
            "title": "global_link_options(options)"
        }, 
        {
            "location": "/user/reference/#test-rules", 
            "text": "These rules help you define automated tests that can all be run via the  test \ntarget. For simple cases, you should only need the  test  rule, but you\ncan also wrap your tests with a separate driver using test_driver .  For cases where you only want to  build  the tests, not run them, you can use\nthe  tests  target.", 
            "title": "Test rules"
        }, 
        {
            "location": "/user/reference/#test", 
            "text": "Create a test for a single test file named  test . You may specify additional\ncommand-line arguments to the test in  options . You can also pass temporary\nenvironment variables as a dict via  environment , or specify a test driver to\nadd this test file to via  driver .", 
            "title": "test(test, [options], [environment|driver])"
        }, 
        {
            "location": "/user/reference/#test_driver", 
            "text": "Create a test driver which can run a series of tests, specified as command-line\narguments to the driver. You may specify driver-wide command-line arguments via options . You can also pass temporary environment variables as a dict with environment , or specify a parent test driver to wrap this driver via  driver .", 
            "title": "test_driver(driver, [options], [environment|parent])"
        }, 
        {
            "location": "/user/reference/#test_deps", 
            "text": "Specify a list of dependencies which must be satisfied before the tests can be\nrun.", 
            "title": "test_deps(...)"
        }, 
        {
            "location": "/user/reference/#package-resolvers", 
            "text": "", 
            "title": "Package resolvers"
        }, 
        {
            "location": "/user/reference/#boost_package", 
            "text": "Search for a  Boost  library. You can specify  name  (as\na string or a list) to specify a specific Boost library (or libraries); for\ninstance,  'program_options' . For header-only libraries, you can omit  name .\nIf  version  is specified, it will ensure that the installed version of Boost\nmeets the version requirement; it must be formatted as a Python  version\nspecifier .  This rule recognizes the following environment variables: BOOST_ROOT , BOOST_INCLUDEDIR , BOOST_LIBRARYDIR , CPATH , INCLUDE , LIB , LIBRARY_PATH .", 
            "title": "boost_package([name], [version])"
        }, 
        {
            "location": "/user/reference/#pkgconfig_package", 
            "text": "Search for a package named  name  via pkg-config . If version  is specified, it will ensure that the installed version of the package\nmeets the version requirement; it must be formatted as a Python  version\nspecifier .  lang \nis the source language of the library ( 'c'  by default); this is useful if you\nneed to link a static library written in C++ with a program written in C.  This rule recognizes the following environment variable: PKG_CONFIG ,", 
            "title": "pkgconfig_package(name, [version], [lang])"
        }, 
        {
            "location": "/user/reference/#system_executable", 
            "text": "Search for an executable named  name  somewhere in the system's PATH.  This rule recognizes the following environment variables: PATH ,  PATHEXT .", 
            "title": "system_executable(name)"
        }, 
        {
            "location": "/user/reference/#system_package", 
            "text": "Search for a library named  name  somewhere in the system's default library\nlocation.  lang  is the source language of the library ( 'c'  by default); this\nis useful if you need to link a static library written in C++ with a program\nwritten in C. You can also specify  kind  to one of  'any'  (the default), 'shared' , or  'static' . This allows you to restrict the search to find only\nstatic versions of a library, for example.  Finally, the  header  argument allows you to specify a header file (or list\nthereof) that you need to use in your source files. This will search for the\nheader file and add the appropriate include directory to your build\nconfiguration.  This rule recognizes the following environment variables: CPATH , INCLUDE , LIB , LIBRARY_PATH .", 
            "title": "system_package(name, [lang], [kind], [header])"
        }, 
        {
            "location": "/user/reference/#environment", 
            "text": "The  environment ,  env , is a special object that encapsulates information\nabout the system outside of bfg9000. It's used internally for nearly all\nplatform-specific code, but it can also help in  build.bfg  files when you\nencounter some unavoidable issue with multiplatform compatibility.   Note  This listing doesn't cover  all  available functions on the environment,\nsince many are only useful to internal code. However, the most relevant ones\nfor  build.bfg  files are shown below.", 
            "title": "Environment"
        }, 
        {
            "location": "/user/reference/#env-builder", 
            "text": "Return the builder used by bfg9000 for a particular language  lang . While\nbuilder objects are primarily suited to bfg's internals, there are still a few\nuseful properties for  build.bfg  files:", 
            "title": "env.builder(lang)"
        }, 
        {
            "location": "/user/reference/#builder-flavor", 
            "text": "The \"flavor\" of the builder, i.e. the kind of command-line interface it has.\nPossible values are  'cc'  and  'msvc' .", 
            "title": "builder.flavor"
        }, 
        {
            "location": "/user/reference/#builder-brand", 
            "text": "The brand of the builder, i.e. the commonad name people use for it. Possible\nvalues are  'gcc' ,  'clang' ,  'msvc' , and  'unknown' .", 
            "title": "builder.brand"
        }, 
        {
            "location": "/user/reference/#builder-compiler", 
            "text": "The compiler used with this builder.", 
            "title": "builder.compiler"
        }, 
        {
            "location": "/user/reference/#compiler-command", 
            "text": "The command to run when invoking this compiler, e.g.  g++-4.9 .", 
            "title": "compiler.command"
        }, 
        {
            "location": "/user/reference/#builder-linker", 
            "text": "The linker used with this builder.  mode  is one of  'executable' , 'shared_library' , or  'static_library' . Its public properties are the same as compiler  above.", 
            "title": "builder.linker(mode)"
        }, 
        {
            "location": "/user/reference/#env-platform", 
            "text": "Return the target platform used for the build (currently the same as the host\nplatform).", 
            "title": "env.platform"
        }, 
        {
            "location": "/user/reference/#platform-flavor", 
            "text": "The \"flavor\" of the platform. Either  'posix'  or  'windows' .", 
            "title": "platform.flavor"
        }, 
        {
            "location": "/user/reference/#platform-name", 
            "text": "The name of the platform, e.g.  'linux' ,  'darwin'  (OS X), or  'windows' .", 
            "title": "platform.name"
        }, 
        {
            "location": "/user/reference/#miscellaneous", 
            "text": "", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/user/reference/#bfg9000_required_version", 
            "text": "Set the required  version  for bfg9000 and/or the required  python_version .\nEach of these is a standard Python  version\nspecifier .", 
            "title": "bfg9000_required_version([version], [python_version])"
        }, 
        {
            "location": "/user/reference/#bfg9000_version", 
            "text": "Return the current version of bfg9000. This can be useful if you want to\noptionally support a feature only available in certain versions of bfg.", 
            "title": "bfg9000_version"
        }, 
        {
            "location": "/user/reference/#filter_by_platform", 
            "text": "Return  FindResult.include  if  path  is a filename that should be included for\nthe target platform, and  FindResult.not_now  otherwise. File (or directory)\nnames like  PLATFORM  or  foo_PLATFORM.cpp  are excluded if  PLATFORM  is a\nknown platform name that  doesn't  match the target platform. Known platform\nnames are:  'posix' , 'linux' ,  'darwin' ,  'cygwin' ,  'windows' .  This is the default  filter  for  find_files .", 
            "title": "filter_by_platform(name, path, type)"
        }, 
        {
            "location": "/user/reference/#findresult", 
            "text": "An enum to be used as the result of a filter function for find_files . The possible enum values are:   include : Include this file in the results  exclude : Don't include this file in the results  not_now : Don't include this file in the results, but do include it in the\n   source distribution", 
            "title": "FindResult"
        }, 
        {
            "location": "/user/reference/#find_files", 
            "text": "Find files in  path  whose name matches the glob (or list of globs)  name . The\nfollowing arguments may be specified:   path : A path (or list of paths) to start the search in; if omitted, search\n  in the root of the source directory ( '.' )  name : A glob (or list of globs) to match files; if omitted, all files match\n  (equivalent to  '*' )  type : A filter for the type of file:  'f'  to find only files, 'd'  to find\n  only directories, or  '*'  to find either  extra : A glob (or list of globs) to match extra files (which will not be\n  returned from  find_files  but will be added to the\n   source distribution )  exclude : A glob (or list of globs) of files to exclude from results; by\n  default,  .#* ,  *~ , and  #*#  are exluded  flat : If true,  find_files  will not recurse into subdirectories; otherwise,\n  (the default) it will  filter : A predicate taking a filename, relative path, and file type, and\n  returning a  FindResult  which will filter the results; by\n  default, this is  filter_by_platform  cache : If true (the default), cache the results so that any changes to will\n  regenerate the build scripts for the project  dist : If true (the default), all files found by this function will\n  automatically be added to the source distribution  as_object : If true, results will be returned as file or directory objects;\n  otherwise (the default), return path strings   The  cache  argument is particularly important. It allows you to add or remove\nsource files and not have to worry about manually rerunning bfg9000.", 
            "title": "find_files([path], [name], [type], [extra], [exclude], [flat], [filter], [cache], [dist], [as_object])"
        }, 
        {
            "location": "/user/reference/#project", 
            "text": "Set the name (and optionally the version) of the project. If you don't call\nthis function to specify a project name, it defaults to the name of the\nproject's source directory. This is primarily useful for creating  source\ndistributions .", 
            "title": "project(name, [version])"
        }, 
        {
            "location": "/user/environment-vars/", 
            "text": "Environment Variables\n\u00a7\n\n\nbfg9000 reads from a number of environment variables. These are the primary way\nin which users can customize parts of a specific build, e.g. by changing the\ntools to use or adding compiler flags. Below is a full list of all the\nenvironment variables bfg9000 recognizes.\n\n\nCompilation variables\n\u00a7\n\n\nGeneric\n\u00a7\n\n\n\n\nCPPFLAGS\n\u00a7\n\n\nDefault: \nnone\n\n\n\"C preprocessor flags\"; command line arguments to pass to the compiler when\ncompiling any C-family source file (C, C++, Objective C/C++).\n\n\nC\n\u00a7\n\n\n\n\nCC\n\u00a7\n\n\nDefault: \ncc\n (POSIX), \ncl\n (Windows)\n\n\nThe command to use when compiling C source files. Also the command to use with\ncc-style toolchains when linking object files whose source is in C.\n\n\nCFLAGS\n\u00a7\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the compiler when compiling any C source file.\n\n\nC++\n\u00a7\n\n\n\n\nCXX\n\u00a7\n\n\nDefault: \nc++\n (POSIX), \ncl\n (Windows)\n\n\nThe command to use when compiling C++ source files. Also the command to use with\ncc-style toolchains when linking object files whose source is in C++.\n\n\nCXXFLAGS\n\u00a7\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the compiler when compiling any C++ source\nfile.\n\n\nFortran\n\u00a7\n\n\n\n\nFC\n\u00a7\n\n\nDefault: \ngfortran\n\n\nThe command to use when compiling Fortran source files. Also the command to use\nwhen linking object files whose source is in Fortran.\n\n\nFFLAGS\n\u00a7\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the compiler when compiling any Fortran source\nfile.\n\n\nObjective C\n\u00a7\n\n\n\n\nOBJC\n\u00a7\n\n\nDefault: \ncc\n\n\nThe command to use when compiling Objective C source files. Also the command to\nuse with cc-style toolchains when linking object files whose source is in\nObjective C.\n\n\nOBJCFLAGS\n\u00a7\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the compiler when compiling any Objective C\nsource file.\n\n\nObjective C++\n\u00a7\n\n\n\n\nOBJCXX\n\u00a7\n\n\nDefault: \nc++\n\n\nThe command to use when compiling Objective C++ source files. Also the command\nto use with cc-style toolchains when linking object files whose source is in\nObjective C++.\n\n\nOBJCXXFLAGS\n\u00a7\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the compiler when compiling any Objective C++\nsource file.\n\n\nLinking variables\n\u00a7\n\n\nStatic linking\n\u00a7\n\n\n\n\nAR\n\u00a7\n\n\nDefault: \nar\n\n\nPOSIX-only\n. The command to use when creating static libraries from object\nfiles.\n\n\nARFLAGS\n\u00a7\n\n\nDefault: \ncru\n\n\nPOSIX-only\n. The arguments to pass to the static library builder (typically\n\nar\n).\n\n\nCC_LIB\n\u00a7\n\n\nDefault: \nlib\n\n\nMSVC-only\n. The command to use when creating static libraries whose source\nis in C.\n\n\nCXX_LIB\n\u00a7\n\n\nDefault: \nlib\n\n\nMSVC-only\n. The command to use when creating static libraries whose source\nis in C++.\n\n\nLIBFLAGS\n\u00a7\n\n\nDefault: \nnone\n\n\nWindows-only\n. Command line arguments to pass to the static library builder\n(typically \nlib\n).\n\n\nDynamic linking\n\u00a7\n\n\n\n\nCC_LINK\n\u00a7\n\n\nDefault: \nlink\n\n\nMSVC-only\n. The command to use when linking shared libraries whose source\nis in C.\n\n\nCXX_LINK\n\u00a7\n\n\nDefault: \nlink\n\n\nMSVC-only\n. The command to use when linking shared libraries whose source\nis in C++.\n\n\nLDFLAGS\n\u00a7\n\n\nDefault: \nnone\n\n\nCommand line arguments to pass to the linker when linking an executable or\nshared library.\n\n\nLDLIBS\n\u00a7\n\n\nDefault: \nnone\n\n\nAdditional libraries to link into an executable or shared library. This is\nmainly useful for cases where a system library (e.g. the C++ Standard Library\nimplementation) requires another library to be explicitly linked with it.\n\n\nPackaging variables\n\u00a7\n\n\n\n\nBOOST_ROOT\n\u00a7\n\n\nDefault: \nnone\n\n\nThe root directory where Boost headers and libraries are stored (as\n\n$BOOST_ROOT/include\n and \n$BOOST_ROOT/lib\n, respectively).\n\n\nBOOST_INCLUDEDIR\n\u00a7\n\n\nDefault: \nnone\n\n\nThe root directory where Boost headers are stored. This takes precedence over\n\nBOOST_ROOT\n.\n\n\nBOOST_LIBRARYDIR\n\u00a7\n\n\nDefault: \nnone\n\n\nThe root directory where Boost libraries are stored. This takes precedence over\n\nBOOST_ROOT\n.\n\n\nCPATH\n\u00a7\n\n\nDefault: \nnone\n\n\nA list of additional directories to search for headers. On POSIX systems, this\nis delimited by \n:\n; on Windows, by \n;\n.\n\n\nINCLUDE\n\u00a7\n\n\nDefault: \nnone\n\n\nMSVC-only\n. A list of directories to search for headers, delimited by \n;\n.\n\n\nLIB\n\u00a7\n\n\nDefault: \nnone\n\n\nMSVC-only\n. A list of directories to search for \nsystem\nlibraries\n, delimited by \n;\n.\n\n\nLIBRARY_PATH\n\u00a7\n\n\nDefault: \nnone\n\n\nA list of additional directories to search for \nsystem\nlibraries\n. On POSIX systems, this is delimited by\n\n:\n; on Windows, by \n;\n.\n\n\nPATH\n\u00a7\n\n\nDefault: \nnone\n\n\nA list of directories to search for \nsystem\nexecutables\n. On POSIX systems, this is\ndelimited by \n:\n; on Windows, by \n;\n.\n\n\nPATHEXT\n\u00a7\n\n\nDefault: \nnone\n\n\nWindows-only\n. A list of valid extensions for executable files under Windows,\nseparated by \n;\n.\n\n\nPKG_CONFIG\n\u00a7\n\n\nDefault: \npkg_config\n\n\nThe command to use when fetching pkg-config package information.\n\n\nCommand variables\n\u00a7\n\n\n\n\nBFG9000\n\u00a7\n\n\nDefault: \n/path/to/bfg9000\n\n\nThe command to use when executing bfg9000 (e.g. when regenerating the build\nscripts because the list of source files has changed). This should only be\nnecessary if you run bfg9000 from a wrapper script.\n\n\nDEPFIXER\n\u00a7\n\n\nDefault: \n/path/to/bfg9000-depfixer\n\n\nThe command to use when fixing up depfiles generated by your compiler for the\nMake backend. In general, you shouldn't need to touch this.\n\n\nDOPPEL\n\u00a7\n\n\nDefault: \ndoppel\n\n\nThe command to use when installing files and building source distributions. For\nmore information about doppel, see its\n\ndocumentation\n.\n\n\nINSTALL_NAME_TOOL\n\u00a7\n\n\nDefault: \ninstall_name_tool\n\n\nDarwin-only\n. The command to use when modifying the paths of the shared\nlibraries linked to during installation.\n\n\nMKDIR_P\n\u00a7\n\n\nDefault: \nmkdir -p\n\n\nThe command to use when making a directory tree. This is used both for\ninstalling whole directories of files and for creating build directories under\nthe Make backend.\n\n\nPATCHELF\n\u00a7\n\n\nDefault: \npatchelf\n\n\nLinux-only\n. The command to use when patching an ELF file's rpath for\ninstallation.\n\n\nPRINTF\n\u00a7\n\n\nDefault: \nprintf\n or \n/path/to/bfg9000-printf\n\n\nThe command to use when printing formatted strings during the build process\n(used when writing generated files).\n\n\nSETENV\n\u00a7\n\n\nDefault: \n/path/to/bfg9000-setenv\n\n\nWindows-only\n. The command to use when setting temporary environment variables,\nsimilar to the POSIX \nenv\n command. This is used when setting environment\nvariables for tests.\n\n\nSystem variables\n\u00a7\n\n\n\n\nPLATFORM\n\u00a7\n\n\nDefault: \nWin32\n\n\nWindows-only\n. The platform type to use when generating MSBuild files.\n\n\nVISUALSTUDIOVERSION\n\u00a7\n\n\nDefault: \n14.0\n\n\nWindows-only\n. The version of Visual Studio to target when generating MSBuild\nfiles.", 
            "title": "Environment Variables"
        }, 
        {
            "location": "/user/environment-vars/#environment-variables", 
            "text": "bfg9000 reads from a number of environment variables. These are the primary way\nin which users can customize parts of a specific build, e.g. by changing the\ntools to use or adding compiler flags. Below is a full list of all the\nenvironment variables bfg9000 recognizes.", 
            "title": "Environment Variables"
        }, 
        {
            "location": "/user/environment-vars/#compilation-variables", 
            "text": "", 
            "title": "Compilation variables"
        }, 
        {
            "location": "/user/environment-vars/#generic", 
            "text": "", 
            "title": "Generic"
        }, 
        {
            "location": "/user/environment-vars/#cppflags", 
            "text": "Default:  none  \"C preprocessor flags\"; command line arguments to pass to the compiler when\ncompiling any C-family source file (C, C++, Objective C/C++).", 
            "title": "CPPFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#c", 
            "text": "", 
            "title": "C"
        }, 
        {
            "location": "/user/environment-vars/#cc", 
            "text": "Default:  cc  (POSIX),  cl  (Windows)  The command to use when compiling C source files. Also the command to use with\ncc-style toolchains when linking object files whose source is in C.", 
            "title": "CC"
        }, 
        {
            "location": "/user/environment-vars/#cflags", 
            "text": "Default:  none  Command line arguments to pass to the compiler when compiling any C source file.", 
            "title": "CFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#c_1", 
            "text": "", 
            "title": "C++"
        }, 
        {
            "location": "/user/environment-vars/#cxx", 
            "text": "Default:  c++  (POSIX),  cl  (Windows)  The command to use when compiling C++ source files. Also the command to use with\ncc-style toolchains when linking object files whose source is in C++.", 
            "title": "CXX"
        }, 
        {
            "location": "/user/environment-vars/#cxxflags", 
            "text": "Default:  none  Command line arguments to pass to the compiler when compiling any C++ source\nfile.", 
            "title": "CXXFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#fortran", 
            "text": "", 
            "title": "Fortran"
        }, 
        {
            "location": "/user/environment-vars/#fc", 
            "text": "Default:  gfortran  The command to use when compiling Fortran source files. Also the command to use\nwhen linking object files whose source is in Fortran.", 
            "title": "FC"
        }, 
        {
            "location": "/user/environment-vars/#fflags", 
            "text": "Default:  none  Command line arguments to pass to the compiler when compiling any Fortran source\nfile.", 
            "title": "FFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#objective-c", 
            "text": "", 
            "title": "Objective C"
        }, 
        {
            "location": "/user/environment-vars/#objc", 
            "text": "Default:  cc  The command to use when compiling Objective C source files. Also the command to\nuse with cc-style toolchains when linking object files whose source is in\nObjective C.", 
            "title": "OBJC"
        }, 
        {
            "location": "/user/environment-vars/#objcflags", 
            "text": "Default:  none  Command line arguments to pass to the compiler when compiling any Objective C\nsource file.", 
            "title": "OBJCFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#objective-c_1", 
            "text": "", 
            "title": "Objective C++"
        }, 
        {
            "location": "/user/environment-vars/#objcxx", 
            "text": "Default:  c++  The command to use when compiling Objective C++ source files. Also the command\nto use with cc-style toolchains when linking object files whose source is in\nObjective C++.", 
            "title": "OBJCXX"
        }, 
        {
            "location": "/user/environment-vars/#objcxxflags", 
            "text": "Default:  none  Command line arguments to pass to the compiler when compiling any Objective C++\nsource file.", 
            "title": "OBJCXXFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#linking-variables", 
            "text": "", 
            "title": "Linking variables"
        }, 
        {
            "location": "/user/environment-vars/#static-linking", 
            "text": "", 
            "title": "Static linking"
        }, 
        {
            "location": "/user/environment-vars/#ar", 
            "text": "Default:  ar  POSIX-only . The command to use when creating static libraries from object\nfiles.", 
            "title": "AR"
        }, 
        {
            "location": "/user/environment-vars/#arflags", 
            "text": "Default:  cru  POSIX-only . The arguments to pass to the static library builder (typically ar ).", 
            "title": "ARFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#cc_lib", 
            "text": "Default:  lib  MSVC-only . The command to use when creating static libraries whose source\nis in C.", 
            "title": "CC_LIB"
        }, 
        {
            "location": "/user/environment-vars/#cxx_lib", 
            "text": "Default:  lib  MSVC-only . The command to use when creating static libraries whose source\nis in C++.", 
            "title": "CXX_LIB"
        }, 
        {
            "location": "/user/environment-vars/#libflags", 
            "text": "Default:  none  Windows-only . Command line arguments to pass to the static library builder\n(typically  lib ).", 
            "title": "LIBFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#dynamic-linking", 
            "text": "", 
            "title": "Dynamic linking"
        }, 
        {
            "location": "/user/environment-vars/#cc_link", 
            "text": "Default:  link  MSVC-only . The command to use when linking shared libraries whose source\nis in C.", 
            "title": "CC_LINK"
        }, 
        {
            "location": "/user/environment-vars/#cxx_link", 
            "text": "Default:  link  MSVC-only . The command to use when linking shared libraries whose source\nis in C++.", 
            "title": "CXX_LINK"
        }, 
        {
            "location": "/user/environment-vars/#ldflags", 
            "text": "Default:  none  Command line arguments to pass to the linker when linking an executable or\nshared library.", 
            "title": "LDFLAGS"
        }, 
        {
            "location": "/user/environment-vars/#ldlibs", 
            "text": "Default:  none  Additional libraries to link into an executable or shared library. This is\nmainly useful for cases where a system library (e.g. the C++ Standard Library\nimplementation) requires another library to be explicitly linked with it.", 
            "title": "LDLIBS"
        }, 
        {
            "location": "/user/environment-vars/#packaging-variables", 
            "text": "", 
            "title": "Packaging variables"
        }, 
        {
            "location": "/user/environment-vars/#boost_root", 
            "text": "Default:  none  The root directory where Boost headers and libraries are stored (as $BOOST_ROOT/include  and  $BOOST_ROOT/lib , respectively).", 
            "title": "BOOST_ROOT"
        }, 
        {
            "location": "/user/environment-vars/#boost_includedir", 
            "text": "Default:  none  The root directory where Boost headers are stored. This takes precedence over BOOST_ROOT .", 
            "title": "BOOST_INCLUDEDIR"
        }, 
        {
            "location": "/user/environment-vars/#boost_librarydir", 
            "text": "Default:  none  The root directory where Boost libraries are stored. This takes precedence over BOOST_ROOT .", 
            "title": "BOOST_LIBRARYDIR"
        }, 
        {
            "location": "/user/environment-vars/#cpath", 
            "text": "Default:  none  A list of additional directories to search for headers. On POSIX systems, this\nis delimited by  : ; on Windows, by  ; .", 
            "title": "CPATH"
        }, 
        {
            "location": "/user/environment-vars/#include", 
            "text": "Default:  none  MSVC-only . A list of directories to search for headers, delimited by  ; .", 
            "title": "INCLUDE"
        }, 
        {
            "location": "/user/environment-vars/#lib", 
            "text": "Default:  none  MSVC-only . A list of directories to search for  system\nlibraries , delimited by  ; .", 
            "title": "LIB"
        }, 
        {
            "location": "/user/environment-vars/#library_path", 
            "text": "Default:  none  A list of additional directories to search for  system\nlibraries . On POSIX systems, this is delimited by : ; on Windows, by  ; .", 
            "title": "LIBRARY_PATH"
        }, 
        {
            "location": "/user/environment-vars/#path", 
            "text": "Default:  none  A list of directories to search for  system\nexecutables . On POSIX systems, this is\ndelimited by  : ; on Windows, by  ; .", 
            "title": "PATH"
        }, 
        {
            "location": "/user/environment-vars/#pathext", 
            "text": "Default:  none  Windows-only . A list of valid extensions for executable files under Windows,\nseparated by  ; .", 
            "title": "PATHEXT"
        }, 
        {
            "location": "/user/environment-vars/#pkg_config", 
            "text": "Default:  pkg_config  The command to use when fetching pkg-config package information.", 
            "title": "PKG_CONFIG"
        }, 
        {
            "location": "/user/environment-vars/#command-variables", 
            "text": "", 
            "title": "Command variables"
        }, 
        {
            "location": "/user/environment-vars/#bfg9000", 
            "text": "Default:  /path/to/bfg9000  The command to use when executing bfg9000 (e.g. when regenerating the build\nscripts because the list of source files has changed). This should only be\nnecessary if you run bfg9000 from a wrapper script.", 
            "title": "BFG9000"
        }, 
        {
            "location": "/user/environment-vars/#depfixer", 
            "text": "Default:  /path/to/bfg9000-depfixer  The command to use when fixing up depfiles generated by your compiler for the\nMake backend. In general, you shouldn't need to touch this.", 
            "title": "DEPFIXER"
        }, 
        {
            "location": "/user/environment-vars/#doppel", 
            "text": "Default:  doppel  The command to use when installing files and building source distributions. For\nmore information about doppel, see its documentation .", 
            "title": "DOPPEL"
        }, 
        {
            "location": "/user/environment-vars/#install_name_tool", 
            "text": "Default:  install_name_tool  Darwin-only . The command to use when modifying the paths of the shared\nlibraries linked to during installation.", 
            "title": "INSTALL_NAME_TOOL"
        }, 
        {
            "location": "/user/environment-vars/#mkdir_p", 
            "text": "Default:  mkdir -p  The command to use when making a directory tree. This is used both for\ninstalling whole directories of files and for creating build directories under\nthe Make backend.", 
            "title": "MKDIR_P"
        }, 
        {
            "location": "/user/environment-vars/#patchelf", 
            "text": "Default:  patchelf  Linux-only . The command to use when patching an ELF file's rpath for\ninstallation.", 
            "title": "PATCHELF"
        }, 
        {
            "location": "/user/environment-vars/#printf", 
            "text": "Default:  printf  or  /path/to/bfg9000-printf  The command to use when printing formatted strings during the build process\n(used when writing generated files).", 
            "title": "PRINTF"
        }, 
        {
            "location": "/user/environment-vars/#setenv", 
            "text": "Default:  /path/to/bfg9000-setenv  Windows-only . The command to use when setting temporary environment variables,\nsimilar to the POSIX  env  command. This is used when setting environment\nvariables for tests.", 
            "title": "SETENV"
        }, 
        {
            "location": "/user/environment-vars/#system-variables", 
            "text": "", 
            "title": "System variables"
        }, 
        {
            "location": "/user/environment-vars/#platform", 
            "text": "Default:  Win32  Windows-only . The platform type to use when generating MSBuild files.", 
            "title": "PLATFORM"
        }, 
        {
            "location": "/user/environment-vars/#visualstudioversion", 
            "text": "Default:  14.0  Windows-only . The version of Visual Studio to target when generating MSBuild\nfiles.", 
            "title": "VISUALSTUDIOVERSION"
        }, 
        {
            "location": "/developer/internals/", 
            "text": "Developer Documentation\n\u00a7\n\n\nAt its core, a build file is just a DAG (directed acyclic graph) that gets\nwalked through by the build system, where the nodes are files and the edges are\nbuild steps. A bfg9000 build file is no different.\n\n\nHow a build.bfg file is compiled\n\u00a7\n\n\nSnapshot the environment\n\u00a7\n\n\nWhen bfg9000 is invoked, it first takes a snapshot of the current environment\n(the operating system, environment variables, compiler to use, etc). This is\nimportant to provide a stable state for regeneration of the build file if\nnecessary (e.g. if build.bfg is changed).\n\n\nBuild an internal dependency graph\n\u00a7\n\n\nNext, it executes the build.bfg file. Most bfg9000 functions represent build\nsteps or other related parts of the dependency graph. When called, these build\nup an internal DAG structure with all the backend-agnostic data filled in (e.g.\nvirtual filenames are resolved to real ones, such as \"foo\" to \"libfoo.so\").\n\n\nEmit the final build file\n\u00a7\n\n\nOnce this is complete, the DAG is passed to the appropriate backend, which\niterates over all the known edges (build steps) and emits the backend-specific\ncode for them. Since all the backends handle walking the DAG on their own,\nbfg9000 can safely avoid worrying about trying to do this efficiently in Python.", 
            "title": "Internals"
        }, 
        {
            "location": "/developer/internals/#developer-documentation", 
            "text": "At its core, a build file is just a DAG (directed acyclic graph) that gets\nwalked through by the build system, where the nodes are files and the edges are\nbuild steps. A bfg9000 build file is no different.", 
            "title": "Developer Documentation"
        }, 
        {
            "location": "/developer/internals/#how-a-buildbfg-file-is-compiled", 
            "text": "", 
            "title": "How a build.bfg file is compiled"
        }, 
        {
            "location": "/developer/internals/#snapshot-the-environment", 
            "text": "When bfg9000 is invoked, it first takes a snapshot of the current environment\n(the operating system, environment variables, compiler to use, etc). This is\nimportant to provide a stable state for regeneration of the build file if\nnecessary (e.g. if build.bfg is changed).", 
            "title": "Snapshot the environment"
        }, 
        {
            "location": "/developer/internals/#build-an-internal-dependency-graph", 
            "text": "Next, it executes the build.bfg file. Most bfg9000 functions represent build\nsteps or other related parts of the dependency graph. When called, these build\nup an internal DAG structure with all the backend-agnostic data filled in (e.g.\nvirtual filenames are resolved to real ones, such as \"foo\" to \"libfoo.so\").", 
            "title": "Build an internal dependency graph"
        }, 
        {
            "location": "/developer/internals/#emit-the-final-build-file", 
            "text": "Once this is complete, the DAG is passed to the appropriate backend, which\niterates over all the known edges (build steps) and emits the backend-specific\ncode for them. Since all the backends handle walking the DAG on their own,\nbfg9000 can safely avoid worrying about trying to do this efficiently in Python.", 
            "title": "Emit the final build file"
        }, 
        {
            "location": "/developer/contributing/", 
            "text": "Contributing\n\u00a7\n\n\nSo, you'd like to help improve bfg9000 by writing a patch? Great! This page will\nprovide you with some useful information to help you get started.\n\n\nRunning tests\n\u00a7\n\n\nbfg9000 has a suite of tests to ensure that everything works properly. (Well,\neverything that has tests!) As you may expect, you can run these via:\n\n\n$ python setup.py test\n\n\n\n\nIf you'd like to run a subset of tests, such as when trying to fix a bug in a\nspecific area of the code, you can limit the tests that get run. For instance,\nto run only the tests in \ntest/integration/test_simple.py\n, you can type:\n\n\n$ python setup.py test -s test.integration.test_simple\n\n\n\n\nLinting code\n\u00a7\n\n\nbfg9000 uses \nflake8\n for linting.\nSince users generally don't need to worry about linting the codebase, this isn't\nautomatically installed by setup.py. You'll need to install it yourself. Once\ninstalled, you can use the \nlint\n command like so:\n\n\n$ python setup.py lint", 
            "title": "Contributing"
        }, 
        {
            "location": "/developer/contributing/#contributing", 
            "text": "So, you'd like to help improve bfg9000 by writing a patch? Great! This page will\nprovide you with some useful information to help you get started.", 
            "title": "Contributing"
        }, 
        {
            "location": "/developer/contributing/#running-tests", 
            "text": "bfg9000 has a suite of tests to ensure that everything works properly. (Well,\neverything that has tests!) As you may expect, you can run these via:  $ python setup.py test  If you'd like to run a subset of tests, such as when trying to fix a bug in a\nspecific area of the code, you can limit the tests that get run. For instance,\nto run only the tests in  test/integration/test_simple.py , you can type:  $ python setup.py test -s test.integration.test_simple", 
            "title": "Running tests"
        }, 
        {
            "location": "/developer/contributing/#linting-code", 
            "text": "bfg9000 uses  flake8  for linting.\nSince users generally don't need to worry about linting the codebase, this isn't\nautomatically installed by setup.py. You'll need to install it yourself. Once\ninstalled, you can use the  lint  command like so:  $ python setup.py lint", 
            "title": "Linting code"
        }, 
        {
            "location": "/about/changes/", 
            "text": "Changes\n\u00a7\n\n\nv0.3.0\n\u00a7\n\n\nin progress\n\n\nNew features\n\u00a7\n\n\n\n\nAdd \nheader\n argument to \nsystem_package()\n to find header files\n\n\n\n\n\n\nv0.2.0\n\u00a7\n\n\n2016-06-26\n\n\nNew features\n\u00a7\n\n\n\n\nSupport Objective C/C++\n\n\nPartially support Fortran (simple projects work, but more complex things\n  probably don't)\n\n\nImproved error reporting\n\n\nWarn users if necessary build tools can't be found by bfg9000\n\n\nAutomatically include runtime dependencies when installing a binary\n\n\nSupport \n@rpath\n on OS X\n\n\nAllow fetching bfg's version from \nbuild.bfg\n files via \nbfg9000_version\n\n\nSupport versioning of shared libraries on POSIX systems\n\n\nSupport resolving packages via pkg-config\n\n\nLocally-built static libraries now forward their options to binaries that link\n  to them\n\n\nwhole_archive\n now forwards its arguments on to \nstatic_library\n\n\nUse \ndoppel\n for installing files instead of \ninstall(1)\n\n\nSupport \ncommand\n and \nalias\n rules under MSBuild\n\n\nAdd support for building a distribution of the sources (\nmake dist\n)\n\n\nAllow running custom build steps via \nbuild_step()\n\n\n\n\nBreaking changes\n\u00a7\n\n\n\n\nConfiguring a build is now performed by \nbfg9000 configure DIRECTORY\n\n\nheader()\n renamed to \nheader_file()\n\n\nenv.compiler(lang)\n replaced by \nenv.builder(lang).compiler\n\n\nenv.linker(lang, mode)\n replaced by \nenv.builder(lang).linker(mode)\n\n\nenv.compiler(lang).flavor\n replaced by \nenv.builder(lang).flavor\n\n\n\n\nBug fixes\n\u00a7\n\n\n\n\nFix fetching \nCFLAGS\n from the environment (it used to try \nCCFLAGS\n)\n\n\nFix execution context of \nbuild.bfg\n files; this caused strange issues with\n  list/generator comprehensions\n\n\n\n\n\n\nv0.1.1\n\u00a7\n\n\n2016-01-21\n\n\n\n\nFix an issue with installing the package from PyPI\n\n\n\n\n\n\nv0.1.0\n\u00a7\n\n\n2016-01-20\n\n\n\n\nInitial release\n\n\nSupport for C and C++ builds on Linux, Mac, and Windows (MinGW included) via\n  Make, Ninja, and MSBuild.", 
            "title": "Changes"
        }, 
        {
            "location": "/about/changes/#changes", 
            "text": "", 
            "title": "Changes"
        }, 
        {
            "location": "/about/changes/#v030", 
            "text": "in progress", 
            "title": "v0.3.0"
        }, 
        {
            "location": "/about/changes/#new-features", 
            "text": "Add  header  argument to  system_package()  to find header files", 
            "title": "New features"
        }, 
        {
            "location": "/about/changes/#v020", 
            "text": "2016-06-26", 
            "title": "v0.2.0"
        }, 
        {
            "location": "/about/changes/#new-features_1", 
            "text": "Support Objective C/C++  Partially support Fortran (simple projects work, but more complex things\n  probably don't)  Improved error reporting  Warn users if necessary build tools can't be found by bfg9000  Automatically include runtime dependencies when installing a binary  Support  @rpath  on OS X  Allow fetching bfg's version from  build.bfg  files via  bfg9000_version  Support versioning of shared libraries on POSIX systems  Support resolving packages via pkg-config  Locally-built static libraries now forward their options to binaries that link\n  to them  whole_archive  now forwards its arguments on to  static_library  Use  doppel  for installing files instead of  install(1)  Support  command  and  alias  rules under MSBuild  Add support for building a distribution of the sources ( make dist )  Allow running custom build steps via  build_step()", 
            "title": "New features"
        }, 
        {
            "location": "/about/changes/#breaking-changes", 
            "text": "Configuring a build is now performed by  bfg9000 configure DIRECTORY  header()  renamed to  header_file()  env.compiler(lang)  replaced by  env.builder(lang).compiler  env.linker(lang, mode)  replaced by  env.builder(lang).linker(mode)  env.compiler(lang).flavor  replaced by  env.builder(lang).flavor", 
            "title": "Breaking changes"
        }, 
        {
            "location": "/about/changes/#bug-fixes", 
            "text": "Fix fetching  CFLAGS  from the environment (it used to try  CCFLAGS )  Fix execution context of  build.bfg  files; this caused strange issues with\n  list/generator comprehensions", 
            "title": "Bug fixes"
        }, 
        {
            "location": "/about/changes/#v011", 
            "text": "2016-01-21   Fix an issue with installing the package from PyPI", 
            "title": "v0.1.1"
        }, 
        {
            "location": "/about/changes/#v010", 
            "text": "2016-01-20   Initial release  Support for C and C++ builds on Linux, Mac, and Windows (MinGW included) via\n  Make, Ninja, and MSBuild.", 
            "title": "v0.1.0"
        }, 
        {
            "location": "/about/license/", 
            "text": "License\n\u00a7\n\n\nBSD 3-clause license\n\u00a7\n\n\nCopyright (c) 2015-2016, Jim Porter\nAll rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n\n\n\n\n\nRedistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n\n\n\n\n\nNeither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\n\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", 
            "title": "License"
        }, 
        {
            "location": "/about/license/#license", 
            "text": "", 
            "title": "License"
        }, 
        {
            "location": "/about/license/#bsd-3-clause-license", 
            "text": "Copyright (c) 2015-2016, Jim Porter\nAll rights reserved.  Redistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:    Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.    Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.    Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", 
            "title": "BSD 3-clause license"
        }
    ]
}