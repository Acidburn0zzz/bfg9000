#!/usr/bin/env python
# -*- python -*-

import fnmatch
import os
import os.path
import re
import sys
from collections import OrderedDict
__targets__ = OrderedDict()

def find(base='.', name='*', type=None):
    results = []
    for path, dirs, files in os.walk(base):
        if type != 'f':
            results.extend((
                os.path.join(path, i) for i in fnmatch.filter(dirs, name)
            ))
        if type != 'd':
            results.extend((
                os.path.join(path, i) for i in fnmatch.filter(files, name)
            ))
    return results

class Rule(object):
    def __init__(self, kind, name, deps, attrs):
        self.kind = kind
        self.name = name
        self.deps = deps
        self.attrs = attrs

def rule(fn):
    def wrapped(name, deps=None, **kwargs):
        result = Rule(fn.func_name, name, deps or [], fn(**kwargs))
        if name not in __targets__:
            __targets__[name] = []
        __targets__[name].append(result)
        return result
    return wrapped

__rule_handlers__ = {}
def rule_handler(rule_name):
    def decorator(fn):
        __rule_handlers__[rule_name] = fn
        return fn
    return decorator

def target_name(rule):
    if isinstance(rule, Rule):
        if rule.kind == 'library':
            return 'lib{}.so'.format(rule.name)
        elif rule.kind == 'compile':
            return '{}.o'.format(rule.name)
        else:
            return rule.name
    else:
        return rule

def lib_link_name(rule):
    if isinstance(rule, Rule):
        return rule.name
    else:
        return rule

def write_makefile_rule(out, target, deps, commands, phony=False):
    if phony:
        out.write('.PHONY: {}\n'.format(target))
    out.write('{target}:{deps}\n'.format(
        target=target,
        deps=''.join((' ' +target_name(i) for i in deps))
    ))
    for cmd in commands:
        out.write('\t{}\n'.format(cmd))
    out.write('\n')

def write_makefile(out):
    for i in __targets__.itervalues():
        for rule in i:
            __rule_handlers__[rule.kind](out, rule)

@rule
def compile(file):
    return {'file': file}

def compile_all(files):
    return [compile(os.path.splitext(f)[0], file=f) for f in files]

@rule
def executable(files, libs=None):
    # XXX: Allow pre-built objects?
    return {'files': compile_all(files), 'libs': libs or []}

@rule
def library(files, libs=None):
    # XXX: Allow pre-built objects?
    return {'files': compile_all(files), 'libs': libs or []}

@rule
def target():
    return {'phony': True}

@rule
def command(cmd):
    return {'cmd': cmd, 'phony': True}

def filter_rules(iterable):
    return filter(lambda i: isinstance(i, Rule), iterable)

__seen_compile_rules__ = set()

__var_table__ = set()
def __unique_var_name__(name):
    name = re.sub('/', '_', name)
    if name in __var_table__:
        i = 2
        fmt = name + '_{}'
        while True:
            name = fmt.format(i)
            if name not in __var_table__:
                break
            i += 1
    __var_table__.add(name)
    return name

@rule_handler('compile')
def __emit_compile__(out, rule):
    base, ext = os.path.splitext(rule.attrs['file'])
    if ext not in __seen_compile_rules__:
        __seen_compile_rules__.add(ext)
        write_makefile_rule(
            out,
            '%.o',
            ['%' + ext],
            ["$(eval TEMP := $(shell mktemp $(TMPDIR)/$(notdir $*)-XXXXXX.d))",
             "g++ -MMD -MF $(TEMP) -c $< -o $@",
             "@sed -e 's|.*:|$*.o:|' < $(TEMP) > $*.d",
             "@sed -e 's/.*://' -e 's/\\$$//' < $(TEMP) | fmt -1 | \\",
             "  sed -e 's/^ *//' -e 's/$$/:/' >> $*.d",
             "@rm -f $(TEMP)"]
        )
    out.write('-include {}.d\n'.format(base))

def __emit_link__(out, rule, var_prefix, command_template):
    if len(rule.attrs['files']) > 0:
        var_name = __unique_var_name__(
            '{}{}_OBJS'.format(var_prefix, rule.name.upper())
        )
        out.write('{} := {}\n'.format(var_name, ' '.join(
            (target_name(i) for i in rule.attrs['files'])
        )))
        files = '$({})'.format(var_name)
    else:
        files = target_name(rule.attrs['files'][0])

    write_makefile_rule(
        out,
        target_name(rule),
        rule.deps + [files] + filter_rules(rule.attrs['libs']),
        [command_template.format(
            files=files,
            libs=''.join((' -l' + lib_link_name(i) for i in rule.attrs['libs']))
        )]
    )

@rule_handler('executable')
def __emit_executable__(out, rule):
    __emit_link__(out, rule, '', 'g++ {files}{libs} -o $@')

@rule_handler('library')
def __emit_library__(out, rule):
    __emit_link__(out, rule, 'LIB', 'g++ -shared {files}{libs} -o $@')

@rule_handler('target')
def __emit_target__(out, rule):
    write_makefile_rule(out, target_name(rule), rule.deps, [], phony=True)

@rule_handler('command')
def __emit_command__(out, rule):
    write_makefile_rule(out, target_name(rule), rule.deps, rule.attrs['cmd'],
                        phony=True)

if __name__ == '__main__':
    execfile(sys.argv[1])
    write_makefile(sys.stdout)
