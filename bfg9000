#!/usr/bin/env python
# -*- python -*-

import os.path
import sys
from collections import OrderedDict
__targets__ = OrderedDict()

class Rule(object):
    def __init__(self, kind, name, deps, attrs):
        self.kind = kind
        self.name = name
        self.deps = deps
        self.attrs = attrs

def rule(fn):
    def wrapped(name, deps=None, **kwargs):
        result = Rule(fn.func_name, name, deps or [], fn(**kwargs))
        if name not in __targets__:
            __targets__[name] = []
        __targets__[name].append(result)
        return result
    return wrapped

__rule_handlers__ = {}
def rule_handler(rule_name):
    def decorator(fn):
        __rule_handlers__[rule_name] = fn
        return fn
    return decorator

def target_name(rule):
    if isinstance(rule, Rule):
        if rule.kind == 'library':
            return 'lib{}.so'.format(rule.name)
        elif rule.kind == 'compile':
            return '{}.o'.format(rule.name)
        else:
            return rule.name
    else:
        return rule

def lib_link_name(rule):
    if isinstance(rule, Rule):
        return rule.name
    else:
        return rule

def write_makefile_rule(target, deps, commands, phony=False):
    if phony:
        print '.PHONY: {}'.format(target)
    print '{}:'.format(target),
    if deps:
        print ' '.join((target_name(i) for i in deps)),
    print
    if commands:
        print '\t' + '\n\t'.join(commands)
    print

def write_makefile():
    for i in __targets__.itervalues():
        for rule in i:
            __rule_handlers__[rule.kind](rule)

@rule
def compile(file):
    return {'file': file}

def compile_all(files):
    return [compile(os.path.splitext(f)[0], file=f) for f in files]

@rule
def executable(files, libs=None):
    return {'files': compile_all(files), 'libs': libs or []}

@rule
def library(files, libs=None):
    return {'files': compile_all(files), 'libs': libs or []}

@rule
def target():
    return {'phony': True}

@rule
def command(cmd):
    return {'cmd': cmd, 'phony': True}


__seen_compile_rules__ = set()

def filter_rules(iterable):
    return filter(lambda i: isinstance(i, Rule), iterable)

@rule_handler('compile')
def __emit_compile__(rule):
    base, ext = os.path.splitext(rule.attrs['file'])
    if ext not in __seen_compile_rules__:
        __seen_compile_rules__.add(ext)
        write_makefile_rule(
            '%.o',
            ['%' + ext],
            ["$(eval TEMP := $(shell mktemp $(TMPDIR)/$(*F)-XXXXXX.d))",
             "g++ -MMD -MF $(TEMP) -c $< -o $@",
             "@sed -e 's|.*:|$*.o:|' < $(TEMP) > $*.d",
             "@sed -e 's/.*://' -e 's/\\$$//' < $(TEMP) | fmt -1 | \\",
             "  sed -e 's/^ *//' -e 's/$$/:/' >> $*.d",
             "@rm -f $(TEMP)"]
        )
    print '-include {}.d'.format(base)

@rule_handler('executable')
def __emit_executable__(rule):
    write_makefile_rule(
        target_name(rule),
        rule.deps + filter_rules(rule.attrs['files']) +
            filter_rules(rule.attrs['libs']),
        ['g++ {files}{libs} -o $@'.format(
            files=' '.join((target_name(i) for i in rule.attrs['files'])),
            libs=''.join((' -l' + lib_link_name(i) for i in rule.attrs['libs']))
        )]
    )

@rule_handler('library')
def __emit_executable__(rule):
    write_makefile_rule(
        target_name(rule),
        rule.deps + filter_rules(rule.attrs['files']) +
            filter_rules(rule.attrs['libs']),
        ['g++ -shared {files}{libs} -o $@'.format(
            files=' '.join((target_name(i) for i in rule.attrs['files'])),
            libs=''.join((' -l' + lib_link_name(i) for i in rule.attrs['libs']))
        )]
    )

@rule_handler('target')
def __emit_target__(rule):
    write_makefile_rule(
        target_name(rule),
        rule.deps,
        None,
        phony=True
    )

@rule_handler('command')
def __emit_command__(rule):
    write_makefile_rule(
        target_name(rule),
        rule.deps,
        rule.attrs['cmd'],
        phony=True
    )

if __name__ == '__main__':
    execfile(sys.argv[1])
    write_makefile()
