#!/usr/bin/env python
# -*- python -*-

import os.path
import sys
from collections import OrderedDict
__targets__ = OrderedDict()

class Rule(object):
    def __init__(self, kind, name, deps, attrs):
        self.kind = kind
        self.name = name
        self.deps = deps
        self.attrs = attrs

def rule(fn):
    def wrapped(name, deps=None, **kwargs):
        result = Rule(fn.func_name, name, deps or [], fn(**kwargs))
        if name not in __targets__:
            __targets__[name] = []
        __targets__[name].append(result)
        return result
    return wrapped

__rule_handlers__ = {}
def rule_handler(rule_name):
    def decorator(fn):
        __rule_handlers__[rule_name] = fn
        return fn
    return decorator

def target_name(rule):
    if isinstance(rule, Rule):
        if rule.kind == 'library':
            return 'lib{}.so'.format(rule.name)
        elif rule.kind == 'compile':
            return '{}.o'.format(rule.name)
        else:
            return rule.name
    else:
        return rule

def lib_link_name(rule):
    if isinstance(rule, Rule):
        return rule.name
    else:
        return rule

def write_makefile_rule(target, deps, commands, phony=False):
    if phony:
        print '.PHONY: {}'.format(target)
    print '{}:'.format(target),
    if deps:
        print ' '.join((target_name(i) for i in deps)),
    print
    if commands:
        print '\t' + '\n\t'.join(commands)
    print

def write_makefile():
    for i in __targets__.itervalues():
        for rule in i:
            __rule_handlers__[rule.kind](rule)

@rule
def compile(file):
    return {'file': file}

def compile_all(files):
    return [compile(os.path.splitext(f)[0], file=f) for f in files]

@rule
def executable(files, libs=None):
    # XXX: Allow pre-built objects?
    return {'files': compile_all(files), 'libs': libs or []}

@rule
def library(files, libs=None):
    # XXX: Allow pre-built objects?
    return {'files': compile_all(files), 'libs': libs or []}

@rule
def target():
    return {'phony': True}

@rule
def command(cmd):
    return {'cmd': cmd, 'phony': True}


__seen_compile_rules__ = set()

__var_table__ = set()
def __unique_var_name__(name):
    if name in __var_table__:
        i = 2
        fmt = name + '_{}'
        while True:
            name = fmt.format(i)
            if name not in __var_table__:
                break
    __var_table__.add(name)
    return name

@rule_handler('compile')
def __emit_compile__(rule):
    base, ext = os.path.splitext(rule.attrs['file'])
    if ext not in __seen_compile_rules__:
        __seen_compile_rules__.add(ext)
        write_makefile_rule(
            '%.o',
            ['%' + ext],
            ["$(eval TEMP := $(shell mktemp $(TMPDIR)/$(*F)-XXXXXX.d))",
             "g++ -MMD -MF $(TEMP) -c $< -o $@",
             "@sed -e 's|.*:|$*.o:|' < $(TEMP) > $*.d",
             "@sed -e 's/.*://' -e 's/\\$$//' < $(TEMP) | fmt -1 | \\",
             "  sed -e 's/^ *//' -e 's/$$/:/' >> $*.d",
             "@rm -f $(TEMP)"]
        )
    print '-include {}.d'.format(base)

def __emit_link__(rule, var_prefix, command_template):
    if len(rule.attrs['files']) > 0:
        var_name = __unique_var_name__(
            '{}{}_OBJS'.format(var_prefix, rule.name.upper())
        )
        print '{} := {}'.format(var_name, ' '.join(
            (target_name(i) for i in rule.attrs['files'])
        ))
        files = '$({})'.format(var_name)
    else:
        files = target_name(rule.attrs['files'][0])

    write_makefile_rule(
        target_name(rule),
        rule.deps + [files] + filter_rules(rule.attrs['libs']),
        [command_template.format(
            files=files,
            libs=''.join((' -l' + lib_link_name(i) for i in rule.attrs['libs']))
        )]
    )

@rule_handler('executable')
def __emit_executable__(rule):
    __emit_link__(rule, '', 'g++ {files}{libs} -o $@')

@rule_handler('library')
def __emit_library__(rule):
    __emit_link__(rule, 'LIB', 'g++ -shared {files}{libs} -o $@')

@rule_handler('target')
def __emit_target__(rule):
    write_makefile_rule(
        target_name(rule),
        rule.deps,
        None,
        phony=True
    )

@rule_handler('command')
def __emit_command__(rule):
    write_makefile_rule(
        target_name(rule),
        rule.deps,
        rule.attrs['cmd'],
        phony=True
    )

if __name__ == '__main__':
    execfile(sys.argv[1])
    write_makefile()
