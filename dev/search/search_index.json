{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"/","text":"bfg9000 \u00a7 bfg9000 ( \"build file generator\" ) is a cross-platform build configuration system with an emphasis on making it easy to define how to build your software. It converts a Python-based build script into the appropriate files for your underlying build system of choice. Why bfg9000? \u00a7 Familiar syntax \u00a7 build.bfg files are just Python scripts with some new functions added, so you may already know how to write them; and when your build gets complicated, you can rely on the existing Python ecosystem to get you out of trouble. Fast builds \u00a7 bfg9000 ensures your builds are fast by relying on existing, mature build systems like Make and Ninja to do the heavy lifting of building your software; often, incremental builds don't need to execute bfg9000 at all! Stay sane \u00a7 Building your code shouldn't be the hard part of developing your project. Above all else, bfg9000 strives to help you get your build right the first time with many helpful features . A brief example \u00a7 You can't get much simpler than the simplest build.bfg file: executable('simple', files=['simple.cpp']) To build this executable, we need to create the actual build files and then run them: $ cd /path/to/src/ $ 9k build/ $ cd build/ $ ninja From there, you can run your newly-created executable: ./simple . Hooray! For further examples, please see the examples/ subdirectory.","title":"Home"},{"location":"/#bfg9000","text":"bfg9000 ( \"build file generator\" ) is a cross-platform build configuration system with an emphasis on making it easy to define how to build your software. It converts a Python-based build script into the appropriate files for your underlying build system of choice.","title":"bfg9000"},{"location":"/#why-bfg9000","text":"","title":"Why bfg9000?"},{"location":"/#familiar-syntax","text":"build.bfg files are just Python scripts with some new functions added, so you may already know how to write them; and when your build gets complicated, you can rely on the existing Python ecosystem to get you out of trouble.","title":"Familiar syntax"},{"location":"/#fast-builds","text":"bfg9000 ensures your builds are fast by relying on existing, mature build systems like Make and Ninja to do the heavy lifting of building your software; often, incremental builds don't need to execute bfg9000 at all!","title":"Fast builds"},{"location":"/#stay-sane","text":"Building your code shouldn't be the hard part of developing your project. Above all else, bfg9000 strives to help you get your build right the first time with many helpful features .","title":"Stay sane"},{"location":"/#a-brief-example","text":"You can't get much simpler than the simplest build.bfg file: executable('simple', files=['simple.cpp']) To build this executable, we need to create the actual build files and then run them: $ cd /path/to/src/ $ 9k build/ $ cd build/ $ ninja From there, you can run your newly-created executable: ./simple . Hooray! For further examples, please see the examples/ subdirectory.","title":"A brief example"},{"location":"/getting-started/","text":"Getting Started \u00a7 Supported platforms/languages \u00a7 bfg9000 is designed to work on Linux, OS X, and Windows; other POSIX systems should work as well, but they aren't explicitly supported (if you'd like to help add support for your favorite platform, just file a pull request!). In addition, bfg9000 supports building code written in the following languages: C C++ Fortran (partial) Java Objective C/C++ Scala For more details on what you can do with bfg9000, see the features page. Installation \u00a7 bfg9000 uses setuptools , so installation is much the same as any other Python package: $ pip install bfg9000 If you've downloaded bfg already, just run pip install . from the source directory. (Equivalently, you can run python setup.py install .) From there, you can start using bfg to build your software! Note If you're using Ubuntu, you can also install bfg9000 from the following PPA: ppa:jimporter/stable . Installing patchelf \u00a7 On Linux, bfg9000 requires patchelf in order to modify rpath s of executables and shared libraries when installing. If you don't already have patchelf installed (e.g. via your distro's package manager) and in your PATH , bfg9000 will automatically install it via the patchelf-wrapper package. If you'd prefer not to install patchelf at all, you can set the NO_PATCHELF environment variable to 1 before installing bfg9000: $ NO_PATCHELF=1 pip install bfg9000 This will automatically download and install patchelf when installing the rest of bfg9000. If you're installing into a virtualenv , patchelf will go into $VIRTUAL_ENV/bin . Installing MSBuild support \u00a7 Since many users don't need it, MSBuild support is an optional feature. To install all the dependencies required for MSBuild, you can run the following: $ pip install bfg9000[msbuild]","title":"Getting Started"},{"location":"/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"/getting-started/#supported-platformslanguages","text":"bfg9000 is designed to work on Linux, OS X, and Windows; other POSIX systems should work as well, but they aren't explicitly supported (if you'd like to help add support for your favorite platform, just file a pull request!). In addition, bfg9000 supports building code written in the following languages: C C++ Fortran (partial) Java Objective C/C++ Scala For more details on what you can do with bfg9000, see the features page.","title":"Supported platforms/languages"},{"location":"/getting-started/#installation","text":"bfg9000 uses setuptools , so installation is much the same as any other Python package: $ pip install bfg9000 If you've downloaded bfg already, just run pip install . from the source directory. (Equivalently, you can run python setup.py install .) From there, you can start using bfg to build your software! Note If you're using Ubuntu, you can also install bfg9000 from the following PPA: ppa:jimporter/stable .","title":"Installation"},{"location":"/getting-started/#installing-patchelf","text":"On Linux, bfg9000 requires patchelf in order to modify rpath s of executables and shared libraries when installing. If you don't already have patchelf installed (e.g. via your distro's package manager) and in your PATH , bfg9000 will automatically install it via the patchelf-wrapper package. If you'd prefer not to install patchelf at all, you can set the NO_PATCHELF environment variable to 1 before installing bfg9000: $ NO_PATCHELF=1 pip install bfg9000 This will automatically download and install patchelf when installing the rest of bfg9000. If you're installing into a virtualenv , patchelf will go into $VIRTUAL_ENV/bin .","title":"Installing patchelf"},{"location":"/getting-started/#installing-msbuild-support","text":"Since many users don't need it, MSBuild support is an optional feature. To install all the dependencies required for MSBuild, you can run the following: $ pip install bfg9000[msbuild]","title":"Installing MSBuild support"},{"location":"/user/features/","text":"Features \u00a7 Supported languages/platforms \u00a7 bfg9000 is designed to work on Linux, OS X, and Windows; other POSIX systems should work as well, but they aren't explicitly supported (if you'd like to help add support for your favorite platform, just file a pull request!). In addition, bfg9000 supports building code written in the following languages: C C++ Fortran (partial) Java Objective C/C++ Scala Finally, bfg supports generating build files for Make , Ninja , and MSBuild , defaulting to Ninja. Rich scripting \u00a7 Since build.bfg (and options.bfg !) files are just Python scripts with some extra builtins, it's possible to use the entirety of the Python ecosystem in your build scripts. This allows you to perform complex operations in your build scripts without having to roll everything yourself or provide a layer of \"glue\" to some external scripts in your build process. Intelligent rpath support \u00a7 bfg9000 automatically specifies rpaths on platforms that support them (currently Linux and macOS), making it easier to produce correct builds. When building, bfg always produces relative rpaths to allow moving your build directory without breaking things; however, when installing your build, these rpaths are modified to absolute paths (using patchelf on Linux and install_name_tool on macOS). Auto-sudo during installation \u00a7 When installing your builds, the install tool ( doppel ) will automatically request sudo priveleges if the installation directory requires it. This allows you to run ninja install as a non-root user, preventing permissions issues with intermediate files as well as being more secure. pkg-config lookup and generation \u00a7 bfg9000 supports pkg-config both for looking up packages as well as generating .pc files for your own packages. Project-defined arguments \u00a7 Projects can specify their own options, complete with help instructions, in the options.bfg , making it easy to help users get your project configured for their system.","title":"Features"},{"location":"/user/features/#features","text":"","title":"Features"},{"location":"/user/features/#supported-languagesplatforms","text":"bfg9000 is designed to work on Linux, OS X, and Windows; other POSIX systems should work as well, but they aren't explicitly supported (if you'd like to help add support for your favorite platform, just file a pull request!). In addition, bfg9000 supports building code written in the following languages: C C++ Fortran (partial) Java Objective C/C++ Scala Finally, bfg supports generating build files for Make , Ninja , and MSBuild , defaulting to Ninja.","title":"Supported languages/platforms"},{"location":"/user/features/#rich-scripting","text":"Since build.bfg (and options.bfg !) files are just Python scripts with some extra builtins, it's possible to use the entirety of the Python ecosystem in your build scripts. This allows you to perform complex operations in your build scripts without having to roll everything yourself or provide a layer of \"glue\" to some external scripts in your build process.","title":"Rich scripting"},{"location":"/user/features/#intelligent-rpath-support","text":"bfg9000 automatically specifies rpaths on platforms that support them (currently Linux and macOS), making it easier to produce correct builds. When building, bfg always produces relative rpaths to allow moving your build directory without breaking things; however, when installing your build, these rpaths are modified to absolute paths (using patchelf on Linux and install_name_tool on macOS).","title":"Intelligent rpath support"},{"location":"/user/features/#auto-sudo-during-installation","text":"When installing your builds, the install tool ( doppel ) will automatically request sudo priveleges if the installation directory requires it. This allows you to run ninja install as a non-root user, preventing permissions issues with intermediate files as well as being more secure.","title":"Auto-sudo during installation"},{"location":"/user/features/#pkg-config-lookup-and-generation","text":"bfg9000 supports pkg-config both for looking up packages as well as generating .pc files for your own packages.","title":"pkg-config lookup and generation"},{"location":"/user/features/#project-defined-arguments","text":"Projects can specify their own options, complete with help instructions, in the options.bfg , making it easy to help users get your project configured for their system.","title":"Project-defined arguments"},{"location":"/user/building/","text":"Building With bfg9000 \u00a7 Like some other tools (e.g. CMake or autotools ), bfg9000 isn't actually a build system; it's a build configuration system or, if you prefer, a meta-build system . That is, bfg9000 builds build files which you then use to run your actual builds. Your first build \u00a7 Invoking bfg9000 is simple. Assuming you have an existing project that uses bfg9000, just call bfg9000 configure builddir and it will generate the final build script ( build.ninja in this case) in builddir to use for building your project: $ cd /path/to/src/ $ bfg9000 configure build/ $ cd build/ $ ninja Since the configure command is easily the most common thing to run when using bfg9000, you can use the following shorthand instead of bfg9000 configure build/ : $ 9k build/ Note On Windows, using bfg9000 requires a bit more care. Since the MSVC tools aren't in the PATH by default, you can't just open any command prompt. You need to pick the correct prompt. Thankfully, Visual Studio provides Start Menu items such as \"VS2015 Developer Command Prompt\". These add the appropiate directories to the PATH , allowing you to use whichever version of the MSVC tools that you'd like. Build directories \u00a7 You might have noticed above that build.ninja was placed in a separate directory. This is because bfg9000 exclusively uses out-of-tree builds ; that is, the build directory must be different from the source directory. While slightly more inconvenient for one-off builds (users will have to cd into another directory to start the build), the benefits are significant. First, it ensures that cleaning a build is trivial: just remove the build directory. Second, simplifies building in multiple configurations, a very useful feature for development; you can easily have debug and optimized builds sitting side-by-side. In our example above, we specified the build directory to place the final build files. However, you can also run bfg9000 from the build directory, in which case you'd run bfg9000 configure srcdir/ (or, equivalently, 9k srcdir/ ). If neither the source nor build directories are your current working directory, you can run: bfg9000 configure-into srcdir/ builddir/ Selecting a backend \u00a7 By default, bfg9000 tries to use the most appropriate build backend for your system. In descending order, bfg prefers ninja , make , and msbuild . If one of these isn't installed, it will try the next best option. However, you can explicitly select a backend with the --backend option. For instance, to build a Makefile even if Ninja is installed: $ bfg9000 configure builddir/ --backend=make For a complete description of the available command-line options for bfg9000, see the Command-line Reference chapter. Setting build options \u00a7 Many options for building can be set via the environment. These generally follow the UNIX naming conventions, so you can use, say, CXX to change the C++ compiler that bfg9000 uses. For a full listing of the recognized environment variables, see the Environment Variables chapter. Installing your software \u00a7 After building your software, you may wish to install it to another directory on your system. You can do this by running: $ ninja install Similarly, you can run ninja uninstall to uninstall the files from their install location. Of course, if you're using the Make backend, you'd run make install / make uninstall instead. Warning The MSBuild backend doesn't currently support this command. Install locations \u00a7 By default, bfg9000 will install them into the appropriate place for your platform (e.g. /usr/local/bin for exectuables on POSIX systems). However, you can specify where you'd like to install your project when invoking bfg9000. To change the installation prefix ( /usr/local on POSIX), just specify --prefix /path/to/prefix when running bfg9000. You can also specify the binary, library, and include directories individually, using --bindir , --libdir , and --includedir , respectively. Note On POSIX systems, you can additionally specify the $DESTDIR environment variable to perform a staged installation (useful when creating a binary package, for example). For more information about $DESTDIR, see the GNU coding standards . Distributing your source \u00a7 Once you're ready to release your software, you'll want to provide a source distribution. You can't just archive the entire source directory, since it'll include things that don't belong like .gitignore . Instead, you should run: $ ninja dist (Of course, you should run make dist for the Make backend.) This will produce a tar.gz file containing all the source files necessary for building your project. If you'd like to specify another file format, you can use one of the following targets: dist-gzip , dist-bzip2 , or dist-zip . Warning The MSBuild backend doesn't currently support this command.","title":"Building with bfg9000"},{"location":"/user/building/#building-with-bfg9000","text":"Like some other tools (e.g. CMake or autotools ), bfg9000 isn't actually a build system; it's a build configuration system or, if you prefer, a meta-build system . That is, bfg9000 builds build files which you then use to run your actual builds.","title":"Building With bfg9000"},{"location":"/user/building/#your-first-build","text":"Invoking bfg9000 is simple. Assuming you have an existing project that uses bfg9000, just call bfg9000 configure builddir and it will generate the final build script ( build.ninja in this case) in builddir to use for building your project: $ cd /path/to/src/ $ bfg9000 configure build/ $ cd build/ $ ninja Since the configure command is easily the most common thing to run when using bfg9000, you can use the following shorthand instead of bfg9000 configure build/ : $ 9k build/ Note On Windows, using bfg9000 requires a bit more care. Since the MSVC tools aren't in the PATH by default, you can't just open any command prompt. You need to pick the correct prompt. Thankfully, Visual Studio provides Start Menu items such as \"VS2015 Developer Command Prompt\". These add the appropiate directories to the PATH , allowing you to use whichever version of the MSVC tools that you'd like.","title":"Your first build"},{"location":"/user/building/#build-directories","text":"You might have noticed above that build.ninja was placed in a separate directory. This is because bfg9000 exclusively uses out-of-tree builds ; that is, the build directory must be different from the source directory. While slightly more inconvenient for one-off builds (users will have to cd into another directory to start the build), the benefits are significant. First, it ensures that cleaning a build is trivial: just remove the build directory. Second, simplifies building in multiple configurations, a very useful feature for development; you can easily have debug and optimized builds sitting side-by-side. In our example above, we specified the build directory to place the final build files. However, you can also run bfg9000 from the build directory, in which case you'd run bfg9000 configure srcdir/ (or, equivalently, 9k srcdir/ ). If neither the source nor build directories are your current working directory, you can run: bfg9000 configure-into srcdir/ builddir/","title":"Build directories"},{"location":"/user/building/#selecting-a-backend","text":"By default, bfg9000 tries to use the most appropriate build backend for your system. In descending order, bfg prefers ninja , make , and msbuild . If one of these isn't installed, it will try the next best option. However, you can explicitly select a backend with the --backend option. For instance, to build a Makefile even if Ninja is installed: $ bfg9000 configure builddir/ --backend=make For a complete description of the available command-line options for bfg9000, see the Command-line Reference chapter.","title":"Selecting a backend"},{"location":"/user/building/#setting-build-options","text":"Many options for building can be set via the environment. These generally follow the UNIX naming conventions, so you can use, say, CXX to change the C++ compiler that bfg9000 uses. For a full listing of the recognized environment variables, see the Environment Variables chapter.","title":"Setting build options"},{"location":"/user/building/#installing-your-software","text":"After building your software, you may wish to install it to another directory on your system. You can do this by running: $ ninja install Similarly, you can run ninja uninstall to uninstall the files from their install location. Of course, if you're using the Make backend, you'd run make install / make uninstall instead. Warning The MSBuild backend doesn't currently support this command.","title":"Installing your software"},{"location":"/user/building/#install-locations","text":"By default, bfg9000 will install them into the appropriate place for your platform (e.g. /usr/local/bin for exectuables on POSIX systems). However, you can specify where you'd like to install your project when invoking bfg9000. To change the installation prefix ( /usr/local on POSIX), just specify --prefix /path/to/prefix when running bfg9000. You can also specify the binary, library, and include directories individually, using --bindir , --libdir , and --includedir , respectively. Note On POSIX systems, you can additionally specify the $DESTDIR environment variable to perform a staged installation (useful when creating a binary package, for example). For more information about $DESTDIR, see the GNU coding standards .","title":"Install locations"},{"location":"/user/building/#distributing-your-source","text":"Once you're ready to release your software, you'll want to provide a source distribution. You can't just archive the entire source directory, since it'll include things that don't belong like .gitignore . Instead, you should run: $ ninja dist (Of course, you should run make dist for the Make backend.) This will produce a tar.gz file containing all the source files necessary for building your project. If you'd like to specify another file format, you can use one of the following targets: dist-gzip , dist-bzip2 , or dist-zip . Warning The MSBuild backend doesn't currently support this command.","title":"Distributing your source"},{"location":"/user/writing/","text":"Writing a Build File \u00a7 bfg9000's build script is called build.bfg and is (usually) placed in the root of your source tree. build.bfg files are just Python scripts with a handful of extra built-in functions to define all the rules for building your software. While bfg9000's goal is to make writing build scripts easy, sometimes complexity is unavoidable. By using a general-purpose language, this complexity can (hopefully!) be managed. Your first build script \u00a7 The simplest build script, compiling a single source file into an executable , is indeed very simple: executable('simple', files=['simple.cpp']) The above is all you need to build your executable for any supported build backend and platform. The output file's name is automatically converted to the appropriate name for the target platform ( 'simple' on Linux and OS X and 'simple.exe' on Windows). Building executables \u00a7 We've already seen how to build simple executables, but build tools aren't much good if that's all they can do! Naturally, it's easy to build an executable from multiple source files (just add more elements to the files argument), but there are plenty of other things you'd probably like to do with your build scripts. Implicit conversions \u00a7 bfg9000 tries its best to make your build scripts easy to read and to minimize verbosity. First, arguments that normally take a list can take a single item instead, e.g. executable('simple', files='simple.cpp') . In addition, bfg9000 will automatically convert a string argument to an object of the appropriate type. In the previous example, 'simple.cpp' is automatically converted to a source_file . Sudirectories \u00a7 Many projects organize their headers and source files into different directories. For source files, this is easy to handle: just write out the relative path to the file. For header files, you need to let your compiler know where they're located. The header_directory function creates a reference to the directory, which can then be passed to your build function via the include argument: include_dir = header_directory('include') executable('program', files=['src/prog.cpp'], includes=[include_dir]) As noted above, you can also simplify this to: executable('program', files='src/prog.cpp', includes='include') Of course, bfg9000 also allows you to place built files in subdirectories as well. Simply specify the relative path as the name of executable (or whatever type of file you're building). Options \u00a7 Build scripts often need to set options when compiling/linking binaries. Sometimes, these are specific to a single executable in the project, and other times they apply to all the binaries. bfg9000 supports both cases. You can provide options for a single binary with the compile_options and link_options arguments: executable('simple', files=['simple.cpp'], compile_options=['-Wall', '-Werror'], link_options=['-static-libstdc++']) You can also specify global compiler options (on a per-language basis) as well as global linker options : global_options(['-Wall', '-Werror'], lang='c++') global_link_options(['-static-libstdc++']) Naturally, the interpretations of these arguments depend on the compiler being used, so it's important to be sure the compiler understands the arguments. You can determine the kind of compiler being used by consulting the build's Environment and checking the compiler's flavor . Building libraries \u00a7 In addition to building executables, you can obviously also build libraries . This takes the same arguments as an executable as described above. Once you've defined how to build your library, you can pass it along to an executable or other shared library via the libs argument: lib = library('library', files=['library.cpp']) executable('program', files=['program.cpp'], libs=[lib]) By default, this will create a shared library; however, when running bfg9000, users can specify what kind of library to build by passing --enable-shared / --disable-shared and --enable-static / --disable-static on the command line. When creating a static library, the link_options argument behaves specially: it represents arguments that will be forwarded to the dynamic linker when the static lib is used. Shared and static libraries \u00a7 Sometimes, you may want to explicitly specify in the build file whether to create a shared or a static library. This is easy to accomplish: shared = shared_library('shared', files=['shared.cpp']) static = static_library('static', files=['static.cpp']) Building libraries on Windows \u00a7 On Windows, native shared libraries need to annotate public symbols so that the dynamic linker knows what to do. To facilitate this, bfg9000 automatically defines a preprocessor macro named for native-runtime languages (e.g. C or C++) when building on Windows. For shared libraries, it defines LIB NAME _EXPORTS ; for static, LIB NAME _STATIC . The following snippet shows how you can use these macros to set the appropriate attributes for your public symbols: #if defined(_WIN32) !defined(LIBLIBRARY_STATIC) # ifdef LIBLIBRARY_EXPORTS # define LIB_PUBLIC __declspec(dllexport) # else # define LIB_PUBLIC __declspec(dllimport) # endif #else # define LIB_PUBLIC #endif Finding files \u00a7 For projects with many source files, it can be inconvenient to manually list all of them. Since build.bfg files are just Python scripts, you could use Python's standard library to examine the file system and build the list. However, there's a better way: bfg9000 provides a find_files() function to fetch the list; if the list ever changes, the build files will be regenerated automatically the next time they're run. find_files() starts at a base directory and searches recursively for any files matching a particular glob: hello_files = find_files('src/hello', '*.cpp') executable('hello', files=hello_files) There are lots of options you can pass to find_files() to tweak its behavior. For instance, you can search only for files or only for directories by passing 'f' or 'd' , respectively to the type argument. Default targets \u00a7 When you're building multiple binaries, you might want to be able to specify what gets built by default, i.e. when calling make (or ninja ) with no arguments. Normally, every executable and library (except those passed to test() ) will get built. However, you can pass any build rule(s) to default() , and they'll be set as the default, overriding the normal behavior. This makes it easy to provide your users with a standard build that gets them all the bits they need, and none they don't. External packages \u00a7 Most projects have external packages that they depend on. There are lots of different ways these packages are organized, and bfg9000 currently supports two of them: \"ordinary\" packages (resolved using either pkg-config or searched for in the default location for your system) and Boost packages : ogg = package('ogg', kind='static') prog_opts = boost_package('program_options', version=' =1.55') Each of these returns an object representing the package that can be used when building binaries by passing them in the packages argument: executable('program', files=['main.cpp'], packages=[ogg, prog_opts]) Installation \u00a7 After building, you might want to allow your project to be installed onto the user's system somewhere. Most files (headers, executables, libraries) can be added to the list of installed files via the install() rule. You can also install entire directories of headers: include_dir = header_directory('include') lib = static_library('program', files=['src/prog.cpp'], includes=[include_dir]) install(lib, include_dir) Commands \u00a7 In addition to ordinary build rules, it can be useful to provide other common commands that apply to a project's source, such as linting the code or building documentation. Normally, you should pass the command to be run as an array of arguments. This will automatically handle escaping any quotes in each argument. This is especially important for cross-platform compatibility, since different shells have different quoting rules: command('hello', cmd=['python', '-c', 'print( hello )']) Of course, if you need to use your shell's special characters (like ), you can simply pass a string to the cmd argument. In addition, you can supply multiple commands to this function via the cmds argument: command('script', cmds=[ 'touch file', ['python', 'script.py'] ]) Aliases \u00a7 Sometimes, you just want to group a set of targets together to make it easier to build all of them at once. This automatically happens for default targets by creating an all alias, but you can do this yourself for any collection of targets: foo = executable('foo', files=['foo.cpp']) bar = executable('bar', files=['bar.cpp']) alias('foobar', [foo, bar]) Tests \u00a7 All good projects should have tests. Since your project is good (isn't it?), yours has tests too, and you should have a good way to execute those tests from your build system. bfg9000 provides a set of functions for running tests. The most important of these is aptly named test() . Any executable can be passed to this function, and it will be executed as a test; an exit status of 0 marks success, and non-zero marks failure: test( executable('test_foo', files=['test_foo.cpp']) ) In addition, you can provide a test driver that collects all of your tests together and runs them as one. test_driver() takes an executable (a system_executable by default) that runs all the test files. This allows you to aggregate multiple test files into a single run, which is very useful for reporting: mettle = test_driver('mettle') test( executable('test_foo', files=['test_foo.cpp']), driver=mettle ) test( executable('test_bar', files=['test_bar.cpp']), driver=mettle ) Custom build steps \u00a7 Sometimes, the built-in build steps don't support the things you want to do (e.g. if you're generating source files via Flex/Bison). In these cases, you can use build_step() to define a step that produces a file by running an arbitrary command: lex = build_step('lex.yy.c', cmd=[ 'flex', source_file('hello.lex') ]) You can also define steps that produce multiple files. When doing this, you'll generally want to specify the type argument as well, which lets you indicate the type of file object to return. In addition, you can pass args and kwargs to forward arguments along to type : hdr, src = build_step(['hello.tab.h', 'hello.tab.c'], cmd=[ 'bison', 'hello.y' ], type=[header_file, source_file]) User-defined arguments \u00a7 Many projects benefit from letting the user configure project-specific elements of their builds, e.g. by enabling certain optional features or by using different branding for testing and release builds. You can add support for options to configure your build by creating a options.bfg file alongside your build.bfg . Inside options.bfg , you can define arguments with the argument() function: # Adds --name/--x-name to the list of available command-line options, e.g.: # 9k build/ --name=foobar argument('name', default='unnamed', help='set the program's name') It works much like argparse 's add_argument() method, except that a) argument names are automatically prefixed with -- (and --x- for forwards compatibility) and b) there are two extra actions available: enable' and 'with' : # Adds --enable-foo/--disable-foo (and --x- variants) argument('foo', action='enable', help='enable the foo feature') # Adds --with-bar/--without-bar (and --x- variants) argument('bar', action='with', help='build the bar module') Once these options are defined, you can fetch their results from the built-in argv global in your build.bfg file. This object is simply an argparse.Namespace object: print( This program's name is {} .format(argv.name)) if argv.foo: pass # Enable the foo feature if argv.bar: pass # Build the bar module Generating pkg-config data \u00a7 When creating libraries for other projects to use, pkg-config is a common tool to simplify using the library. pkg-config allows users to look up a package and retrieve all the compiler and linker options required to use that package. You can generate a pkg-config .pc file using the pkg_config() function. By default (or if the auto_fill parameter is True ), this function will automatically fill in the values for the package's name, version, installed include directories, and installed libraries: project('my_project', '1.0') include = header_directory('include', include='*.hpp') lib = library('hello', files=['src/hello.cpp'], includes=[include]) install(lib, include) pkg_config() You can also override any or all of the defaulted parameters: pkg_config( 'my_pkgconfig_project', version='2.0', includes=[include], libs=[lib], ) Libraries are perhaps the most interesting part of the pkg_config() function. If a library listed here depends on any packages or other libraries, they will automatically be included in the pkg-config info. There are several other options available to tweak the output of this function, detailed in the reference guide .","title":"Writing a Build File"},{"location":"/user/writing/#writing-a-build-file","text":"bfg9000's build script is called build.bfg and is (usually) placed in the root of your source tree. build.bfg files are just Python scripts with a handful of extra built-in functions to define all the rules for building your software. While bfg9000's goal is to make writing build scripts easy, sometimes complexity is unavoidable. By using a general-purpose language, this complexity can (hopefully!) be managed.","title":"Writing a Build File"},{"location":"/user/writing/#your-first-build-script","text":"The simplest build script, compiling a single source file into an executable , is indeed very simple: executable('simple', files=['simple.cpp']) The above is all you need to build your executable for any supported build backend and platform. The output file's name is automatically converted to the appropriate name for the target platform ( 'simple' on Linux and OS X and 'simple.exe' on Windows).","title":"Your first build script"},{"location":"/user/writing/#building-executables","text":"We've already seen how to build simple executables, but build tools aren't much good if that's all they can do! Naturally, it's easy to build an executable from multiple source files (just add more elements to the files argument), but there are plenty of other things you'd probably like to do with your build scripts.","title":"Building executables"},{"location":"/user/writing/#implicit-conversions","text":"bfg9000 tries its best to make your build scripts easy to read and to minimize verbosity. First, arguments that normally take a list can take a single item instead, e.g. executable('simple', files='simple.cpp') . In addition, bfg9000 will automatically convert a string argument to an object of the appropriate type. In the previous example, 'simple.cpp' is automatically converted to a source_file .","title":"Implicit conversions"},{"location":"/user/writing/#sudirectories","text":"Many projects organize their headers and source files into different directories. For source files, this is easy to handle: just write out the relative path to the file. For header files, you need to let your compiler know where they're located. The header_directory function creates a reference to the directory, which can then be passed to your build function via the include argument: include_dir = header_directory('include') executable('program', files=['src/prog.cpp'], includes=[include_dir]) As noted above, you can also simplify this to: executable('program', files='src/prog.cpp', includes='include') Of course, bfg9000 also allows you to place built files in subdirectories as well. Simply specify the relative path as the name of executable (or whatever type of file you're building).","title":"Sudirectories"},{"location":"/user/writing/#options","text":"Build scripts often need to set options when compiling/linking binaries. Sometimes, these are specific to a single executable in the project, and other times they apply to all the binaries. bfg9000 supports both cases. You can provide options for a single binary with the compile_options and link_options arguments: executable('simple', files=['simple.cpp'], compile_options=['-Wall', '-Werror'], link_options=['-static-libstdc++']) You can also specify global compiler options (on a per-language basis) as well as global linker options : global_options(['-Wall', '-Werror'], lang='c++') global_link_options(['-static-libstdc++']) Naturally, the interpretations of these arguments depend on the compiler being used, so it's important to be sure the compiler understands the arguments. You can determine the kind of compiler being used by consulting the build's Environment and checking the compiler's flavor .","title":"Options"},{"location":"/user/writing/#building-libraries","text":"In addition to building executables, you can obviously also build libraries . This takes the same arguments as an executable as described above. Once you've defined how to build your library, you can pass it along to an executable or other shared library via the libs argument: lib = library('library', files=['library.cpp']) executable('program', files=['program.cpp'], libs=[lib]) By default, this will create a shared library; however, when running bfg9000, users can specify what kind of library to build by passing --enable-shared / --disable-shared and --enable-static / --disable-static on the command line. When creating a static library, the link_options argument behaves specially: it represents arguments that will be forwarded to the dynamic linker when the static lib is used.","title":"Building libraries"},{"location":"/user/writing/#shared-and-static-libraries","text":"Sometimes, you may want to explicitly specify in the build file whether to create a shared or a static library. This is easy to accomplish: shared = shared_library('shared', files=['shared.cpp']) static = static_library('static', files=['static.cpp'])","title":"Shared and static libraries"},{"location":"/user/writing/#building-libraries-on-windows","text":"On Windows, native shared libraries need to annotate public symbols so that the dynamic linker knows what to do. To facilitate this, bfg9000 automatically defines a preprocessor macro named for native-runtime languages (e.g. C or C++) when building on Windows. For shared libraries, it defines LIB NAME _EXPORTS ; for static, LIB NAME _STATIC . The following snippet shows how you can use these macros to set the appropriate attributes for your public symbols: #if defined(_WIN32) !defined(LIBLIBRARY_STATIC) # ifdef LIBLIBRARY_EXPORTS # define LIB_PUBLIC __declspec(dllexport) # else # define LIB_PUBLIC __declspec(dllimport) # endif #else # define LIB_PUBLIC #endif","title":"Building libraries on Windows"},{"location":"/user/writing/#finding-files","text":"For projects with many source files, it can be inconvenient to manually list all of them. Since build.bfg files are just Python scripts, you could use Python's standard library to examine the file system and build the list. However, there's a better way: bfg9000 provides a find_files() function to fetch the list; if the list ever changes, the build files will be regenerated automatically the next time they're run. find_files() starts at a base directory and searches recursively for any files matching a particular glob: hello_files = find_files('src/hello', '*.cpp') executable('hello', files=hello_files) There are lots of options you can pass to find_files() to tweak its behavior. For instance, you can search only for files or only for directories by passing 'f' or 'd' , respectively to the type argument.","title":"Finding files"},{"location":"/user/writing/#default-targets","text":"When you're building multiple binaries, you might want to be able to specify what gets built by default, i.e. when calling make (or ninja ) with no arguments. Normally, every executable and library (except those passed to test() ) will get built. However, you can pass any build rule(s) to default() , and they'll be set as the default, overriding the normal behavior. This makes it easy to provide your users with a standard build that gets them all the bits they need, and none they don't.","title":"Default targets"},{"location":"/user/writing/#external-packages","text":"Most projects have external packages that they depend on. There are lots of different ways these packages are organized, and bfg9000 currently supports two of them: \"ordinary\" packages (resolved using either pkg-config or searched for in the default location for your system) and Boost packages : ogg = package('ogg', kind='static') prog_opts = boost_package('program_options', version=' =1.55') Each of these returns an object representing the package that can be used when building binaries by passing them in the packages argument: executable('program', files=['main.cpp'], packages=[ogg, prog_opts])","title":"External packages"},{"location":"/user/writing/#installation","text":"After building, you might want to allow your project to be installed onto the user's system somewhere. Most files (headers, executables, libraries) can be added to the list of installed files via the install() rule. You can also install entire directories of headers: include_dir = header_directory('include') lib = static_library('program', files=['src/prog.cpp'], includes=[include_dir]) install(lib, include_dir)","title":"Installation"},{"location":"/user/writing/#commands","text":"In addition to ordinary build rules, it can be useful to provide other common commands that apply to a project's source, such as linting the code or building documentation. Normally, you should pass the command to be run as an array of arguments. This will automatically handle escaping any quotes in each argument. This is especially important for cross-platform compatibility, since different shells have different quoting rules: command('hello', cmd=['python', '-c', 'print( hello )']) Of course, if you need to use your shell's special characters (like ), you can simply pass a string to the cmd argument. In addition, you can supply multiple commands to this function via the cmds argument: command('script', cmds=[ 'touch file', ['python', 'script.py'] ])","title":"Commands"},{"location":"/user/writing/#aliases","text":"Sometimes, you just want to group a set of targets together to make it easier to build all of them at once. This automatically happens for default targets by creating an all alias, but you can do this yourself for any collection of targets: foo = executable('foo', files=['foo.cpp']) bar = executable('bar', files=['bar.cpp']) alias('foobar', [foo, bar])","title":"Aliases"},{"location":"/user/writing/#tests","text":"All good projects should have tests. Since your project is good (isn't it?), yours has tests too, and you should have a good way to execute those tests from your build system. bfg9000 provides a set of functions for running tests. The most important of these is aptly named test() . Any executable can be passed to this function, and it will be executed as a test; an exit status of 0 marks success, and non-zero marks failure: test( executable('test_foo', files=['test_foo.cpp']) ) In addition, you can provide a test driver that collects all of your tests together and runs them as one. test_driver() takes an executable (a system_executable by default) that runs all the test files. This allows you to aggregate multiple test files into a single run, which is very useful for reporting: mettle = test_driver('mettle') test( executable('test_foo', files=['test_foo.cpp']), driver=mettle ) test( executable('test_bar', files=['test_bar.cpp']), driver=mettle )","title":"Tests"},{"location":"/user/writing/#custom-build-steps","text":"Sometimes, the built-in build steps don't support the things you want to do (e.g. if you're generating source files via Flex/Bison). In these cases, you can use build_step() to define a step that produces a file by running an arbitrary command: lex = build_step('lex.yy.c', cmd=[ 'flex', source_file('hello.lex') ]) You can also define steps that produce multiple files. When doing this, you'll generally want to specify the type argument as well, which lets you indicate the type of file object to return. In addition, you can pass args and kwargs to forward arguments along to type : hdr, src = build_step(['hello.tab.h', 'hello.tab.c'], cmd=[ 'bison', 'hello.y' ], type=[header_file, source_file])","title":"Custom build steps"},{"location":"/user/writing/#user-defined-arguments","text":"Many projects benefit from letting the user configure project-specific elements of their builds, e.g. by enabling certain optional features or by using different branding for testing and release builds. You can add support for options to configure your build by creating a options.bfg file alongside your build.bfg . Inside options.bfg , you can define arguments with the argument() function: # Adds --name/--x-name to the list of available command-line options, e.g.: # 9k build/ --name=foobar argument('name', default='unnamed', help='set the program's name') It works much like argparse 's add_argument() method, except that a) argument names are automatically prefixed with -- (and --x- for forwards compatibility) and b) there are two extra actions available: enable' and 'with' : # Adds --enable-foo/--disable-foo (and --x- variants) argument('foo', action='enable', help='enable the foo feature') # Adds --with-bar/--without-bar (and --x- variants) argument('bar', action='with', help='build the bar module') Once these options are defined, you can fetch their results from the built-in argv global in your build.bfg file. This object is simply an argparse.Namespace object: print( This program's name is {} .format(argv.name)) if argv.foo: pass # Enable the foo feature if argv.bar: pass # Build the bar module","title":"User-defined arguments"},{"location":"/user/writing/#generating-pkg-config-data","text":"When creating libraries for other projects to use, pkg-config is a common tool to simplify using the library. pkg-config allows users to look up a package and retrieve all the compiler and linker options required to use that package. You can generate a pkg-config .pc file using the pkg_config() function. By default (or if the auto_fill parameter is True ), this function will automatically fill in the values for the package's name, version, installed include directories, and installed libraries: project('my_project', '1.0') include = header_directory('include', include='*.hpp') lib = library('hello', files=['src/hello.cpp'], includes=[include]) install(lib, include) pkg_config() You can also override any or all of the defaulted parameters: pkg_config( 'my_pkgconfig_project', version='2.0', includes=[include], libs=[lib], ) Libraries are perhaps the most interesting part of the pkg_config() function. If a library listed here depends on any packages or other libraries, they will automatically be included in the pkg-config info. There are several other options available to tweak the output of this function, detailed in the reference guide .","title":"Generating pkg-config data"},{"location":"/user/reference/","text":"Reference \u00a7 Below are listed all the builtin functions and properties available to bfg9000 scripts ( build.bfg and options.bfg ). Most are only available to build.bfg files, since that's where most of the build configuration logic belongs, but some may be used in options.bfg . Consult each function to see its availability. File types \u00a7 Files used in a build.bfg script are divided by their types (e.g. source code, header files, etc). All files from the source directory which are referenced in the build.bfg script will automatically be added to the source distribution when it's built. In most cases, you can simply pass a string to functions expecting a file type; the string will automatically be converted to a file object of the appropriate type. However, in some cases, you may wish to explicitly create a file object. This can be useful, for instance, when running commands that take a source file as an argument, e.g. in the following snippet: command('script', cmd=['python', source_file('script.py')]) Using source_file here allows you to specify that the file is found in the source directory , rather than the build directory. directory( name , [ include ], [ exclude ], [ filter ]) \u00a7 Availability: build.bfg Create a reference to an existing directory named name . This allows you to refer to an arbitrary subfolder of your source directory. The arguments include , exclude , and filter are as per find_files . Any matching files will be added to the project's source distribution . extra_dist([ files ], [ dirs ]) \u00a7 Availability: build.bfg Add extra files and dirs to the list of recognized source files. This lets you reference files that are part of the source distribution but which have no impact on the build proper (e.g. READMEs). generic_file( name ) \u00a7 Availability: build.bfg Create a reference to an existing file named name . header_directory( name , [ include ], [ exclude ], [ filter ], [ system ]) \u00a7 Availability: build.bfg Create a reference to a directory named name containing header files for the project. This can then be used in the include argument when compiling a source file. The arguments include , exclude , and filter are as per find_files . Any matching files will be added to the project's source distribution . If system is True , this directory will be treated as a system directory for compilers that support this. header_file( name ) \u00a7 Availability: build.bfg Create a reference to an existing header named name . This is useful if you'd like to install a single header file for your project. source_file( name , [ lang ]) \u00a7 Availability: build.bfg Create a reference to an existing source file named name . If lang is not specified, the language of the file is inferred from its extension. Build steps \u00a7 Availability: build.bfg Build steps define rules to create an output (usually a file) from zero or more inputs (also usually files). As you may expect, if the output doesn't exist, the step is run to generate it. Each input is a dependency on the output, and any changes to an input will result in a rebuild. This includes headers #include d by any of the source files, but does not include files external to the project (i.e. packages ). In addition, all build steps have the ability to define extra dependencies via the extra_deps argument. These can be files or other build steps, and changes to them will trigger a rebuild as with the build's inputs. Finally, build steps which produce a file can also be used like the file types described above to refer to prebuilt files already in the source tree (e.g. static libraries provided in binary form by a vendor). This is described in more detail for each step below. Note For build steps which produce a file, the exact name of the output file is determined by the platform you're running on. For instance, when building an executable file named \"foo\" on Windows, the resulting file will be foo.exe . build_step( name , cmd | cmds , [ environment ], [ type ], [ args ], [ kwargs ], [ extra_deps ]) \u00a7 Availability: build.bfg Create a custom build step that produces a file named name by running an arbitrary command ( cmd or cmds ). name may either be a single file name or a list of file names. For a description of the arguments cmd , cmds , and environment , see command below. By default, this function return a source_file ; you can adjust this with the type argument. This should be either 1) a function returning a file object, or 2) an object with a .type attribute that meets the criteria of (1). You can also pass args and kwargs to forward arguments along to this function. command( name , cmd | cmds , [ environment ], [ extra_deps ]) \u00a7 Availability: build.bfg Create a build step named name that runs a list of arbitrary commands, specified in either cmd or cmds ; cmd takes a single command, whereas cmds takes a list of commands. Each command may be a string to be parsed according to shell rules, a file object (such as an executable ), or a list of arguments to be passed directly to the process. You may also pass a dict to environment to set environment variables for the commands. These override any environment variables set on the command line. executable( name , [ files , ..., [ extra_deps ]]) \u00a7 Availability: build.bfg Create a build step that builds an executable file named name . files is the list of source (or object) files to link. If an element of files is a source file (or a plain string), this function will implicitly call object_file on it. The following arguments may also be specified: includes : Forwarded on to object_file pch : Forwarded on to object_file libs : A list of library files (see shared_library and static_library ) packages : A list of external packages ; also forwarded on to object_file compile_options : Forwarded on to object_file as options link_options : Command-line options to pass to the linker lang : Forwarded on to object_file If neither files nor libs is specified, this function merely references an existing executable file (a precompiled binary, a shell script, etc) somewhere on the filesystem. In this case, name is the exact name of the file, relative to the source directory. This allows you to refer to existing executables for other functions. In addition, the following arguments may be specified: format : The object format of the exectuable; by default, this is the platform's native object format (e.g. 'elf' on Linux) This build step recognizes the dynamic linking environment variables and the compiler environment variable (e.g. CC ) for the relevant language. library( name , [ files , ..., [ extra_deps ]]) \u00a7 Availability: build.bfg Create a build step that builds a shared library named name . Its arguments are the same as the superset of shared_library and static_library , with the following additional argument: kind : The kind of library to be built; one of 'shared' , 'static' , or 'dual' (to build both shared and static versions). If not specified, the default behavior depends on the command-line arguments passed to bfg9000. To enable/disable shared libraries, pass --enable-shared / --disable-shared , and for static libraries, pass --enable-static / --disable-static . Like with executable , if files isn't specified, this function merely references an existing library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. You may also pass in the format argument as with executable . If name refers to a dual-use library, this function will return the library subtype as specified in kind (e.g. passing 'shared' will return the shared version of the library). This build step recognizes the dynamic linking environment variables or the static linking environment variables , as well as the compiler environment variable (e.g. CC ) for the relevant language. Warning By convention, MSVC uses the same filenames for static libraries as for import libs for shared libraries. As a result, if both shared and static library builds are enabled with MSVC, bfg9000 will fall back to building only the shared library. object_file([ name ], [ file , ..., [ extra_deps ]]) \u00a7 Availability: build.bfg Create a build step that compiles a source file named file to an object file named name ; if name is not specified, it takes the file name in file without the extension. The following arguments may also be specified: includes : A list of directories to search for header files; you may also pass header files , and their directories will be added to the search list pch : A precompiled header to use during compilation libs : A list of library files (see shared_library and static_library ); this is only used by languages that need libraries defined at compile-time, such as Java packages : A list of external packages options : Command-line options to pass to the compiler lang : The language of the source file; useful if the source file's extension isn't recognized by bfg9000 If file isn't specified, this function merely references an existing object file somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following arguments may be specified: format : The object format of the file; by default, this is the platform's native object format (e.g. 'elf' on Linux) lang : The source language of the file; if none is specified, defaults to 'c' This build step recognizes the compilation environment variables for the relevant language. object_files( files , ..., [ extra_deps ]) \u00a7 Availability: build.bfg Create a compilation build step for each of the files in files ; this is equivalent to calling object_file for each element in files . In addition, object_files returns a special list that allows you to index into it using the filename of one of the source files listed in files . This makes it easy to extract a single object file to use in other places, e.g. test code. For example: objs = object_files(['foo.cpp', 'bar.cpp']) release_exe = executable('release', objs) foo_obj = objs['foo.cpp'] test_exe = executable('test', ['test.cpp', foo_obj]) precompiled_header([ name ], [ file , ..., [ extra_deps ]]) \u00a7 Availability: build.bfg Create a build step that generates a precompiled header, which can be used to speed up the compilation of object files . If name is not specified, it is inferred from the value of file ; the exact name varies based on the compiler being used, but typically looks like header.hpp.pch for cc-like compilers and header.pch for MSVC-like compilers. The arguments for precompiled_header are the same as for object_file , with the following additional argument: pch_source : The source file to be used when building the precompiled header. If this is not specified, a source file will automatically be created, containing nothing but #include \"header\" , where header is the name of the header specified in file . This option only applies to MSVC-like compilers; for all others, it is ignored. If file isn't specified, this function merely references an existing precompiled header somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following argument may be specified: lang : The source language of the file; if none is specified, defaults to 'c' Warning The exact behavior of precompiled headers varies according to the compiler you're using. In GCC and Clang , the header to be precompiled must be the first file #include d in each source file. In MSVC , the resulting precompiled header is actually compiled within the context of a particular source file and will contain all the code up to and including the header in question. shared_library( name , [ files , ..., [ extra_deps ]]) \u00a7 Availability: build.bfg Create a build step that builds a shared library named name . Its arguments are the same as executable , with the following additional arguments: version : The version number of the library, e.g. 1.2.3 . soversion : The API version of the library (used in its soname), e.g. 1 . Like with executable , if files isn't specified, this function merely references an existing shared library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. You may also pass in the format argument as with executable . If name refers to a dual-use library, this function will return the shared version of the library. This build step recognizes the dynamic linking environment variables and the compiler environment variable (e.g. CC ) for the relevant language. Note On Windows, this produces two files for native-runtime languages (e.g. C or C++): name.dll and name.lib . The latter is the import library , used when linking to this library. Additionally for native languages on Windows, this step will add a preprocessor macro named LIB NAME _EXPORTS that can be used for declaring public symbols. See Building libraries on Windows for an example of how to use this macro in your code. static_library( name , [ files , ..., [ extra_deps ]]) \u00a7 Availability: build.bfg Create a build step that builds a static library named name . Its arguments are the same as executable , with the following additional argument: static_link_options : Command-line options to pass to the linker Other link-related arguments ( link_options , libs , and libraries from packages ) have no direct effect on this build step. Instead, they're cached and forwarded on to any dynamic linking step that uses this static library. Like with executable , if files isn't specified, this function merely references an existing shared library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following arguments may be specified: format : The object format of the exectuable; by default, this is the platform's native object format (e.g. 'elf' on Linux) lang : The source language(s) of the library; if none is specified, defaults to ['c'] If name refers to a dual-use library, this function will return the static version of the library. This build step recognizes the static linking environment variables . Note On Windows, this step will add a preprocessor macro on Windows named LIB NAME _STATIC that can be used for declaring public symbols. See Building libraries on Windows for an example of how to use this macro in your code. whole_archive( name , [ files , ..., [ extra_deps ]]) \u00a7 Availability: build.bfg Create a build step that builds a whole-archive named name . Whole archives ensures that every object file in the library is included, rather than just the ones whose symbols are referenced. This is typically used to turn a static library into a shared library. whole_archive 's arguments are the same as for static_library . In addition, you can pass an existing static library to whole_archive to convert it into a whole archive. Warning The MSVC linker doesn't have a way of expressing the required directives, so whole_archive can't be used with it. Grouping rules \u00a7 alias( name , [ deps ]) \u00a7 Availability: build.bfg Create a build step named name that performs no actions on its own. Instead, it just runs its dependencies listed in deps as necessary. This build step is useful for grouping common steps together. default( ... ) \u00a7 Availability: build.bfg Specify a list of build steps that should be run by default when building. These are all accumulated into the all target. If default is never called, all executables and libraries not passed to test will be built by default. install( ... ) \u00a7 Availability: build.bfg Specify a list of files that need to be installed for the project to work. Each will be installed to the appropriate location based on its type, e.g. header files will go in $PREFIX/include by default on POSIX systems. These are all accumulated into the install target. If there are any runtime dependencies for a file (such as shared libraries you just built), they will be installed as well. Note When explicitly listing a target, all the files for that target will be installed. For instance, on Windows, this means that passing in a shared library will install the DLL and the import library. This rule recognizes the following environment variables: DESTDIR , INSTALL , INSTALL_NAME_TOOL , MKDIR_P , PATCHELF . Global options \u00a7 global_options( options , lang ) \u00a7 Availability: build.bfg Specify some options (either as a string or list) to use for all compilation steps for the language (or list of languages) lang . global_link_options( options , [ family ], [ mode ]) \u00a7 Availability: build.bfg Specify some options (either as a string or list) to use for all link steps for a given family of languages (or a list of families) and linking mode . By default family is 'native' , used for C, C++, and other languages using the same linking process. You can also specify 'jvm' for JVM-based languages (Java, Scala). mode may be either 'dynamic' (the default) to modify executables and shared libraries or 'static' to modify static libraries . Test rules \u00a7 These rules help you define automated tests that can all be run via the test target. For simple cases, you should only need the test rule, but you can also wrap your tests with a separate driver using test_driver . For cases where you only want to build the tests, not run them, you can use the tests target. test( test , [ environment | driver ]) \u00a7 Availability: build.bfg Create a single test. cmd is the base command (possibly with arguments) to run; this works much like the cmd argument in the command built-in. You can also pass temporary environment variables as a dict via environment , or specify a test driver to add this test file to via driver . test_driver( cmd , [ environment | parent ], [ wrap_children ]) \u00a7 Availability: build.bfg Create a test driver which can run a series of tests, specified as command-line arguments to the driver. cmd is the base command (possibly with arguments) to run; this works much like the cmd argument in the command built-in. You can also pass temporary environment variables as a dict with environment , or specify a parent test driver to wrap this driver via parent . Finally, you can specify wrap_children to determine how tests using this driver are run. If true, each test will be wrapped by env.run_arguments ; if false (the default), tests will be used as-is. test_deps( ... ) \u00a7 Availability: build.bfg Specify a list of extra dependencies which must be satisfied when building the tests via the tests target. Package resolvers \u00a7 boost_package([ name ], [ version ]) \u00a7 Availability: build.bfg Search for a Boost library. You can specify name (as a string or a list) to specify a specific Boost library (or libraries); for instance, 'program_options' . For header-only libraries, you can omit name . If version is specified, it will ensure that the installed version of Boost meets the version requirement; it must be formatted as a Python version specifier . If this function is unable to find the specified Boost library, it will raise a PackageResolutionError . If the library is found but doesn't match the required version, a PackageVersionError will be raised instead. This rule recognizes the following environment variables: BOOST_ROOT , BOOST_INCLUDEDIR , BOOST_LIBRARYDIR , CPATH , INCLUDE , LIB , LIBRARY_PATH . framework( name , [ suffix ]) \u00a7 Reference a macOS framework named name with the optional suffix suffix . Though not a \"package\" in name, this can be used wherever packages are accepted. package( name , [ version ], [ lang ], [ kind ], [ headers ], [ libs ]) \u00a7 Availability: build.bfg Search for a package named name . lang is the source language of the library ( 'c' by default); this will affect how the package is resolved. For native libraries (C, C++, Fortran, etc), this will use pkg-config to resolve the package if it's installed. Otherwise (or if pkg-config can't find the package), this will check the system's default library locations. If this function is unable to find the package, it will raise a PackageResolutionError . You can also specify kind to one of 'any' (the default), 'shared' , or 'static' . This allows you to restrict the search to find only static versions of a library, for example. If version is specified, it will (if possible) ensure that the installed version of the package meets the version requirement; it must be formatted as a Python version specifier . If this check fails, a PackageVersionError will be raised. The headers and libs arguments can be used as fallbacks when pkg-config fails to resolve the package. headers allows you to specify a header file (or list thereof) that you need to use in your source files. This will search for the header files and add the appropriate include directories to your build configuration. libs lets you list any library names that are part of this package; by default, this is set to the package's name . You can also pass None to libs in order to explicitly indicate that the library is header-only. This rule recognizes the following environment variables: CLASSPATH , CPATH , INCLUDE , LIB , LIBRARY_PATH , PKG_CONFIG . Note This function can also be used to refer to the pthread library. On many Unix-like systems, instead of using -lpthread during the link step, it's preferred to use -pthread during compilation and linking. Using package('pthread') will handle this automatically. pkg_config([ name ], [ desc_name ], [ desc ], [ url ], [ version ], [ requires ], [ requires_private ], [ conflicts ], [ includes ], [ libs ], [ libs_private ], [ options ], [ link_options ], [ link_options_private ], [ auto_fill ]) \u00a7 Availability: build.bfg Create pkg-config information for this project and install it along with the rest of the installed files. All of these arguments are optional and will be automatically inferred from the rest of the build where possible. Unless otherwise noted, these arguments correspond directly to the fields in the pkg-config .pc file. name : The name of the package (to be used at the name of the .pc file) desc_name : A human-readable name for the package (stored as the Name field in pkg-config); defaults to name desc : A brief description of the package; defaults to name library url : A URL where users can learn more about the package version : The package's version requires : A list of packages required by this package; these can be strings, a string and version specifier, or the results from package . In the last case, packages resolved by pkg-config are added directly as requirements; those resolved by other means are added to the Libs field in pkg-config requires_private : A list of packages required by this package but not exposed to users; these can be specified as with requires conflicts : A list of packages that conflict with this package; these can be specified as with requires includes : A list of directories (or header files ) to add to the search path for users of this package libs : A list of libraries for users of this package to link to; any dependent libraries, packages, or link options (in the case of static libs) will automatically be added to libs_private , requires_private , and link_options_private , respectively libs_private : A list of libraries required by this package but not exposed to users (this is used primarily for static linking); dependent libraries, packages, and link options are added as with libs options : A list of compile options for this package link_options : A list of link options for this package link_options_private : A list of link options for this package but not exposed to users (this is used primarily for static linking) lang : The language of the builder to use when generating option strings; by default, 'c' If auto_fill is true (the default), this function will automatically fill in default values for the following fields: name : The project's name (this also fills in desc_name and desc with default values) version : The project's version , or 0.0 if none is specified includes : The list of installed header files/directories libs : The list of installed library files system_executable( name ) \u00a7 Availability: build.bfg Search for an executable named name somewhere in the system's PATH. This rule recognizes the following environment variables: PATH , PATHEXT . Environment \u00a7 Occasionally, build scripts need to directly query aspects of the environment. In bfg9000, this is performed with the environment object and its various members. Environment object \u00a7 The environment , env , is a special object that encapsulates information about the system outside of bfg9000. It's used internally for nearly all platform-specific code, but it can also help in build.bfg (or options.bfg !) files when you encounter some unavoidable issue with multiplatform compatibility. Note This listing doesn't cover all available functions on the environment, since many are only useful to internal code. However, the most relevant ones for build.bfg files are shown below. env.builder( lang ) \u00a7 Return the builder used by bfg9000 for a particular language lang . env.getvar( name , [ default ]) \u00a7 Equivalent to env.variables .get(name, default) . env.platform \u00a7 Return the target platform used for the build (currently the same as the host platform). env.run_arguments( args , [ lang ]) \u00a7 Generate the arguments needed to run the command in args . If args is a file type (or a list beginning with a file type) such as an executable , it will be prepended with the runner for lang as needed. If lang is None , the language will be determined by the language of args 's first element. env.Mode \u00a7 An enumeration of output modes for env.execute and env.run . Possible values are: normal : Perform no redirection and output to stdout/stderr normally pipe : Pipe the output and return it to the calling process stdout : Pipe stderr output to stdout devnull : Pipe output to /dev/null or equivalent env.execute( args , [ env ], [ env_update ], [ shell ], [ stdout ], [ stderr ], [ returncode ]) \u00a7 Execute the command-line arguments in args and return the output. If shell is true, args should be a string that will be interpreted by the system's shell; if not (the default), it should be a series of arguments. You can also set env to be a dictionary of environment variables to pass to the child process. If env_update is true (the default), these will be added to the environment variables in env.varables ; otherwise, env represents all the environment variables to pass to the child process. stdout and stderr are env.Mode values that describe how (or if) output should be redirected. By default, both are set to Mode.normal . Finally, returncode specifies the expected return code from the subprocess. This is 0 by default, and may be either a number, a list of numbers, or 'any' to match any return code. If the return code fails to match, a CalledProcessError will be thrown. env.run( args , [ lang ], [ env ], [ env_update ], [ stdout ], [ stderr ], [ returncode ]) \u00a7 Run a command, generating any arguments needed to perform the operation. Equivalent to env.execute(env.run_arguments(arg, lang), ...) . env.variables \u00a7 A dict of all the environment variables as they were defined when the build was first configured. Builders \u00a7 Builder objects represent the toolset used to build executables and libraries for a particular source language. They can be retrieved via env.builder . While builder objects are primarily suited to bfg's internals, there are still a few useful properties for build.bfg files: builder .flavor \u00a7 The \"flavor\" of the builder, i.e. the kind of command-line interface it has. Possible values are 'cc' , 'msvc' , and 'jvm' . builder .brand \u00a7 The brand of the builder, i.e. the command name people use for it. Currently, for languages in the C family (including Fortran), this is one of 'gcc' , 'clang' , 'msvc' , or 'unknown' . For languages in the Java family, this is one of 'oracle' , 'openjdk' , 'epfl' (for Scala), or 'unknown' . builder .version \u00a7 The version of the builder (specifically, the version of the primary compiler for the builder). May be None if bfg9000 was unable to detect the version. builder .lang \u00a7 The language of the source files that this builder is designed for. builder .object_format \u00a7 The object format that the builder outputs, e.g. 'elf' , 'coff' , or 'jvm' . builder .compiler \u00a7 The compiler used with this builder. builder .pch_compiler \u00a7 The compiler used to build precompiled headers with this builder. May be None for languages or toolsets that don't support precompiled headers. builder .linker( mode ) \u00a7 The linker used with this builder. mode is one of 'executable' , 'shared_library' , or 'static_library' Its public properties are the same as compiler . cc -like builders also support a mode of 'raw' , which returns an object representing the actual linker, such as ld . builder .runner \u00a7 The runner used with files built by this builder (e.g. java ). This may be None for languages which have no runner, such as C and C++. Compilers \u00a7 Builder objects represent the specific used to compile a source file (generally into an object file ). compiler .flavor \u00a7 The \"flavor\" of the compiler, i.e. the kind of command-line interface it has; e.g. 'cc' , 'msvc' . compiler .brand \u00a7 The brand of the compiler; typically the same as builder.brand . compiler .version \u00a7 The version of the compiler; typically the same as builder.version . compiler .language \u00a7 The language of the compiler; typically the same as builder.language . compiler .command \u00a7 The command to run when invoking this compiler, e.g. g++-4.9 . Platforms \u00a7 Platform objects represent the platform that the project is being compiled for. platform .flavor \u00a7 The \"flavor\" of the platform. Either 'posix' or 'windows' . platform .name \u00a7 The name of the platform, e.g. 'linux' , 'darwin' (macOS), or 'windows' . Utilities \u00a7 argument( names ..., [ action ], [ nargs ], [ const ], [ default ], [ type ], [ choices ], [ required ], [ help ], [ metavar ], [ dest ]) \u00a7 Availability: options.bfg Define how a particular command-line argument will be parsed. names is a sequence of argument names; these will be prefixed with -- and --x- for parsing. For example, passing 'foo' will add --foo and --x-foo as possible command-line arguments. All other arguments to this function have the same behavior as in argparse.ArgumentParser.add_argument() , with the exception of action , which accepts two extra values: 'enable' : Add a pair of arguments of the form --enable- name and --disable- name (with --x- -prefixed versions as well), storing True if --enable- name is specified and False if --disable- name is. 'with' : As 'enable' , except the arguments are of the form --with- name and --without-name . argv \u00a7 Availability: build.bfg Retrieve the set of user-defined arguments passed to bfg9000; this is an argparse.Namespace object. __bfg9000__ \u00a7 Availability: build.bfg and options.bfg A dictionary containing all the builtin functions and global variables defined by bfg9000. This can be useful for feature detection or accessing builtins shadowed by a local variable. bfg9000_required_version([ version ], [ python_version ]) \u00a7 Availability: build.bfg and options.bfg Set the required version for bfg9000 and/or the required python_version . Each of these is a standard Python version specifier . If the actual versions don't match the specifiers, a VersionError is raised. bfg9000_version \u00a7 Availability: build.bfg and options.bfg Return the current version of bfg9000. This can be useful if you want to optionally support a feature only available in certain versions of bfg. filter_by_platform( name , path , type ) \u00a7 Availability: build.bfg Return FindResult.include if path is a filename that should be included for the target platform, and FindResult.not_now otherwise. File (or directory) names like PLATFORM or foo_PLATFORM.cpp are excluded if PLATFORM is a known platform name that doesn't match the target platform. Known platform names are: 'posix' , 'linux' , 'darwin' , 'cygwin' , 'windows' . This is the default filter for find_files . FindResult \u00a7 Availability: build.bfg An enum to be used as the result of a filter function for find_files . The possible enum values are: include : Include this file in the results exclude : Don't include this file in the results not_now : Don't include this file in the results, but do include it in the source distribution find_files([ path ], [ name ], [ type ], [ extra ], [ exclude ], [ flat ], [ filter ], [ cache ], [ dist ], [ as_object ]) \u00a7 Availability: build.bfg Find files in path whose name matches the glob (or list of globs) name . The following arguments may be specified: path : A path (or list of paths) to start the search in; if omitted, search in the root of the source directory ( '.' ) name : A glob (or list of globs) to match files; if omitted, all files match (equivalent to '*' ) type : A filter for the type of file: 'f' to find only files, 'd' to find only directories, or '*' to find either extra : A glob (or list of globs) to match extra files (which will not be returned from find_files but will be added to the source distribution ) exclude : A glob (or list of globs) of files to exclude from results; by default, .#* , *~ , and #*# are exluded flat : If true, find_files will not recurse into subdirectories; otherwise, (the default) it will filter : A predicate taking a filename, relative path, and file type, and returning a FindResult which will filter the results; by default, this is filter_by_platform cache : If true (the default), cache the results so that any changes to will regenerate the build scripts for the project dist : If true (the default), all files found by this function will automatically be added to the source distribution as_object : If true, results will be returned as file or directory objects; otherwise (the default), return path strings The cache argument is particularly important. It allows you to add or remove source files and not have to worry about manually rerunning bfg9000. project( name , [ version ]) \u00a7 Availability: build.bfg Set the name (and optionally the version) of the project. If you don't call this function to specify a project name, it defaults to the name of the project's source directory. This is primarily useful for creating source distributions . Exceptions \u00a7 CalledProcessError \u00a7 Availability: build.bfg and options.bfg An exception raised when a subprocess fails to execute successfully. This is just an alias for the standard Python error subprocess.CalledProcessError . PackageResolutionError \u00a7 Availability: build.bfg and options.bfg An exception raised when a package resolution function is unable to find the specified package. PackageVersionError \u00a7 Availability: build.bfg and options.bfg An exception raised when a package resolution function found the specified package, but its version doesn't match the version specifier. Derived from both PackageResolutionError and VersionError . VersionError \u00a7 Availability: build.bfg and options.bfg An exception raised when a version fails to match the supplied version specifier.","title":"Reference"},{"location":"/user/reference/#reference","text":"Below are listed all the builtin functions and properties available to bfg9000 scripts ( build.bfg and options.bfg ). Most are only available to build.bfg files, since that's where most of the build configuration logic belongs, but some may be used in options.bfg . Consult each function to see its availability.","title":"Reference"},{"location":"/user/reference/#file-types","text":"Files used in a build.bfg script are divided by their types (e.g. source code, header files, etc). All files from the source directory which are referenced in the build.bfg script will automatically be added to the source distribution when it's built. In most cases, you can simply pass a string to functions expecting a file type; the string will automatically be converted to a file object of the appropriate type. However, in some cases, you may wish to explicitly create a file object. This can be useful, for instance, when running commands that take a source file as an argument, e.g. in the following snippet: command('script', cmd=['python', source_file('script.py')]) Using source_file here allows you to specify that the file is found in the source directory , rather than the build directory.","title":"File types"},{"location":"/user/reference/#directory","text":"Availability: build.bfg Create a reference to an existing directory named name . This allows you to refer to an arbitrary subfolder of your source directory. The arguments include , exclude , and filter are as per find_files . Any matching files will be added to the project's source distribution .","title":"directory(name, [include], [exclude], [filter])"},{"location":"/user/reference/#extra_dist","text":"Availability: build.bfg Add extra files and dirs to the list of recognized source files. This lets you reference files that are part of the source distribution but which have no impact on the build proper (e.g. READMEs).","title":"extra_dist([files], [dirs])"},{"location":"/user/reference/#generic_file","text":"Availability: build.bfg Create a reference to an existing file named name .","title":"generic_file(name)"},{"location":"/user/reference/#header_directory","text":"Availability: build.bfg Create a reference to a directory named name containing header files for the project. This can then be used in the include argument when compiling a source file. The arguments include , exclude , and filter are as per find_files . Any matching files will be added to the project's source distribution . If system is True , this directory will be treated as a system directory for compilers that support this.","title":"header_directory(name, [include], [exclude], [filter], [system])"},{"location":"/user/reference/#header_file","text":"Availability: build.bfg Create a reference to an existing header named name . This is useful if you'd like to install a single header file for your project.","title":"header_file(name)"},{"location":"/user/reference/#source_file","text":"Availability: build.bfg Create a reference to an existing source file named name . If lang is not specified, the language of the file is inferred from its extension.","title":"source_file(name, [lang])"},{"location":"/user/reference/#build-steps","text":"Availability: build.bfg Build steps define rules to create an output (usually a file) from zero or more inputs (also usually files). As you may expect, if the output doesn't exist, the step is run to generate it. Each input is a dependency on the output, and any changes to an input will result in a rebuild. This includes headers #include d by any of the source files, but does not include files external to the project (i.e. packages ). In addition, all build steps have the ability to define extra dependencies via the extra_deps argument. These can be files or other build steps, and changes to them will trigger a rebuild as with the build's inputs. Finally, build steps which produce a file can also be used like the file types described above to refer to prebuilt files already in the source tree (e.g. static libraries provided in binary form by a vendor). This is described in more detail for each step below. Note For build steps which produce a file, the exact name of the output file is determined by the platform you're running on. For instance, when building an executable file named \"foo\" on Windows, the resulting file will be foo.exe .","title":"Build steps"},{"location":"/user/reference/#build_step","text":"Availability: build.bfg Create a custom build step that produces a file named name by running an arbitrary command ( cmd or cmds ). name may either be a single file name or a list of file names. For a description of the arguments cmd , cmds , and environment , see command below. By default, this function return a source_file ; you can adjust this with the type argument. This should be either 1) a function returning a file object, or 2) an object with a .type attribute that meets the criteria of (1). You can also pass args and kwargs to forward arguments along to this function.","title":"build_step(name, cmd|cmds, [environment], [type], [args], [kwargs], [extra_deps])"},{"location":"/user/reference/#command","text":"Availability: build.bfg Create a build step named name that runs a list of arbitrary commands, specified in either cmd or cmds ; cmd takes a single command, whereas cmds takes a list of commands. Each command may be a string to be parsed according to shell rules, a file object (such as an executable ), or a list of arguments to be passed directly to the process. You may also pass a dict to environment to set environment variables for the commands. These override any environment variables set on the command line.","title":"command(name, cmd|cmds, [environment], [extra_deps])"},{"location":"/user/reference/#executable","text":"Availability: build.bfg Create a build step that builds an executable file named name . files is the list of source (or object) files to link. If an element of files is a source file (or a plain string), this function will implicitly call object_file on it. The following arguments may also be specified: includes : Forwarded on to object_file pch : Forwarded on to object_file libs : A list of library files (see shared_library and static_library ) packages : A list of external packages ; also forwarded on to object_file compile_options : Forwarded on to object_file as options link_options : Command-line options to pass to the linker lang : Forwarded on to object_file If neither files nor libs is specified, this function merely references an existing executable file (a precompiled binary, a shell script, etc) somewhere on the filesystem. In this case, name is the exact name of the file, relative to the source directory. This allows you to refer to existing executables for other functions. In addition, the following arguments may be specified: format : The object format of the exectuable; by default, this is the platform's native object format (e.g. 'elf' on Linux) This build step recognizes the dynamic linking environment variables and the compiler environment variable (e.g. CC ) for the relevant language.","title":"executable(name, [files, ..., [extra_deps]])"},{"location":"/user/reference/#library","text":"Availability: build.bfg Create a build step that builds a shared library named name . Its arguments are the same as the superset of shared_library and static_library , with the following additional argument: kind : The kind of library to be built; one of 'shared' , 'static' , or 'dual' (to build both shared and static versions). If not specified, the default behavior depends on the command-line arguments passed to bfg9000. To enable/disable shared libraries, pass --enable-shared / --disable-shared , and for static libraries, pass --enable-static / --disable-static . Like with executable , if files isn't specified, this function merely references an existing library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. You may also pass in the format argument as with executable . If name refers to a dual-use library, this function will return the library subtype as specified in kind (e.g. passing 'shared' will return the shared version of the library). This build step recognizes the dynamic linking environment variables or the static linking environment variables , as well as the compiler environment variable (e.g. CC ) for the relevant language. Warning By convention, MSVC uses the same filenames for static libraries as for import libs for shared libraries. As a result, if both shared and static library builds are enabled with MSVC, bfg9000 will fall back to building only the shared library.","title":"library(name, [files, ..., [extra_deps]])"},{"location":"/user/reference/#object_file","text":"Availability: build.bfg Create a build step that compiles a source file named file to an object file named name ; if name is not specified, it takes the file name in file without the extension. The following arguments may also be specified: includes : A list of directories to search for header files; you may also pass header files , and their directories will be added to the search list pch : A precompiled header to use during compilation libs : A list of library files (see shared_library and static_library ); this is only used by languages that need libraries defined at compile-time, such as Java packages : A list of external packages options : Command-line options to pass to the compiler lang : The language of the source file; useful if the source file's extension isn't recognized by bfg9000 If file isn't specified, this function merely references an existing object file somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following arguments may be specified: format : The object format of the file; by default, this is the platform's native object format (e.g. 'elf' on Linux) lang : The source language of the file; if none is specified, defaults to 'c' This build step recognizes the compilation environment variables for the relevant language.","title":"object_file([name], [file, ..., [extra_deps]])"},{"location":"/user/reference/#object_files","text":"Availability: build.bfg Create a compilation build step for each of the files in files ; this is equivalent to calling object_file for each element in files . In addition, object_files returns a special list that allows you to index into it using the filename of one of the source files listed in files . This makes it easy to extract a single object file to use in other places, e.g. test code. For example: objs = object_files(['foo.cpp', 'bar.cpp']) release_exe = executable('release', objs) foo_obj = objs['foo.cpp'] test_exe = executable('test', ['test.cpp', foo_obj])","title":"object_files(files, ..., [extra_deps])"},{"location":"/user/reference/#precompiled_header","text":"Availability: build.bfg Create a build step that generates a precompiled header, which can be used to speed up the compilation of object files . If name is not specified, it is inferred from the value of file ; the exact name varies based on the compiler being used, but typically looks like header.hpp.pch for cc-like compilers and header.pch for MSVC-like compilers. The arguments for precompiled_header are the same as for object_file , with the following additional argument: pch_source : The source file to be used when building the precompiled header. If this is not specified, a source file will automatically be created, containing nothing but #include \"header\" , where header is the name of the header specified in file . This option only applies to MSVC-like compilers; for all others, it is ignored. If file isn't specified, this function merely references an existing precompiled header somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following argument may be specified: lang : The source language of the file; if none is specified, defaults to 'c' Warning The exact behavior of precompiled headers varies according to the compiler you're using. In GCC and Clang , the header to be precompiled must be the first file #include d in each source file. In MSVC , the resulting precompiled header is actually compiled within the context of a particular source file and will contain all the code up to and including the header in question.","title":"precompiled_header([name], [file, ..., [extra_deps]])"},{"location":"/user/reference/#shared_library","text":"Availability: build.bfg Create a build step that builds a shared library named name . Its arguments are the same as executable , with the following additional arguments: version : The version number of the library, e.g. 1.2.3 . soversion : The API version of the library (used in its soname), e.g. 1 . Like with executable , if files isn't specified, this function merely references an existing shared library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. You may also pass in the format argument as with executable . If name refers to a dual-use library, this function will return the shared version of the library. This build step recognizes the dynamic linking environment variables and the compiler environment variable (e.g. CC ) for the relevant language. Note On Windows, this produces two files for native-runtime languages (e.g. C or C++): name.dll and name.lib . The latter is the import library , used when linking to this library. Additionally for native languages on Windows, this step will add a preprocessor macro named LIB NAME _EXPORTS that can be used for declaring public symbols. See Building libraries on Windows for an example of how to use this macro in your code.","title":"shared_library(name, [files, ..., [extra_deps]])"},{"location":"/user/reference/#static_library","text":"Availability: build.bfg Create a build step that builds a static library named name . Its arguments are the same as executable , with the following additional argument: static_link_options : Command-line options to pass to the linker Other link-related arguments ( link_options , libs , and libraries from packages ) have no direct effect on this build step. Instead, they're cached and forwarded on to any dynamic linking step that uses this static library. Like with executable , if files isn't specified, this function merely references an existing shared library somewhere on the filesystem. In this case, name must be specified and is the exact name of the file, relative to the source directory. In addition, the following arguments may be specified: format : The object format of the exectuable; by default, this is the platform's native object format (e.g. 'elf' on Linux) lang : The source language(s) of the library; if none is specified, defaults to ['c'] If name refers to a dual-use library, this function will return the static version of the library. This build step recognizes the static linking environment variables . Note On Windows, this step will add a preprocessor macro on Windows named LIB NAME _STATIC that can be used for declaring public symbols. See Building libraries on Windows for an example of how to use this macro in your code.","title":"static_library(name, [files, ..., [extra_deps]])"},{"location":"/user/reference/#whole_archive","text":"Availability: build.bfg Create a build step that builds a whole-archive named name . Whole archives ensures that every object file in the library is included, rather than just the ones whose symbols are referenced. This is typically used to turn a static library into a shared library. whole_archive 's arguments are the same as for static_library . In addition, you can pass an existing static library to whole_archive to convert it into a whole archive. Warning The MSVC linker doesn't have a way of expressing the required directives, so whole_archive can't be used with it.","title":"whole_archive(name, [files, ..., [extra_deps]])"},{"location":"/user/reference/#grouping-rules","text":"","title":"Grouping rules"},{"location":"/user/reference/#alias","text":"Availability: build.bfg Create a build step named name that performs no actions on its own. Instead, it just runs its dependencies listed in deps as necessary. This build step is useful for grouping common steps together.","title":"alias(name, [deps])"},{"location":"/user/reference/#default","text":"Availability: build.bfg Specify a list of build steps that should be run by default when building. These are all accumulated into the all target. If default is never called, all executables and libraries not passed to test will be built by default.","title":"default(...)"},{"location":"/user/reference/#install","text":"Availability: build.bfg Specify a list of files that need to be installed for the project to work. Each will be installed to the appropriate location based on its type, e.g. header files will go in $PREFIX/include by default on POSIX systems. These are all accumulated into the install target. If there are any runtime dependencies for a file (such as shared libraries you just built), they will be installed as well. Note When explicitly listing a target, all the files for that target will be installed. For instance, on Windows, this means that passing in a shared library will install the DLL and the import library. This rule recognizes the following environment variables: DESTDIR , INSTALL , INSTALL_NAME_TOOL , MKDIR_P , PATCHELF .","title":"install(...)"},{"location":"/user/reference/#global-options","text":"","title":"Global options"},{"location":"/user/reference/#global_options","text":"Availability: build.bfg Specify some options (either as a string or list) to use for all compilation steps for the language (or list of languages) lang .","title":"global_options(options, lang)"},{"location":"/user/reference/#global_link_options","text":"Availability: build.bfg Specify some options (either as a string or list) to use for all link steps for a given family of languages (or a list of families) and linking mode . By default family is 'native' , used for C, C++, and other languages using the same linking process. You can also specify 'jvm' for JVM-based languages (Java, Scala). mode may be either 'dynamic' (the default) to modify executables and shared libraries or 'static' to modify static libraries .","title":"global_link_options(options, [family], [mode])"},{"location":"/user/reference/#test-rules","text":"These rules help you define automated tests that can all be run via the test target. For simple cases, you should only need the test rule, but you can also wrap your tests with a separate driver using test_driver . For cases where you only want to build the tests, not run them, you can use the tests target.","title":"Test rules"},{"location":"/user/reference/#test","text":"Availability: build.bfg Create a single test. cmd is the base command (possibly with arguments) to run; this works much like the cmd argument in the command built-in. You can also pass temporary environment variables as a dict via environment , or specify a test driver to add this test file to via driver .","title":"test(test, [environment|driver])"},{"location":"/user/reference/#test_driver","text":"Availability: build.bfg Create a test driver which can run a series of tests, specified as command-line arguments to the driver. cmd is the base command (possibly with arguments) to run; this works much like the cmd argument in the command built-in. You can also pass temporary environment variables as a dict with environment , or specify a parent test driver to wrap this driver via parent . Finally, you can specify wrap_children to determine how tests using this driver are run. If true, each test will be wrapped by env.run_arguments ; if false (the default), tests will be used as-is.","title":"test_driver(cmd, [environment|parent], [wrap_children])"},{"location":"/user/reference/#test_deps","text":"Availability: build.bfg Specify a list of extra dependencies which must be satisfied when building the tests via the tests target.","title":"test_deps(...)"},{"location":"/user/reference/#package-resolvers","text":"","title":"Package resolvers"},{"location":"/user/reference/#boost_package","text":"Availability: build.bfg Search for a Boost library. You can specify name (as a string or a list) to specify a specific Boost library (or libraries); for instance, 'program_options' . For header-only libraries, you can omit name . If version is specified, it will ensure that the installed version of Boost meets the version requirement; it must be formatted as a Python version specifier . If this function is unable to find the specified Boost library, it will raise a PackageResolutionError . If the library is found but doesn't match the required version, a PackageVersionError will be raised instead. This rule recognizes the following environment variables: BOOST_ROOT , BOOST_INCLUDEDIR , BOOST_LIBRARYDIR , CPATH , INCLUDE , LIB , LIBRARY_PATH .","title":"boost_package([name], [version])"},{"location":"/user/reference/#framework","text":"Reference a macOS framework named name with the optional suffix suffix . Though not a \"package\" in name, this can be used wherever packages are accepted.","title":"framework(name, [suffix])"},{"location":"/user/reference/#package","text":"Availability: build.bfg Search for a package named name . lang is the source language of the library ( 'c' by default); this will affect how the package is resolved. For native libraries (C, C++, Fortran, etc), this will use pkg-config to resolve the package if it's installed. Otherwise (or if pkg-config can't find the package), this will check the system's default library locations. If this function is unable to find the package, it will raise a PackageResolutionError . You can also specify kind to one of 'any' (the default), 'shared' , or 'static' . This allows you to restrict the search to find only static versions of a library, for example. If version is specified, it will (if possible) ensure that the installed version of the package meets the version requirement; it must be formatted as a Python version specifier . If this check fails, a PackageVersionError will be raised. The headers and libs arguments can be used as fallbacks when pkg-config fails to resolve the package. headers allows you to specify a header file (or list thereof) that you need to use in your source files. This will search for the header files and add the appropriate include directories to your build configuration. libs lets you list any library names that are part of this package; by default, this is set to the package's name . You can also pass None to libs in order to explicitly indicate that the library is header-only. This rule recognizes the following environment variables: CLASSPATH , CPATH , INCLUDE , LIB , LIBRARY_PATH , PKG_CONFIG . Note This function can also be used to refer to the pthread library. On many Unix-like systems, instead of using -lpthread during the link step, it's preferred to use -pthread during compilation and linking. Using package('pthread') will handle this automatically.","title":"package(name, [version], [lang], [kind], [headers], [libs])"},{"location":"/user/reference/#pkg_config","text":"Availability: build.bfg Create pkg-config information for this project and install it along with the rest of the installed files. All of these arguments are optional and will be automatically inferred from the rest of the build where possible. Unless otherwise noted, these arguments correspond directly to the fields in the pkg-config .pc file. name : The name of the package (to be used at the name of the .pc file) desc_name : A human-readable name for the package (stored as the Name field in pkg-config); defaults to name desc : A brief description of the package; defaults to name library url : A URL where users can learn more about the package version : The package's version requires : A list of packages required by this package; these can be strings, a string and version specifier, or the results from package . In the last case, packages resolved by pkg-config are added directly as requirements; those resolved by other means are added to the Libs field in pkg-config requires_private : A list of packages required by this package but not exposed to users; these can be specified as with requires conflicts : A list of packages that conflict with this package; these can be specified as with requires includes : A list of directories (or header files ) to add to the search path for users of this package libs : A list of libraries for users of this package to link to; any dependent libraries, packages, or link options (in the case of static libs) will automatically be added to libs_private , requires_private , and link_options_private , respectively libs_private : A list of libraries required by this package but not exposed to users (this is used primarily for static linking); dependent libraries, packages, and link options are added as with libs options : A list of compile options for this package link_options : A list of link options for this package link_options_private : A list of link options for this package but not exposed to users (this is used primarily for static linking) lang : The language of the builder to use when generating option strings; by default, 'c' If auto_fill is true (the default), this function will automatically fill in default values for the following fields: name : The project's name (this also fills in desc_name and desc with default values) version : The project's version , or 0.0 if none is specified includes : The list of installed header files/directories libs : The list of installed library files","title":"pkg_config([name], [desc_name], [desc], [url], [version], [requires], [requires_private], [conflicts], [includes], [libs], [libs_private], [options], [link_options], [link_options_private], [auto_fill])"},{"location":"/user/reference/#system_executable","text":"Availability: build.bfg Search for an executable named name somewhere in the system's PATH. This rule recognizes the following environment variables: PATH , PATHEXT .","title":"system_executable(name)"},{"location":"/user/reference/#environment","text":"Occasionally, build scripts need to directly query aspects of the environment. In bfg9000, this is performed with the environment object and its various members.","title":"Environment"},{"location":"/user/reference/#environment-object","text":"The environment , env , is a special object that encapsulates information about the system outside of bfg9000. It's used internally for nearly all platform-specific code, but it can also help in build.bfg (or options.bfg !) files when you encounter some unavoidable issue with multiplatform compatibility. Note This listing doesn't cover all available functions on the environment, since many are only useful to internal code. However, the most relevant ones for build.bfg files are shown below.","title":"Environment object"},{"location":"/user/reference/#env-builder","text":"Return the builder used by bfg9000 for a particular language lang .","title":"env.builder(lang)"},{"location":"/user/reference/#env-getvar","text":"Equivalent to env.variables .get(name, default) .","title":"env.getvar(name, [default])"},{"location":"/user/reference/#env-platform","text":"Return the target platform used for the build (currently the same as the host platform).","title":"env.platform"},{"location":"/user/reference/#env-run_arguments","text":"Generate the arguments needed to run the command in args . If args is a file type (or a list beginning with a file type) such as an executable , it will be prepended with the runner for lang as needed. If lang is None , the language will be determined by the language of args 's first element.","title":"env.run_arguments(args, [lang])"},{"location":"/user/reference/#env-Mode","text":"An enumeration of output modes for env.execute and env.run . Possible values are: normal : Perform no redirection and output to stdout/stderr normally pipe : Pipe the output and return it to the calling process stdout : Pipe stderr output to stdout devnull : Pipe output to /dev/null or equivalent","title":"env.Mode"},{"location":"/user/reference/#env-execute","text":"Execute the command-line arguments in args and return the output. If shell is true, args should be a string that will be interpreted by the system's shell; if not (the default), it should be a series of arguments. You can also set env to be a dictionary of environment variables to pass to the child process. If env_update is true (the default), these will be added to the environment variables in env.varables ; otherwise, env represents all the environment variables to pass to the child process. stdout and stderr are env.Mode values that describe how (or if) output should be redirected. By default, both are set to Mode.normal . Finally, returncode specifies the expected return code from the subprocess. This is 0 by default, and may be either a number, a list of numbers, or 'any' to match any return code. If the return code fails to match, a CalledProcessError will be thrown.","title":"env.execute(args, [env], [env_update], [shell], [stdout], [stderr], [returncode])"},{"location":"/user/reference/#env-run","text":"Run a command, generating any arguments needed to perform the operation. Equivalent to env.execute(env.run_arguments(arg, lang), ...) .","title":"env.run(args, [lang], [env], [env_update], [stdout], [stderr], [returncode])"},{"location":"/user/reference/#env-variables","text":"A dict of all the environment variables as they were defined when the build was first configured.","title":"env.variables"},{"location":"/user/reference/#builders","text":"Builder objects represent the toolset used to build executables and libraries for a particular source language. They can be retrieved via env.builder . While builder objects are primarily suited to bfg's internals, there are still a few useful properties for build.bfg files:","title":"Builders"},{"location":"/user/reference/#builder-flavor","text":"The \"flavor\" of the builder, i.e. the kind of command-line interface it has. Possible values are 'cc' , 'msvc' , and 'jvm' .","title":"builder.flavor"},{"location":"/user/reference/#builder-brand","text":"The brand of the builder, i.e. the command name people use for it. Currently, for languages in the C family (including Fortran), this is one of 'gcc' , 'clang' , 'msvc' , or 'unknown' . For languages in the Java family, this is one of 'oracle' , 'openjdk' , 'epfl' (for Scala), or 'unknown' .","title":"builder.brand"},{"location":"/user/reference/#builder-version","text":"The version of the builder (specifically, the version of the primary compiler for the builder). May be None if bfg9000 was unable to detect the version.","title":"builder.version"},{"location":"/user/reference/#builder-lang","text":"The language of the source files that this builder is designed for.","title":"builder.lang"},{"location":"/user/reference/#builder-object_format","text":"The object format that the builder outputs, e.g. 'elf' , 'coff' , or 'jvm' .","title":"builder.object_format"},{"location":"/user/reference/#builder-compiler","text":"The compiler used with this builder.","title":"builder.compiler"},{"location":"/user/reference/#builder-compiler","text":"The compiler used to build precompiled headers with this builder. May be None for languages or toolsets that don't support precompiled headers.","title":"builder.compiler"},{"location":"/user/reference/#builder-linker","text":"The linker used with this builder. mode is one of 'executable' , 'shared_library' , or 'static_library' Its public properties are the same as compiler . cc -like builders also support a mode of 'raw' , which returns an object representing the actual linker, such as ld .","title":"builder.linker(mode)"},{"location":"/user/reference/#builder-runner","text":"The runner used with files built by this builder (e.g. java ). This may be None for languages which have no runner, such as C and C++.","title":"builder.runner"},{"location":"/user/reference/#compilers","text":"Builder objects represent the specific used to compile a source file (generally into an object file ).","title":"Compilers"},{"location":"/user/reference/#compiler-flavor","text":"The \"flavor\" of the compiler, i.e. the kind of command-line interface it has; e.g. 'cc' , 'msvc' .","title":"compiler.flavor"},{"location":"/user/reference/#compiler-brand","text":"The brand of the compiler; typically the same as builder.brand .","title":"compiler.brand"},{"location":"/user/reference/#compiler-version","text":"The version of the compiler; typically the same as builder.version .","title":"compiler.version"},{"location":"/user/reference/#compiler-language","text":"The language of the compiler; typically the same as builder.language .","title":"compiler.language"},{"location":"/user/reference/#compiler-command","text":"The command to run when invoking this compiler, e.g. g++-4.9 .","title":"compiler.command"},{"location":"/user/reference/#platforms","text":"Platform objects represent the platform that the project is being compiled for.","title":"Platforms"},{"location":"/user/reference/#platform-flavor","text":"The \"flavor\" of the platform. Either 'posix' or 'windows' .","title":"platform.flavor"},{"location":"/user/reference/#platform-name","text":"The name of the platform, e.g. 'linux' , 'darwin' (macOS), or 'windows' .","title":"platform.name"},{"location":"/user/reference/#utilities","text":"","title":"Utilities"},{"location":"/user/reference/#argument","text":"Availability: options.bfg Define how a particular command-line argument will be parsed. names is a sequence of argument names; these will be prefixed with -- and --x- for parsing. For example, passing 'foo' will add --foo and --x-foo as possible command-line arguments. All other arguments to this function have the same behavior as in argparse.ArgumentParser.add_argument() , with the exception of action , which accepts two extra values: 'enable' : Add a pair of arguments of the form --enable- name and --disable- name (with --x- -prefixed versions as well), storing True if --enable- name is specified and False if --disable- name is. 'with' : As 'enable' , except the arguments are of the form --with- name and --without-name .","title":"argument(names..., [action], [nargs], [const], [default], [type], [choices], [required], [help], [metavar], [dest])"},{"location":"/user/reference/#argv","text":"Availability: build.bfg Retrieve the set of user-defined arguments passed to bfg9000; this is an argparse.Namespace object.","title":"argv"},{"location":"/user/reference/#95_bfg9000__","text":"Availability: build.bfg and options.bfg A dictionary containing all the builtin functions and global variables defined by bfg9000. This can be useful for feature detection or accessing builtins shadowed by a local variable.","title":"__bfg9000__"},{"location":"/user/reference/#bfg9000_required_version","text":"Availability: build.bfg and options.bfg Set the required version for bfg9000 and/or the required python_version . Each of these is a standard Python version specifier . If the actual versions don't match the specifiers, a VersionError is raised.","title":"bfg9000_required_version([version], [python_version])"},{"location":"/user/reference/#bfg9000_version","text":"Availability: build.bfg and options.bfg Return the current version of bfg9000. This can be useful if you want to optionally support a feature only available in certain versions of bfg.","title":"bfg9000_version"},{"location":"/user/reference/#filter_by_platform","text":"Availability: build.bfg Return FindResult.include if path is a filename that should be included for the target platform, and FindResult.not_now otherwise. File (or directory) names like PLATFORM or foo_PLATFORM.cpp are excluded if PLATFORM is a known platform name that doesn't match the target platform. Known platform names are: 'posix' , 'linux' , 'darwin' , 'cygwin' , 'windows' . This is the default filter for find_files .","title":"filter_by_platform(name, path, type)"},{"location":"/user/reference/#findresult","text":"Availability: build.bfg An enum to be used as the result of a filter function for find_files . The possible enum values are: include : Include this file in the results exclude : Don't include this file in the results not_now : Don't include this file in the results, but do include it in the source distribution","title":"FindResult"},{"location":"/user/reference/#find_files","text":"Availability: build.bfg Find files in path whose name matches the glob (or list of globs) name . The following arguments may be specified: path : A path (or list of paths) to start the search in; if omitted, search in the root of the source directory ( '.' ) name : A glob (or list of globs) to match files; if omitted, all files match (equivalent to '*' ) type : A filter for the type of file: 'f' to find only files, 'd' to find only directories, or '*' to find either extra : A glob (or list of globs) to match extra files (which will not be returned from find_files but will be added to the source distribution ) exclude : A glob (or list of globs) of files to exclude from results; by default, .#* , *~ , and #*# are exluded flat : If true, find_files will not recurse into subdirectories; otherwise, (the default) it will filter : A predicate taking a filename, relative path, and file type, and returning a FindResult which will filter the results; by default, this is filter_by_platform cache : If true (the default), cache the results so that any changes to will regenerate the build scripts for the project dist : If true (the default), all files found by this function will automatically be added to the source distribution as_object : If true, results will be returned as file or directory objects; otherwise (the default), return path strings The cache argument is particularly important. It allows you to add or remove source files and not have to worry about manually rerunning bfg9000.","title":"find_files([path], [name], [type], [extra], [exclude], [flat], [filter], [cache], [dist], [as_object])"},{"location":"/user/reference/#project","text":"Availability: build.bfg Set the name (and optionally the version) of the project. If you don't call this function to specify a project name, it defaults to the name of the project's source directory. This is primarily useful for creating source distributions .","title":"project(name, [version])"},{"location":"/user/reference/#exceptions","text":"","title":"Exceptions"},{"location":"/user/reference/#calledprocesserror","text":"Availability: build.bfg and options.bfg An exception raised when a subprocess fails to execute successfully. This is just an alias for the standard Python error subprocess.CalledProcessError .","title":"CalledProcessError"},{"location":"/user/reference/#packageresolutionerror","text":"Availability: build.bfg and options.bfg An exception raised when a package resolution function is unable to find the specified package.","title":"PackageResolutionError"},{"location":"/user/reference/#packageversionerror","text":"Availability: build.bfg and options.bfg An exception raised when a package resolution function found the specified package, but its version doesn't match the version specifier. Derived from both PackageResolutionError and VersionError .","title":"PackageVersionError"},{"location":"/user/reference/#versionerror","text":"Availability: build.bfg and options.bfg An exception raised when a version fails to match the supplied version specifier.","title":"VersionError"},{"location":"/user/command-line/","text":"Command-Line Reference \u00a7 Global options \u00a7 -h, --help \u00a7 Print a help message and exit. Equivalent to the help subcommand. --version \u00a7 Print the version number and exit. -c, --color WHEN \u00a7 Show colored output; WHEN is one of always , never , or auto and defaults to auto (i.e. show colored output when the terminal is a tty). -c is equivalent to --color=always . --warn-once \u00a7 Only emit a given warning once. Sub-commands \u00a7 bfg9000 help [ SUBCOMMAND ] \u00a7 Print a help message and exit. If SUBCOMMAND is specified, print help for that subcommand. bfg9000 configure DIRECTORY \u00a7 Generate the necessary build files to perform actual builds. If DIRECTORY is a source directory (i.e. it contains a build.bfg file), the build files will be created in the current directory. Otherwise, DIRECTORY is treated as the build directory, and bfg9000 will look for a build.bfg file in the current directory. --backend BACKEND \u00a7 The kind of build files to generate; one of ninja , make , or msbuild . The default value depends on what build backends you have installed, but if ninja is present on your system, it will be the default. --enable-shared, --disable-shared \u00a7 Enable/disable building shared libraries when using library () in your build.bfg files. Defaults to enabled. --enable-static, --disable-static \u00a7 Enable/disable building static libraries when using library () in your build.bfg files. Defaults to enabled. --prefix PATH \u00a7 The installation prefix to use when installing built files. On Linux and macOS, this defaults to /usr/local ; on Windows, there is no default (thus, to install built files on Windows, you must either set --prefix or one of the other install path options below). --exec-prefix PATH \u00a7 The installation prefix to use when installing architecture-dependent files (e.g. executables). This defaults to the value of --prefix . --bindir PATH \u00a7 The installation prefix to use for executables. Defaults to prefix /bin on Linux and macOS, and prefix on Windows. --libdir PATH \u00a7 The installation prefix to use for libraries. Defaults to prefix /lib on Linux and macOS, and prefix on Windows. --includedir PATH \u00a7 The installation prefix to use for headers. Defaults to prefix /include on Linux and macOS, and prefix on Windows. bfg9000 configure-into SRCDIR BUILDDIR \u00a7 Generate the necessary build files (as with bfg9000 configure ) to perform actual builds from a build.bfg file in SRCDIR , and place them in BUILDDIR . bfg9000 refresh [ BUILDDIR ] \u00a7 Regenerate an existing set of build files in BUILDDIR needed to perform actual builds. This is run automatically if bfg9000 determines that the build files are out of date. bfg9000 env [ BUILDDIR ] \u00a7 Print the environment variables stored by the build configuration in BUILDDIR . -u, --unique \u00a7 Only show environment variables that differ from the current environment. 9k shorthand \u00a7 9k is a special shorthand to make it easier to configure your build. It's equivalent to bfg9000 configure .","title":"Command-Line Reference"},{"location":"/user/command-line/#command-line-reference","text":"","title":"Command-Line Reference"},{"location":"/user/command-line/#global-options","text":"","title":"Global options"},{"location":"/user/command-line/#help-option","text":"Print a help message and exit. Equivalent to the help subcommand.","title":"-h, --help"},{"location":"/user/command-line/#version","text":"Print the version number and exit.","title":"--version"},{"location":"/user/command-line/#color","text":"Show colored output; WHEN is one of always , never , or auto and defaults to auto (i.e. show colored output when the terminal is a tty). -c is equivalent to --color=always .","title":"-c, --color WHEN"},{"location":"/user/command-line/#warn-once","text":"Only emit a given warning once.","title":"--warn-once"},{"location":"/user/command-line/#sub-commands","text":"","title":"Sub-commands"},{"location":"/user/command-line/#help","text":"Print a help message and exit. If SUBCOMMAND is specified, print help for that subcommand.","title":"bfg9000 help [SUBCOMMAND]"},{"location":"/user/command-line/#configure","text":"Generate the necessary build files to perform actual builds. If DIRECTORY is a source directory (i.e. it contains a build.bfg file), the build files will be created in the current directory. Otherwise, DIRECTORY is treated as the build directory, and bfg9000 will look for a build.bfg file in the current directory.","title":"bfg9000 configure DIRECTORY"},{"location":"/user/command-line/#configure-backend","text":"The kind of build files to generate; one of ninja , make , or msbuild . The default value depends on what build backends you have installed, but if ninja is present on your system, it will be the default.","title":"--backend BACKEND"},{"location":"/user/command-line/#configure-enable-shared","text":"Enable/disable building shared libraries when using library () in your build.bfg files. Defaults to enabled.","title":"--enable-shared, --disable-shared"},{"location":"/user/command-line/#configure-enable-static","text":"Enable/disable building static libraries when using library () in your build.bfg files. Defaults to enabled.","title":"--enable-static, --disable-static"},{"location":"/user/command-line/#configure-prefix","text":"The installation prefix to use when installing built files. On Linux and macOS, this defaults to /usr/local ; on Windows, there is no default (thus, to install built files on Windows, you must either set --prefix or one of the other install path options below).","title":"--prefix PATH"},{"location":"/user/command-line/#configure-exec-prefix","text":"The installation prefix to use when installing architecture-dependent files (e.g. executables). This defaults to the value of --prefix .","title":"--exec-prefix PATH"},{"location":"/user/command-line/#configure-bindir","text":"The installation prefix to use for executables. Defaults to prefix /bin on Linux and macOS, and prefix on Windows.","title":"--bindir PATH"},{"location":"/user/command-line/#configure-libdir","text":"The installation prefix to use for libraries. Defaults to prefix /lib on Linux and macOS, and prefix on Windows.","title":"--libdir PATH"},{"location":"/user/command-line/#configure-includedir","text":"The installation prefix to use for headers. Defaults to prefix /include on Linux and macOS, and prefix on Windows.","title":"--includedir PATH"},{"location":"/user/command-line/#configure-into","text":"Generate the necessary build files (as with bfg9000 configure ) to perform actual builds from a build.bfg file in SRCDIR , and place them in BUILDDIR .","title":"bfg9000 configure-into SRCDIR BUILDDIR"},{"location":"/user/command-line/#refresh","text":"Regenerate an existing set of build files in BUILDDIR needed to perform actual builds. This is run automatically if bfg9000 determines that the build files are out of date.","title":"bfg9000 refresh [BUILDDIR]"},{"location":"/user/command-line/#env","text":"Print the environment variables stored by the build configuration in BUILDDIR .","title":"bfg9000 env [BUILDDIR]"},{"location":"/user/command-line/#env-unique","text":"Only show environment variables that differ from the current environment.","title":"-u, --unique"},{"location":"/user/command-line/#9k-shorthand","text":"9k is a special shorthand to make it easier to configure your build. It's equivalent to bfg9000 configure .","title":"9k shorthand"},{"location":"/user/environment-vars/","text":"Environment Variables \u00a7 bfg9000 reads from a number of environment variables. These are the primary way in which users can customize parts of a specific build, e.g. by changing the tools to use or adding compiler flags. Below is a full list of all the environment variables bfg9000 recognizes. Compilation variables \u00a7 Generic \u00a7 CPPFLAGS \u00a7 Default: none \"C preprocessor flags\"; command line arguments to pass to the compiler when compiling any C-family source file (C, C++, Objective C/C++). C \u00a7 CC \u00a7 Default: cc (POSIX), cl (Windows) The command to use when compiling C source files. Also the command to use with cc-style toolchains when linking object files whose source is in C. CFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any C source file. C++ \u00a7 CXX \u00a7 Default: c++ (POSIX), cl (Windows) The command to use when compiling C++ source files. Also the command to use with cc-style toolchains when linking object files whose source is in C++. CXXFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any C++ source file. Fortran \u00a7 FC \u00a7 Default: gfortran The command to use when compiling Fortran source files. Also the command to use when linking object files whose source is in Fortran. FFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Fortran source file. Java \u00a7 JAVAC \u00a7 Default: javac The command to use when compiling Java source files. JAVAFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Java source file. Objective C \u00a7 OBJC \u00a7 Default: cc The command to use when compiling Objective C source files. Also the command to use with cc-style toolchains when linking object files whose source is in Objective C. OBJCFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Objective C source file. Objective C++ \u00a7 OBJCXX \u00a7 Default: c++ The command to use when compiling Objective C++ source files. Also the command to use with cc-style toolchains when linking object files whose source is in Objective C++. OBJCXXFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Objective C++ source file. Scala \u00a7 SCALAC \u00a7 Default: scalac The command to use when compiling Scala source files. SCALAFLAGS \u00a7 Default: none Command line arguments to pass to the compiler when compiling any Scala source file. Linking variables \u00a7 Static linking \u00a7 AR \u00a7 Default: ar POSIX-only . The command to use when creating static libraries from object files. ARFLAGS \u00a7 Default: cru POSIX-only . The arguments to pass to the static library builder (typically ar ). JAR \u00a7 Default: jar The command to use when creating .jar files for JVM-based binaries. LIBFLAGS \u00a7 Default: none Windows-only . Command line arguments to pass to the static library builder (typically lib ). VCLIB \u00a7 Default: lib MSVC-only . The command to use when creating static libraries. Dynamic linking \u00a7 LDFLAGS \u00a7 Default: none Command line arguments to pass to the linker when linking an executable or shared library. LDLIBS \u00a7 Default: none Additional libraries to link into an executable or shared library. This is mainly useful for cases where a system library (e.g. the C++ Standard Library implementation) requires another library to be explicitly linked with it. VCLINK \u00a7 Default: link MSVC-only . The command to use when linking shared libraries. Execution variables \u00a7 JAVACMD \u00a7 Default: java The command to use when running Java .class files or .jar s. (Does not apply when building with GCJ.) LUA \u00a7 Default: lua The command to use when running Lua scripts. PERL \u00a7 Default: perl The command to use when running Perl scripts. PYTHON \u00a7 Default: sys.executable The command to use when running Python scripts. By default, this is the interpreter used to run bfg9000. RUBY \u00a7 Default: ruby The command to use when running Ruby scripts. SCALACMD \u00a7 Default: scala The command to use when running Scala .class files or .jar s. Packaging variables \u00a7 BOOST_ROOT \u00a7 Default: none The root directory where Boost headers and libraries are stored (as $BOOST_ROOT/include and $BOOST_ROOT/lib , respectively). BOOST_INCLUDEDIR \u00a7 Default: none The root directory where Boost headers are stored. This takes precedence over BOOST_ROOT . BOOST_LIBRARYDIR \u00a7 Default: none The root directory where Boost libraries are stored. This takes precedence over BOOST_ROOT . CLASSPATH \u00a7 Default: none A list of additional directories to search for Java class files. On POSIX systems, this is delimited by : ; on Windows, by ; . CPATH \u00a7 Default: none A list of additional directories to search for headers. On POSIX systems, this is delimited by : ; on Windows, by ; . INCLUDE \u00a7 Default: none MSVC-only . A list of directories to search for headers, delimited by ; . LIB \u00a7 Default: none MSVC-only . A list of directories to search for system libraries , delimited by ; . LIBRARY_PATH \u00a7 Default: none A list of additional directories to search for system libraries . On POSIX systems, this is delimited by : ; on Windows, by ; . PATH \u00a7 Default: none A list of directories to search for system executables . On POSIX systems, this is delimited by : ; on Windows, by ; . PATHEXT \u00a7 Default: none Windows-only . A list of valid extensions for executable files under Windows, separated by ; . PKG_CONFIG \u00a7 Default: pkg_config The command to use when fetching pkg-config package information. Command variables \u00a7 BFG9000 \u00a7 Default: /path/to/bfg9000 The command to use when executing bfg9000 (e.g. when regenerating the build scripts because the list of source files has changed). This should only be necessary if you run bfg9000 from a wrapper script. DEPFIXER \u00a7 Default: /path/to/bfg9000-depfixer The command to use when fixing up depfiles generated by your compiler for the Make backend. In general, you shouldn't need to touch this. DOPPEL \u00a7 Default: doppel The command to use when installing files and building source distributions. For more information about doppel, see its documentation . INSTALL_NAME_TOOL \u00a7 Default: install_name_tool Darwin-only . The command to use when modifying the paths of the shared libraries linked to during installation. MKDIR_P \u00a7 Default: mkdir -p The command to use when making a directory tree. This is used both for installing whole directories of files and for creating build directories under the Make backend. PATCHELF \u00a7 Default: patchelf Linux-only . The command to use when patching an ELF file's rpath for installation. SETENV \u00a7 Default: /path/to/bfg9000-setenv Windows-only . The command to use when setting temporary environment variables, similar to the POSIX env command. This is used when setting environment variables for tests. System variables \u00a7 DESTDIR \u00a7 Default: none POSIX-only . A directory to prepend to the install location for the project, used in performing staged installs. For more information, see the GNU coding standards . PLATFORM \u00a7 Default: Win32 Windows-only . The platform type to use when generating MSBuild files. VISUALSTUDIOVERSION \u00a7 Default: 14.0 Windows-only . The version of Visual Studio to target when generating MSBuild files.","title":"Environment Variables"},{"location":"/user/environment-vars/#environment-variables","text":"bfg9000 reads from a number of environment variables. These are the primary way in which users can customize parts of a specific build, e.g. by changing the tools to use or adding compiler flags. Below is a full list of all the environment variables bfg9000 recognizes.","title":"Environment Variables"},{"location":"/user/environment-vars/#compilation-variables","text":"","title":"Compilation variables"},{"location":"/user/environment-vars/#generic","text":"","title":"Generic"},{"location":"/user/environment-vars/#cppflags","text":"Default: none \"C preprocessor flags\"; command line arguments to pass to the compiler when compiling any C-family source file (C, C++, Objective C/C++).","title":"CPPFLAGS"},{"location":"/user/environment-vars/#c","text":"","title":"C"},{"location":"/user/environment-vars/#cc","text":"Default: cc (POSIX), cl (Windows) The command to use when compiling C source files. Also the command to use with cc-style toolchains when linking object files whose source is in C.","title":"CC"},{"location":"/user/environment-vars/#cflags","text":"Default: none Command line arguments to pass to the compiler when compiling any C source file.","title":"CFLAGS"},{"location":"/user/environment-vars/#c_1","text":"","title":"C++"},{"location":"/user/environment-vars/#cxx","text":"Default: c++ (POSIX), cl (Windows) The command to use when compiling C++ source files. Also the command to use with cc-style toolchains when linking object files whose source is in C++.","title":"CXX"},{"location":"/user/environment-vars/#cxxflags","text":"Default: none Command line arguments to pass to the compiler when compiling any C++ source file.","title":"CXXFLAGS"},{"location":"/user/environment-vars/#fortran","text":"","title":"Fortran"},{"location":"/user/environment-vars/#fc","text":"Default: gfortran The command to use when compiling Fortran source files. Also the command to use when linking object files whose source is in Fortran.","title":"FC"},{"location":"/user/environment-vars/#fflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Fortran source file.","title":"FFLAGS"},{"location":"/user/environment-vars/#java","text":"","title":"Java"},{"location":"/user/environment-vars/#javac","text":"Default: javac The command to use when compiling Java source files.","title":"JAVAC"},{"location":"/user/environment-vars/#javaflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Java source file.","title":"JAVAFLAGS"},{"location":"/user/environment-vars/#objective-c","text":"","title":"Objective C"},{"location":"/user/environment-vars/#objc","text":"Default: cc The command to use when compiling Objective C source files. Also the command to use with cc-style toolchains when linking object files whose source is in Objective C.","title":"OBJC"},{"location":"/user/environment-vars/#objcflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Objective C source file.","title":"OBJCFLAGS"},{"location":"/user/environment-vars/#objective-c_1","text":"","title":"Objective C++"},{"location":"/user/environment-vars/#objcxx","text":"Default: c++ The command to use when compiling Objective C++ source files. Also the command to use with cc-style toolchains when linking object files whose source is in Objective C++.","title":"OBJCXX"},{"location":"/user/environment-vars/#objcxxflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Objective C++ source file.","title":"OBJCXXFLAGS"},{"location":"/user/environment-vars/#scala","text":"","title":"Scala"},{"location":"/user/environment-vars/#scalac","text":"Default: scalac The command to use when compiling Scala source files.","title":"SCALAC"},{"location":"/user/environment-vars/#scalaflags","text":"Default: none Command line arguments to pass to the compiler when compiling any Scala source file.","title":"SCALAFLAGS"},{"location":"/user/environment-vars/#linking-variables","text":"","title":"Linking variables"},{"location":"/user/environment-vars/#static-linking","text":"","title":"Static linking"},{"location":"/user/environment-vars/#ar","text":"Default: ar POSIX-only . The command to use when creating static libraries from object files.","title":"AR"},{"location":"/user/environment-vars/#arflags","text":"Default: cru POSIX-only . The arguments to pass to the static library builder (typically ar ).","title":"ARFLAGS"},{"location":"/user/environment-vars/#jar","text":"Default: jar The command to use when creating .jar files for JVM-based binaries.","title":"JAR"},{"location":"/user/environment-vars/#libflags","text":"Default: none Windows-only . Command line arguments to pass to the static library builder (typically lib ).","title":"LIBFLAGS"},{"location":"/user/environment-vars/#vclib","text":"Default: lib MSVC-only . The command to use when creating static libraries.","title":"VCLIB"},{"location":"/user/environment-vars/#dynamic-linking","text":"","title":"Dynamic linking"},{"location":"/user/environment-vars/#ldflags","text":"Default: none Command line arguments to pass to the linker when linking an executable or shared library.","title":"LDFLAGS"},{"location":"/user/environment-vars/#ldlibs","text":"Default: none Additional libraries to link into an executable or shared library. This is mainly useful for cases where a system library (e.g. the C++ Standard Library implementation) requires another library to be explicitly linked with it.","title":"LDLIBS"},{"location":"/user/environment-vars/#vclink","text":"Default: link MSVC-only . The command to use when linking shared libraries.","title":"VCLINK"},{"location":"/user/environment-vars/#execution-variables","text":"","title":"Execution variables"},{"location":"/user/environment-vars/#javacmd","text":"Default: java The command to use when running Java .class files or .jar s. (Does not apply when building with GCJ.)","title":"JAVACMD"},{"location":"/user/environment-vars/#lua","text":"Default: lua The command to use when running Lua scripts.","title":"LUA"},{"location":"/user/environment-vars/#perl","text":"Default: perl The command to use when running Perl scripts.","title":"PERL"},{"location":"/user/environment-vars/#python","text":"Default: sys.executable The command to use when running Python scripts. By default, this is the interpreter used to run bfg9000.","title":"PYTHON"},{"location":"/user/environment-vars/#ruby","text":"Default: ruby The command to use when running Ruby scripts.","title":"RUBY"},{"location":"/user/environment-vars/#scalacmd","text":"Default: scala The command to use when running Scala .class files or .jar s.","title":"SCALACMD"},{"location":"/user/environment-vars/#packaging-variables","text":"","title":"Packaging variables"},{"location":"/user/environment-vars/#boost_root","text":"Default: none The root directory where Boost headers and libraries are stored (as $BOOST_ROOT/include and $BOOST_ROOT/lib , respectively).","title":"BOOST_ROOT"},{"location":"/user/environment-vars/#boost_includedir","text":"Default: none The root directory where Boost headers are stored. This takes precedence over BOOST_ROOT .","title":"BOOST_INCLUDEDIR"},{"location":"/user/environment-vars/#boost_librarydir","text":"Default: none The root directory where Boost libraries are stored. This takes precedence over BOOST_ROOT .","title":"BOOST_LIBRARYDIR"},{"location":"/user/environment-vars/#classpath","text":"Default: none A list of additional directories to search for Java class files. On POSIX systems, this is delimited by : ; on Windows, by ; .","title":"CLASSPATH"},{"location":"/user/environment-vars/#cpath","text":"Default: none A list of additional directories to search for headers. On POSIX systems, this is delimited by : ; on Windows, by ; .","title":"CPATH"},{"location":"/user/environment-vars/#include","text":"Default: none MSVC-only . A list of directories to search for headers, delimited by ; .","title":"INCLUDE"},{"location":"/user/environment-vars/#lib","text":"Default: none MSVC-only . A list of directories to search for system libraries , delimited by ; .","title":"LIB"},{"location":"/user/environment-vars/#library_path","text":"Default: none A list of additional directories to search for system libraries . On POSIX systems, this is delimited by : ; on Windows, by ; .","title":"LIBRARY_PATH"},{"location":"/user/environment-vars/#path","text":"Default: none A list of directories to search for system executables . On POSIX systems, this is delimited by : ; on Windows, by ; .","title":"PATH"},{"location":"/user/environment-vars/#pathext","text":"Default: none Windows-only . A list of valid extensions for executable files under Windows, separated by ; .","title":"PATHEXT"},{"location":"/user/environment-vars/#pkg_config","text":"Default: pkg_config The command to use when fetching pkg-config package information.","title":"PKG_CONFIG"},{"location":"/user/environment-vars/#command-variables","text":"","title":"Command variables"},{"location":"/user/environment-vars/#bfg9000","text":"Default: /path/to/bfg9000 The command to use when executing bfg9000 (e.g. when regenerating the build scripts because the list of source files has changed). This should only be necessary if you run bfg9000 from a wrapper script.","title":"BFG9000"},{"location":"/user/environment-vars/#depfixer","text":"Default: /path/to/bfg9000-depfixer The command to use when fixing up depfiles generated by your compiler for the Make backend. In general, you shouldn't need to touch this.","title":"DEPFIXER"},{"location":"/user/environment-vars/#doppel","text":"Default: doppel The command to use when installing files and building source distributions. For more information about doppel, see its documentation .","title":"DOPPEL"},{"location":"/user/environment-vars/#install_name_tool","text":"Default: install_name_tool Darwin-only . The command to use when modifying the paths of the shared libraries linked to during installation.","title":"INSTALL_NAME_TOOL"},{"location":"/user/environment-vars/#mkdir_p","text":"Default: mkdir -p The command to use when making a directory tree. This is used both for installing whole directories of files and for creating build directories under the Make backend.","title":"MKDIR_P"},{"location":"/user/environment-vars/#patchelf","text":"Default: patchelf Linux-only . The command to use when patching an ELF file's rpath for installation.","title":"PATCHELF"},{"location":"/user/environment-vars/#setenv","text":"Default: /path/to/bfg9000-setenv Windows-only . The command to use when setting temporary environment variables, similar to the POSIX env command. This is used when setting environment variables for tests.","title":"SETENV"},{"location":"/user/environment-vars/#system-variables","text":"","title":"System variables"},{"location":"/user/environment-vars/#destdir","text":"Default: none POSIX-only . A directory to prepend to the install location for the project, used in performing staged installs. For more information, see the GNU coding standards .","title":"DESTDIR"},{"location":"/user/environment-vars/#platform","text":"Default: Win32 Windows-only . The platform type to use when generating MSBuild files.","title":"PLATFORM"},{"location":"/user/environment-vars/#visualstudioversion","text":"Default: 14.0 Windows-only . The version of Visual Studio to target when generating MSBuild files.","title":"VISUALSTUDIOVERSION"},{"location":"/developer/backends/","text":"Build Backends \u00a7 bfg9000 supports generating files for multiple build tools, called \"backends\". These are specified in the bfg9000.backends entry point ; third parties can add support for their own backend by hooking into this. Warning Currently, custom build steps aren't supported as builtins ; however, support is planned, and any third-party backend will need to decide which (if any) custom build steps they'd like to support. How a build.bfg file is compiled \u00a7 Before we get started looking at how each bakend works, let's quickly go over how a build.bfg file is compiled at a high level. At its core, a build file is just a DAG (directed acyclic graph) that gets walked through by the build system, where the nodes are files and the edges are build steps. A bfg9000 build file is no different. Snapshot the environment \u00a7 When bfg9000 is invoked, it first takes a snapshot of the current environment (the operating system, environment variables, compiler to use, etc). This is important to provide a stable state for regeneration of the build file if necessary (e.g. if build.bfg is changed). Build an internal dependency graph \u00a7 Next, it executes the build.bfg file. Most bfg9000 functions represent build steps or other related parts of the dependency graph. When called, these build up an internal DAG structure with all the backend-agnostic data filled in (e.g. virtual filenames are resolved to real ones, such as \"foo\" to \"libfoo.so\"). Emit the final build file \u00a7 Once this is complete, the DAG is passed to the appropriate backend, which iterates over all the known edges (build steps) and emits the backend-specific code for them. Since all the backends handle walking the DAG on their own, bfg9000 can safely avoid worrying about trying to do this efficiently in Python. Public API for backends \u00a7 backend.write( env , build_inputs ) \u00a7 Called when bfg9000 has finished building its internal dependency graph and it's time to generate the backend-specific build files. env is an Environment object and build_inputs is a BuildInputs object containing the internal dependency graph. build_inputs.edges() returns a list of Edge s that correspond to each build step defined in the build.bfg file. backend.priority \u00a7 The priority of this build backend. This helps determine the default backend. The default is the backend with the highest priority that's also \"valid\" (i.e. backend.version() returns a non- None value). backend.version() \u00a7 Return the version (as a packaging.LegacyVersion object -- also aliased as bfg9000.versioning.Version ) of this build backend's underlying tool. If the tool can't be found (or is otherwise broken), this returns None .","title":"Build Backends"},{"location":"/developer/backends/#build-backends","text":"bfg9000 supports generating files for multiple build tools, called \"backends\". These are specified in the bfg9000.backends entry point ; third parties can add support for their own backend by hooking into this. Warning Currently, custom build steps aren't supported as builtins ; however, support is planned, and any third-party backend will need to decide which (if any) custom build steps they'd like to support.","title":"Build Backends"},{"location":"/developer/backends/#how-a-buildbfg-file-is-compiled","text":"Before we get started looking at how each bakend works, let's quickly go over how a build.bfg file is compiled at a high level. At its core, a build file is just a DAG (directed acyclic graph) that gets walked through by the build system, where the nodes are files and the edges are build steps. A bfg9000 build file is no different.","title":"How a build.bfg file is compiled"},{"location":"/developer/backends/#snapshot-the-environment","text":"When bfg9000 is invoked, it first takes a snapshot of the current environment (the operating system, environment variables, compiler to use, etc). This is important to provide a stable state for regeneration of the build file if necessary (e.g. if build.bfg is changed).","title":"Snapshot the environment"},{"location":"/developer/backends/#build-an-internal-dependency-graph","text":"Next, it executes the build.bfg file. Most bfg9000 functions represent build steps or other related parts of the dependency graph. When called, these build up an internal DAG structure with all the backend-agnostic data filled in (e.g. virtual filenames are resolved to real ones, such as \"foo\" to \"libfoo.so\").","title":"Build an internal dependency graph"},{"location":"/developer/backends/#emit-the-final-build-file","text":"Once this is complete, the DAG is passed to the appropriate backend, which iterates over all the known edges (build steps) and emits the backend-specific code for them. Since all the backends handle walking the DAG on their own, bfg9000 can safely avoid worrying about trying to do this efficiently in Python.","title":"Emit the final build file"},{"location":"/developer/backends/#public-api-for-backends","text":"","title":"Public API for backends"},{"location":"/developer/backends/#backend-write","text":"Called when bfg9000 has finished building its internal dependency graph and it's time to generate the backend-specific build files. env is an Environment object and build_inputs is a BuildInputs object containing the internal dependency graph. build_inputs.edges() returns a list of Edge s that correspond to each build step defined in the build.bfg file.","title":"backend.write(env, build_inputs)"},{"location":"/developer/backends/#backend-priority","text":"The priority of this build backend. This helps determine the default backend. The default is the backend with the highest priority that's also \"valid\" (i.e. backend.version() returns a non- None value).","title":"backend.priority"},{"location":"/developer/backends/#backend-version","text":"Return the version (as a packaging.LegacyVersion object -- also aliased as bfg9000.versioning.Version ) of this build backend's underlying tool. If the tool can't be found (or is otherwise broken), this returns None .","title":"backend.version()"},{"location":"/developer/tools/","text":"Build Tools \u00a7 Note Build tools aren't currently extendable by third parties. However, this is planned . As a build configuration system, bfg9000 naturally interacts with many other tools; this interaction is defined for each tool in bfg9000/tools/ ; each file is automatically imported and the tools are added to a dict ultimately used by the environment object . Decorators \u00a7 @builder( lang , ...) \u00a7 Define a builder for one or more lang s. The API for builders is somewhat complex and currently beyond the scope of this document. @tool( name , [ lang ]) \u00a7 Define a tool named name that optionally acts as a runner for files with the language lang . The API for tools is somewhat complex and currently beyond the scope of this document. Accessors \u00a7 get_builder( env , lang ) \u00a7 Get the builder associated with lang , passing env (and lang if the builder was defined for multiple languages) to the builder type. get_tool( env , name ) \u00a7 Get the tool named name , passing env to the tool type. get_tool_runner( lang ) \u00a7 Get the name of the tool specified to run files with language lang .","title":"Build Tools"},{"location":"/developer/tools/#build-tools","text":"Note Build tools aren't currently extendable by third parties. However, this is planned . As a build configuration system, bfg9000 naturally interacts with many other tools; this interaction is defined for each tool in bfg9000/tools/ ; each file is automatically imported and the tools are added to a dict ultimately used by the environment object .","title":"Build Tools"},{"location":"/developer/tools/#decorators","text":"","title":"Decorators"},{"location":"/developer/tools/#builderlang","text":"Define a builder for one or more lang s. The API for builders is somewhat complex and currently beyond the scope of this document.","title":"@builder(lang, ...)"},{"location":"/developer/tools/#toolname-lang","text":"Define a tool named name that optionally acts as a runner for files with the language lang . The API for tools is somewhat complex and currently beyond the scope of this document.","title":"@tool(name, [lang])"},{"location":"/developer/tools/#accessors","text":"","title":"Accessors"},{"location":"/developer/tools/#get_builderenv-lang","text":"Get the builder associated with lang , passing env (and lang if the builder was defined for multiple languages) to the builder type.","title":"get_builder(env, lang)"},{"location":"/developer/tools/#get_toolenv-name","text":"Get the tool named name , passing env to the tool type.","title":"get_tool(env, name)"},{"location":"/developer/tools/#get_tool_runnerlang","text":"Get the name of the tool specified to run files with language lang .","title":"get_tool_runner(lang)"},{"location":"/developer/builtins/","text":"Builtins \u00a7 Note Builtins aren't currently extendable by third parties. However, this is planned . bfg9000 provides a set of builtin functions, classes, and variables to build scripts so that projects can easily describe their build process. These are all defined in bfg9000/builtins/ ; each file is automatically imported and its builtins are added to a dict of globals to pass to build.bfg . Decorators \u00a7 Builtins are defined by using decorators defined in bfg9000.builtins.builtin ; by default, these make the decorated object available to build.bfg , but you can also specify the context to change where the object is available: 'build' for build.bfg files, 'options' for options.bfg files, and '*' for all files. These decorators also accept a list of internal global variables to be passed to the decorated function. For build contexts, valid globals are build_inputs , env , and argv ; for options contexts, env and parser . @function( global , ..., [ context ]) \u00a7 Define a function (or other callable object, including a type) as a builtin with the specified global s passed as the initial arguments to the function. @getter( global , ..., [ context ]) \u00a7 Define a getter function as a builtin with the specified global s passed as the initial arguments to the function. @post( global , ..., [ context ]) \u00a7 Define a function to be run after the user's build script ( build.bfg or options.bfg , depending on context ) is executed. @type( out_type , [ in_type ]) \u00a7 Define the return type of the decorated function as out_type and accepting automatic conversion of any object of in_type (either a type or tuple of types, defaulting to string_types ) as the first argument. This is primarily useful for autoconversion of strings to the corresponding object for one of a build step's arguments (e.g. converting 'foo.cpp' to a SourceFile ).","title":"Builtins"},{"location":"/developer/builtins/#builtins","text":"Note Builtins aren't currently extendable by third parties. However, this is planned . bfg9000 provides a set of builtin functions, classes, and variables to build scripts so that projects can easily describe their build process. These are all defined in bfg9000/builtins/ ; each file is automatically imported and its builtins are added to a dict of globals to pass to build.bfg .","title":"Builtins"},{"location":"/developer/builtins/#decorators","text":"Builtins are defined by using decorators defined in bfg9000.builtins.builtin ; by default, these make the decorated object available to build.bfg , but you can also specify the context to change where the object is available: 'build' for build.bfg files, 'options' for options.bfg files, and '*' for all files. These decorators also accept a list of internal global variables to be passed to the decorated function. For build contexts, valid globals are build_inputs , env , and argv ; for options contexts, env and parser .","title":"Decorators"},{"location":"/developer/builtins/#function","text":"Define a function (or other callable object, including a type) as a builtin with the specified global s passed as the initial arguments to the function.","title":"@function(global, ..., [context])"},{"location":"/developer/builtins/#getter","text":"Define a getter function as a builtin with the specified global s passed as the initial arguments to the function.","title":"@getter(global, ..., [context])"},{"location":"/developer/builtins/#post","text":"Define a function to be run after the user's build script ( build.bfg or options.bfg , depending on context ) is executed.","title":"@post(global, ..., [context])"},{"location":"/developer/builtins/#type","text":"Define the return type of the decorated function as out_type and accepting automatic conversion of any object of in_type (either a type or tuple of types, defaulting to string_types ) as the first argument. This is primarily useful for autoconversion of strings to the corresponding object for one of a build step's arguments (e.g. converting 'foo.cpp' to a SourceFile ).","title":"@type(out_type, [in_type])"},{"location":"/developer/contributing/","text":"Contributing \u00a7 So, you'd like to help improve bfg9000 by writing a patch? Great! This page will provide you with some useful information to help you get started. Running tests \u00a7 bfg9000 has a suite of tests to ensure that everything works properly. (Well, everything that has tests!) As you may expect, you can run these via: $ python setup.py test If you'd like to run a subset of tests, such as when trying to fix a bug in a specific area of the code, you can limit the tests that get run. For instance, to run only the tests in test/integration/test_simple.py , you can type: $ python setup.py test -s test.integration.test_simple Linting code \u00a7 bfg9000 uses flake8 for linting. Since users generally don't need to worry about linting the codebase, this isn't automatically installed by setup.py. You'll need to install it yourself. Once installed, you can use the lint command like so: $ python setup.py lint","title":"Contributing"},{"location":"/developer/contributing/#contributing","text":"So, you'd like to help improve bfg9000 by writing a patch? Great! This page will provide you with some useful information to help you get started.","title":"Contributing"},{"location":"/developer/contributing/#running-tests","text":"bfg9000 has a suite of tests to ensure that everything works properly. (Well, everything that has tests!) As you may expect, you can run these via: $ python setup.py test If you'd like to run a subset of tests, such as when trying to fix a bug in a specific area of the code, you can limit the tests that get run. For instance, to run only the tests in test/integration/test_simple.py , you can type: $ python setup.py test -s test.integration.test_simple","title":"Running tests"},{"location":"/developer/contributing/#linting-code","text":"bfg9000 uses flake8 for linting. Since users generally don't need to worry about linting the codebase, this isn't automatically installed by setup.py. You'll need to install it yourself. Once installed, you can use the lint command like so: $ python setup.py lint","title":"Linting code"},{"location":"/about/changes/","text":"Changes \u00a7 v0.3.0 \u00a7 2018-06-01 New features \u00a7 Replace system_package() and pkgconfig_package() with a generic package resolver: package() Add headers argument to package() to find header files and libs to specify library names if pkg-config lookup fails Support Java/Scala Add support for user-defined arguments Add a library() function that builds shared and/or static libraries per the user's preference Add support for generating pkg-config .pc files Allow executing files that require an interpreter or other wrapper via command() or test() / test_driver() without explicitly specifying the wrapper; supports all languages buildable by bfg9000, plus Lua, Perl, Python, and Ruby Add env.run() , env.execute() , and env.run_arguments() to simplify executing programs during configuration Add a framework() function to specify macOS frameworks to use for a build Improve detection of compiler flavors by checking version information Automatically colorize clang/gcc output under Ninja Add support for uninstalling builds Add static_link_options to static_library() to specify options to pass to the static linker Add a bfg9000 env command to print the environment variables used during configuration Automatically request sudo elevation when installing builds to a system directory Breaking changes \u00a7 directory() and header_directory() no longer automatically include all files within them (pass include='*' for the old behavior) The include argument for compiling object files has been replaced by includes When creating a static library, link_options now specifies options that will be forwarded along to the dynamic linker, rather than options for the static linker itself The options argument for test() / test_driver() has been deprecated; add any options to the first argument ( cmd ) instead test() no longer converts its first argument to a generic_file() Splitting POSIX shell strings (used for compile and link options as well as environment vars on POSIX like CPPFLAGS ) no longer parses escape characters Bug fixes \u00a7 Improve logging of syntax errors in build.bfg files Fix usage of nested shared libraries when linking with GNU ld (via -rpath-link ) Installing directories from the srcdir now correctly installs their contents to the installation root for that type (e.g. a header directory of foo/bar installs its contents to $includedir ) Fix generation of dependencies for the tests target Improve escaping for paths when using Make on Windows (previously users had to escape backslashes themselves) Fix an issue with quotation marks being stripped for some commands on Windows with the Ninja backend v0.2.0 \u00a7 2016-06-26 New features \u00a7 Support Objective C/C++ Partially support Fortran (simple projects work, but more complex things probably don't) Improved error reporting Warn users if necessary build tools can't be found by bfg9000 Automatically include runtime dependencies when installing a binary Support @rpath on OS X Allow fetching bfg's version from build.bfg files via bfg9000_version Support versioning of shared libraries on POSIX systems Support resolving packages via pkg-config Locally-built static libraries now forward their options to binaries that link to them whole_archive() now forwards its arguments on to static_library() Use doppel for installing files instead of install(1) Support command() and alias() rules under MSBuild Add support for building a distribution of the sources ( make dist ) Allow running custom build steps via build_step() Breaking changes \u00a7 Configuring a build is now performed by bfg9000 configure DIRECTORY header() renamed to header_file() env.compiler(lang) replaced by env.builder(lang).compiler env.linker(lang, mode) replaced by env.builder(lang).linker(mode) env.compiler(lang).flavor replaced by env.builder(lang).flavor Bug fixes \u00a7 Fix fetching CFLAGS from the environment (it used to try CCFLAGS ) Fix execution context of build.bfg files; this caused strange issues with list/generator comprehensions v0.1.1 \u00a7 2016-01-21 Fix an issue with installing the package from PyPI v0.1.0 \u00a7 2016-01-20 Initial release Support for C and C++ builds on Linux, Mac, and Windows (MinGW included) via Make, Ninja, and MSBuild.","title":"Changes"},{"location":"/about/changes/#changes","text":"","title":"Changes"},{"location":"/about/changes/#v030","text":"2018-06-01","title":"v0.3.0"},{"location":"/about/changes/#new-features","text":"Replace system_package() and pkgconfig_package() with a generic package resolver: package() Add headers argument to package() to find header files and libs to specify library names if pkg-config lookup fails Support Java/Scala Add support for user-defined arguments Add a library() function that builds shared and/or static libraries per the user's preference Add support for generating pkg-config .pc files Allow executing files that require an interpreter or other wrapper via command() or test() / test_driver() without explicitly specifying the wrapper; supports all languages buildable by bfg9000, plus Lua, Perl, Python, and Ruby Add env.run() , env.execute() , and env.run_arguments() to simplify executing programs during configuration Add a framework() function to specify macOS frameworks to use for a build Improve detection of compiler flavors by checking version information Automatically colorize clang/gcc output under Ninja Add support for uninstalling builds Add static_link_options to static_library() to specify options to pass to the static linker Add a bfg9000 env command to print the environment variables used during configuration Automatically request sudo elevation when installing builds to a system directory","title":"New features"},{"location":"/about/changes/#breaking-changes","text":"directory() and header_directory() no longer automatically include all files within them (pass include='*' for the old behavior) The include argument for compiling object files has been replaced by includes When creating a static library, link_options now specifies options that will be forwarded along to the dynamic linker, rather than options for the static linker itself The options argument for test() / test_driver() has been deprecated; add any options to the first argument ( cmd ) instead test() no longer converts its first argument to a generic_file() Splitting POSIX shell strings (used for compile and link options as well as environment vars on POSIX like CPPFLAGS ) no longer parses escape characters","title":"Breaking changes"},{"location":"/about/changes/#bug-fixes","text":"Improve logging of syntax errors in build.bfg files Fix usage of nested shared libraries when linking with GNU ld (via -rpath-link ) Installing directories from the srcdir now correctly installs their contents to the installation root for that type (e.g. a header directory of foo/bar installs its contents to $includedir ) Fix generation of dependencies for the tests target Improve escaping for paths when using Make on Windows (previously users had to escape backslashes themselves) Fix an issue with quotation marks being stripped for some commands on Windows with the Ninja backend","title":"Bug fixes"},{"location":"/about/changes/#v020","text":"2016-06-26","title":"v0.2.0"},{"location":"/about/changes/#new-features_1","text":"Support Objective C/C++ Partially support Fortran (simple projects work, but more complex things probably don't) Improved error reporting Warn users if necessary build tools can't be found by bfg9000 Automatically include runtime dependencies when installing a binary Support @rpath on OS X Allow fetching bfg's version from build.bfg files via bfg9000_version Support versioning of shared libraries on POSIX systems Support resolving packages via pkg-config Locally-built static libraries now forward their options to binaries that link to them whole_archive() now forwards its arguments on to static_library() Use doppel for installing files instead of install(1) Support command() and alias() rules under MSBuild Add support for building a distribution of the sources ( make dist ) Allow running custom build steps via build_step()","title":"New features"},{"location":"/about/changes/#breaking-changes_1","text":"Configuring a build is now performed by bfg9000 configure DIRECTORY header() renamed to header_file() env.compiler(lang) replaced by env.builder(lang).compiler env.linker(lang, mode) replaced by env.builder(lang).linker(mode) env.compiler(lang).flavor replaced by env.builder(lang).flavor","title":"Breaking changes"},{"location":"/about/changes/#bug-fixes_1","text":"Fix fetching CFLAGS from the environment (it used to try CCFLAGS ) Fix execution context of build.bfg files; this caused strange issues with list/generator comprehensions","title":"Bug fixes"},{"location":"/about/changes/#v011","text":"2016-01-21 Fix an issue with installing the package from PyPI","title":"v0.1.1"},{"location":"/about/changes/#v010","text":"2016-01-20 Initial release Support for C and C++ builds on Linux, Mac, and Windows (MinGW included) via Make, Ninja, and MSBuild.","title":"v0.1.0"},{"location":"/about/license/","text":"License \u00a7 BSD 3-clause license \u00a7 Copyright (c) 2015-2018, Jim Porter All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"/about/license/#license","text":"","title":"License"},{"location":"/about/license/#bsd-3-clause-license","text":"Copyright (c) 2015-2018, Jim Porter All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"BSD 3-clause license"}]}